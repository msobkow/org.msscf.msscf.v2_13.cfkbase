<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	Mark's Code Fractal CFKBase 3.1 Code Fractal Knowledge Base
 *
 *	Copyright 2016-2025 Mark Stephen Sobkow
 *
 *	This file is part of Mark's Code Fractal CFKBase.
 *
 *	Mark's Code Fractal CFKBase is available under dual commercial license from
 *	Mark Stephen Sobkow, or under the terms of the GNU General Public License,
 *	Version 3 or later.
 *
 *	Mark's Code Fractal CFKBase is free software: you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	Mark's Code Fractal CFKBase is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Mark's Code Fractal CFKBase.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 *
 *	If you wish to modify and use this code without publishing your changes,
 *	or integrate it with proprietary code, please contact Mark Stephen Sobkow
 *	for a commercial license at mark.sobkow@gmail.com
 * -->
<RuleSet
	xmlns="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="java"
	Name="src/Schema/jpa/SchemaJpaTableRepository.java"
	Revision="3.0"
	Descr="Java Spring JPA Repository for $TableName$">

	<GenFile GenDef="Table" Name="fileSchemaJpaTableRepositoryJava"
			GenerateOnce="false"
		ModuleName="$reference ManufacturingSchema lower JavaPackage$.jpa"
		SourceBundle="java"
		BasePackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$/src/main/java"
		SubPackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.jpa"
		ExpansionClassName="$SchemaName$Jpa$TableName$RepositoryJava"
		ExpansionKeyName="$SchemaName$Jpa$TableName$RepositoryJava"
		ExpansionFileName="$SchemaName$Jpa$TableName$Repository.java"
>// Description: Java Spring JPA Repository for $TableName$

$MssSourceLicense$

package $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.jpa;

import java.io.Serializable;
import java.math.*;
import java.time.*;
import java.util.*;
import jakarta.persistence.*;
import server.markhome.mcf.v3_1.cflib.*;
import server.markhome.mcf.v3_1.cflib.dbutil.*;
import server.markhome.mcf.v3_1.cflib.xml.CFLibXmlUtil;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.text.StringEscapeUtils;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.data.jpa.repository.Lock;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.transaction.annotation.Transactional;$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaName empty empty )$
import $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;

/**
 *	JpaRepository for the $SchemaName$Jpa$TableName$ entities defined in $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.jpa.
 *	The manufactured repositories try to provide a rich, do-it-all interface to the JPA data store, with both object and argument-based implementations of the interface defined.
 */
@Transactional(readOnly = true)
public interface $SchemaName$Jpa$TableName$Repository extends JpaRepository&lt;$SchemaName$Jpa$TableName$, $JpaCompactedPrimaryIndexClass$&gt; {
$declTableReaders$$declTableLockers$$declTableDeleters$
}
</GenFile>

	<GenRule GenDef="Atom" Name="effDbColName">$switch HasDbName yes DbName default Name$</GenRule>
	<GenRule GenDef="TableCol" Name="effDbColName">$switch HasDbName yes DbName default Name$</GenRule>
	<GenRule GenDef="IndexCol" Name="effDbColName">$reference Column switch HasDbName yes DbName default Name$</GenRule>
	<GenRule GenDef="RelationCol" Name="effFromDbColName">$reference FromCol switch HasDbName yes DbName default Name$</GenRule>
	<GenRule GenDef="RelationCol" Name="effToDbColName">$reference ToCol switch HasDbName yes DbName default Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="emitJpaColumnArgumentComment">
	 *		@param $leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>

	<GenRule GenDef="Table" Name="declJpaRepositoryGet">
	/**
	 *	Argument-based get database instance for compatibility with the current MSS code factory code base.
	 *$reference BaseClass reference PrimaryKeyIndex iterate Columns( each emitJpaColumnArgumentComment )$
	 *
	 *		@return The retrieved entity, usually from the JPA cache, or null if no such entity exists.
	 */
	@Query("select r from $poptop Table DefSchemaName$Jpa$TableName$ r where $reference BaseClass reference PrimaryKeyIndex iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	$poptop Table SchemaName$Jpa$poptop Table TableName$ get($reference BaseClass reference PrimaryKeyIndex iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);
$switch IsPrimaryIndexKeyAtomic yes empty default declJpaRepositoryGetByPKeyObj$</GenRule>

	<GenRule GenDef="Table" Name="declJpaRepositoryGetByPKeyObj">
	/**
	 *	$SchemaName$$TableName$PKey based read method for object-based access.
	 *
	 *		@param key The key of the entity to be read.
	 *
	 *		@return The entity read, usually from the JPA cache, or null if no such entity exists.
	 */
	default $poptop Table SchemaName$Jpa$poptop Table TableName$ get(I$SchemaName$$TableName$PKey key) {
		return( get($reference BaseClass reference PrimaryKeyIndex iterate Columns(first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$));
	}
</GenRule>


	<GenRule GenDef="Table" Name="declTableLockers">$switch HasSuperClassRelation yes declInheritedTableLockers default empty$
	// $SchemaName$Jpa$TableName$ specified delete-by-index methods
$iterate Index(each maybeDeclJpaRepositoryLocker empty empty)$</GenRule>

	<GenRule GenDef="Table" Name="declInheritedTableLockers">$reference SuperClassRelation reference ToTable declTableLockers$</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclJpaRepositoryLocker">$switch IsPrimaryIndex yes maybeDeclJpaRepositoryLockerIfBaseTable default declJpaRepositoryLock$</GenRule>
	<GenRule GenDef="Index" Name="maybeDeclJpaRepositoryLockerIfBaseTable">$switch TableHasSuperClassRelation yes empty default declJpaRepositoryLockPKey$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryLockPKey">
	/**
	 *	Argument-based lock database entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity locks, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	@Transactional
	@Lock(LockModeType.WRITE)
	@Query("select r from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	$poptop Table SchemaName$Jpa$poptop Table TableName$ lockBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);
$switch IsPrimaryIndexKeyAtomic yes empty default declJpaRepositoryLockPKeyByObj$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryLockPKeyByObj">
	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The key of the entity to be locked.
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	default $poptop Table SchemaName$Jpa$poptop Table TableName$ lockBy$Suffix$(I$SchemaName$$TableName$PKey key) {
		return( lockBy$Suffix$($iterate Columns(first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryLock">$switch IsUnique yes declJpaRepositoryLockSingle default declJpaRepositoryLockMultiple$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryLockSingle">
	/**
	 *	Argument-based lock database entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity locks, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	@Transactional
	@Lock(LockModeType.WRITE)
	@Query("select r from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	$poptop Table SchemaName$Jpa$poptop Table TableName$ lockBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The key of the entity to be locked.
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	default $poptop Table SchemaName$Jpa$poptop Table TableName$ lockBy$Suffix$(I$SchemaName$$TableName$By$Suffix$Key key) {
		return( lockBy$Suffix$($iterate Columns(first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryLockMultiple">
	/**
	 *	Argument-based lock database instance for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity locks, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return A list of locked entities, refreshed from the data store, or an empty list if no such entities exist.
	 */
	@Transactional
	@Lock(LockModeType.WRITE)
	@Query("select r from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	List&lt;$poptop Table SchemaName$Jpa$poptop Table TableName$&gt; lockBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The key of the entity to be locked.
	 *
	 *		@return A list of locked entities, refreshed from the data store, or an empty list if no such entities exist.
	 */
	default List&lt;$poptop Table SchemaName$Jpa$poptop Table TableName$&gt; lockBy$Suffix$(I$SchemaName$$TableName$By$Suffix$Key key) {
		return( lockBy$Suffix$($iterate Columns(first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="Table" Name="declTableDeleters">$switch HasSuperClassRelation yes declInheritedTableDeleters default empty$
	// $SchemaName$Jpa$TableName$ specified delete-by-index methods
$iterate Index(each maybeDeclJpaRepositoryDeleter empty empty)$</GenRule>

	<GenRule GenDef="Table" Name="declInheritedTableDeleters">$reference SuperClassRelation reference ToTable declTableDeleters$</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclJpaRepositoryDeleter">$switch IsPrimaryIndex yes maybeDeclJpaRepositoryDeleterIfBaseTable default declJpaRepositoryDelete$</GenRule>
	<GenRule GenDef="Index" Name="maybeDeclJpaRepositoryDeleterIfBaseTable">$switch TableHasSuperClassRelation yes empty default declJpaRepositoryDeleteByPKey$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryDeleteByPKey">
	/**
	 *	Argument-based delete entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity lock, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 */
	@Transactional
	@Modifying
	@Query("delete from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	void deleteBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);
$switch IsPrimaryIndexKeyAtomic yes empty default declJpaRepositoryDeleteByPKeyObj$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryDeleteByPKeyObj">
	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key of the entity to be locked.
	 */
	default void deleteBy$Suffix$(I$SchemaName$$TableName$PKey key) {
		deleteBy$Suffix$($iterate Columns(first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$);
	}
</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryDelete">
	/**
	 *	Argument-based delete entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity lock, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 */
	@Transactional
	@Modifying
	@Query("delete from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	void deleteBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key of the entity to be locked.
	 */
	default void deleteBy$Suffix$(I$SchemaName$$TableName$By$Suffix$Key key) {
		deleteBy$Suffix$($iterate Columns(first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$);
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="commaDeclJpaRepositoryPassKeyAttr">, $declJpaRepositoryPassKeyAttr$</GenRule>
	<GenRule GenDef="IndexCol" Name="declJpaRepositoryPassKeyAttr">key.get$reference Column implColumnAttrOptionality$$reference Column Name$()</GenRule>

	<GenRule GenDef="Table" Name="declTableReaders">$switch HasSuperClassRelation yes declInheritedTableReaders default declJpaRepositoryGet$
	// $SchemaName$Jpa$TableName$ specified index readers
$iterate Index(each maybeDeclJpaRepositoryReader empty empty)$</GenRule>
	<GenRule GenDef="Table" Name="declInheritedTableReaders">$reference SuperClassRelation reference ToTable declTableReaders$</GenRule>

	<GenRule GenDef="IndexCol" Name="declJpaRepositoryGetArgument">$reference Column implJavaAtomType$ $leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>
	<GenRule GenDef="IndexCol" Name="commaDeclJpaRepositoryGetArgument">,
		$declJpaRepositoryGetArgument$</GenRule>

	<GenRule GenDef="IndexCol" Name="setJpaRepositoryKeyAttr">
		key.set$reference Column implColumnAttrOptionality$$reference Column Name$( $leadlower reference Column implColumnAttrOptionality$$reference Column Name$ );</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclJpaRepositoryReader">$switch IsPrimaryIndex yes empty default declJpaRepositoryReader$</GenRule>
	<GenRule GenDef="Index" Name="declJpaRepositoryReader">$switch IsUnique yes declJpaRepositoryReadSingle default declJpaRepositoryReadList$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryReadSingle">
	/**
	 *	Read an entity using the columns of the $SchemaName$$TableName$By$Suffix$Key as arguments.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return The found entity, typically from the JPA cache, or null if no such entity exists.
	 */
	@Query("select r from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	$poptop Table SchemaName$Jpa$poptop Table TableName$ findBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key entity reader convenience method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key instance to use for the query arguments.
	 *
	 *		@return The found entity, typically from the JPA cache, or null if no such entity exists.
	 */
	default $poptop Table SchemaName$Jpa$poptop Table TableName$ findBy$Suffix$(I$SchemaName$$TableName$By$Suffix$Key key) {
		return( findBy$Suffix$($iterate Columns( first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="commaDeclJpaRepositoryQueryColumnArg"> and $declJpaRepositoryQueryColumnArg$</GenRule>
	<!--GenRule GenDef="IndexCol" Name="declJpaRepositoryQueryColumnArg">r.$effDbColName$ = :$leadlower reference Column Name$</GenRule-->
	<GenRule GenDef="IndexCol" Name="declJpaRepositoryQueryColumnArg">$switch ColumnInPrimaryIndex yes maybeDerefJpaRepositoryQueryColumnArg default simpleJpaRepositoryQueryColumnArg$</GenRule>
	<GenRule GenDef="IndexCol" Name="maybeDerefJpaRepositoryQueryColumnArg">$switch IsPrimaryIndexKeyAtomic yes simpleJpaRepositoryQueryColumnArg default derefJpaRepositoryQueryColumnArg$</GenRule>
	<GenRule GenDef="IndexCol" Name="simpleJpaRepositoryQueryColumnArg">r.$leadlower reference Column implColumnAttrOptionality$$reference Column Name$ = :$leadlower reference Column Name$</GenRule>
	<GenRule GenDef="IndexCol" Name="derefJpaRepositoryQueryColumnArg">r.pkey.$leadlower reference Column implColumnAttrOptionality$$reference Column Name$ = :$leadlower reference Column Name$</GenRule>

	<GenRule GenDef="Index" Name="declJpaRepositoryReadList">
	/**
	 *	Read zero or more entities into a List using the columns of the $SchemaName$$TableName$By$Suffix$Key as arguments.
	 *$iterate Columns( each emitJpaColumnArgumentComment )$
	 *
	 *		@return List&amp;lt;$poptop Table SchemaName$Jpa$poptop Table TableName$&amp;gt; of the found entities, typically from the JPA cache, or an empty list if no such entities exist.
	 */
	@Query("select r from $poptop Table DefSchemaName$Jpa$TableName$ r where $iterate Columns( first declJpaRepositoryQueryColumnArg each commaDeclJpaRepositoryQueryColumnArg)$")
	List&lt;$poptop Table SchemaName$Jpa$poptop Table TableName$&gt; findBy$Suffix$($iterate Columns(first declJpaRepositoryArgument each commaDeclJpaRepositoryArgument)$);

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key entity list reader convenience method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key instance to use for the query arguments.
	 *
	 *		@return The found entity list, which may be empty, typically populated from the JPA cache.
	 */
	default List&lt;$poptop Table SchemaName$Jpa$poptop Table TableName$&gt; findBy$Suffix$(I$SchemaName$$TableName$By$Suffix$Key key) {
		return( findBy$Suffix$($iterate Columns( first declJpaRepositoryPassKeyAttr each commaDeclJpaRepositoryPassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="commaDeclJpaRepositoryArgument">,
		$declJpaRepositoryArgument$</GenRule>
	<GenRule GenDef="IndexCol" Name="declJpaRepositoryArgument">@Param("$reference Column leadlower Name$") $reference Column implJavaAtomType$ $leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>

</RuleSet>
