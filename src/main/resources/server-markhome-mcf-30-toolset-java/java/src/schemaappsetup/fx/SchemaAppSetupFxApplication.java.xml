<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	Mark's Code Fractal CFKBase 3.1 Code Fractal Knowledge Base
 *
 *	Copyright 2016-2025 Mark Stephen Sobkow
 *
 *	This file is part of Mark's Code Fractal CFKBase.
 *
 *	Mark's Code Fractal CFKBase is available under dual commercial license from
 *	Mark Stephen Sobkow, or under the terms of the GNU General Public License,
 *	Version 3 or later.
 *
 *	Mark's Code Fractal CFKBase is free software: you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	Mark's Code Fractal CFKBase is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Mark's Code Fractal CFKBase.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 *
 *	If you wish to modify and use this code without publishing your changes,
 *	or integrate it with proprietary code, please contact Mark Stephen Sobkow
 *	for a commercial license at mark.sobkow@gmail.com
 * -->
<RuleSet
	xmlns="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="java"
	Name="src/schemaappsetup/fx/SchemaAppSetupFxApplication.java"
	Revision="3.0"
	Descr="Java 21 Main for test creation of the JPA database for the schema">

	<GenFile GenDef="SchemaDef" Name="fileSchemaAppSetupFxApplicationJava"
			GenerateOnce="false"
		ModuleName="$reference ManufacturingSchema lower JavaPackage$"
		SourceBundle="java"
		BasePackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$appsetup/src/main/java"
		SubPackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$appsetup.fx"
		ExpansionClassName="$SchemaName$AppSetupFxApplicationJava"
		ExpansionKeyName="$SchemaName$AppSetupFxApplicationJava"
		ExpansionFileName="$SchemaName$AppSetupFxApplication.java">
// Description: JavaFX Application Setup entry point

$MssSourceLicense$

package $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$appsetup.fx;

import java.lang.reflect.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.*;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.rmi.*;
import java.sql.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.core.env.ConfigurableEnvironment;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.text.StringEscapeUtils;
import server.markhome.mcf.v3_1.cflib.*;
import server.markhome.mcf.v3_1.cflib.inz.Inz;
import server.markhome.mcf.v3_1.cflib.inz.InzPathEntry;
import server.markhome.mcf.v3_1.cflib.dbutil.*;$iterate SchemaRefs( each importJavaPackageSchemaName empty empty )$
import $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.*;$iterate SchemaRefs( each importJavaPackageSchemaNameBuff empty empty )$
import $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.buff.*;
import $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.appsetup.fx.$SchemaName$AppSetupFxApplication;
$AppSetupFxApplicationClassBody$
</GenFile>

<GenRule GenDef="SchemaDef" Name="AppSetupFxApplicationClassBody">
@Component
public class $SchemaName$AppSetupFxApplication extends Application {

	public static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger($reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.appsetup.fx.$SchemaName$AppSetupFxApplication.class.getName());

	public static String INIT_LOG_MESSAGE1 = "The $SchemaName$AppSetupFxApplication init method is called";

	private static $SchemaName$AppSetupFxApplication instance = null;

	private Parent rootNode = null;

	private Scene scene;

	private Stage stage = null;

	@Override
	public void init() throws Exception {
		//Only initialize once
		if (getInstance() != null ) {
			return;

		}
		logMessage(INIT_LOG_MESSAGE1);

		ApplicationContextInitializer&lt;GenericApplicationContext&gt; initializer = ac -&gt; {
			ac.registerBean(Application.class, () -&gt; $SchemaName$AppSetupFxApplication.this);
			ac.registerBean(Parameters.class, () -&gt; getParameters());
			ac.registerBean(HostServices.class, () -&gt; getHostServices());
		};

		this.context = new SpringApplicationBuilder().sources($SchemaName$AppSetup.class).initializers(initializer)
				.run(getParameters().getRaw().toArray(new String[0]));

		// provide a handle for the testing framework to inspect
		setInstance(this);
	}

	//This method exists so that the correct behavior and existence of the logger can be tested separately from within a junit test
	// because this class $SchemaName$AppSetupFxApplication extends Application the failure of the logger may be more likely than POJOs
	public static void logMessage(String message) {
		log.info(message);
	}

	private void setUpParameterOverride() {
		Map&lt;String, String&gt; parameterMap;
		Parameters javaFxParameters = getParameters();
		if (javaFxParameters != null) {
			parameterMap = javaFxParameters.getNamed();
			for (String key : parameterMap.keySet()) {
				switch (key) {
				case "interpretation" -&gt; javaFxResource
						.setInterpretation(StreamInterpretation.valueOf(parameterMap.get("interpretation")));
				case "defaultResource" -&gt; javaFxResource.setDefaultResource(parameterMap.get("defaultResource"));
				default -&gt; {}
				}
			}
		}
	}

	@Override
	public void start(Stage stage) {
		String logRootPropertyString = System.getProperty("LOG_ROOT");
		String logRootPropertyMessage ="The $SchemaName$AppSetupFxApplication sees System Property LOG_ROOT: &gt;&gt;&gt;"+logRootPropertyString+"&lt;&lt;&lt;";
		logMessage(logRootPropertyMessage);
		// Save the stage
		setStage(stage);
		// Set the stage to not always on top
		stage.setAlwaysOnTop(false);
		// Set the title of the stage
		stage.setTitle("$SchemaName$ Application Setup");
		// Make the stage available through javaFxResource
		javaFxResource.setStage(getStage());
		double sceneMargin = 5; // some margin at the edge of the scene
		String message = "The $SchemaName$AppSetupFxApplication start method is called";
		log.info( message);
//		getLoader().setControllerFactory(context::getBean);
		setUpParameterOverride();
		rootNode = getRoot();

		double defaultWidth = 100;
		double defaultHeight = 100;
		if (rootNode instanceof Region) {
			defaultWidth = ((Region) rootNode).getPrefWidth() + sceneMargin;
			defaultHeight = ((Region) rootNode).getPrefHeight() + sceneMargin;
		}
		// Override the preferences if there is a resource setting
		double fxResourceWidth = javaFxResource.getRootSceneWidth();
		double fxResourceHeight = javaFxResource.getRootSceneHeight();
		defaultWidth = (fxResourceWidth != 0.0) ? defaultWidth : fxResourceWidth;
		defaultHeight = (fxResourceHeight != 0.0) ? defaultHeight : fxResourceHeight;
		scene = new Scene(rootNode, defaultWidth, defaultHeight);
		stage.setScene(scene);
		stage.show();
	}

	@Override
	public void stop() throws Exception {
		stage.close();
		setInstance(null);
		context.close();
		System.gc();
		System.runFinalization();
		Platform.exit();
	}

	public Parent getRoot() {
		if (javaFxResource != null) {
		logMessage("getRoot javaFxResource is not null");
		} else {
			logMessage("getRoot javaFxResource is null");
		}
		return getRoot(javaFxResource.getDefaultResourceStream());
	}

	public static Parent getRoot(InputStream inputStream) {
		if (inputStream == null) {
			String message = "The input stream is null.";
			throw new MmsRuntimeException(message);
		}
		Parent result = null;
		try {
			FXMLLoader aLoader = getInstance().getLoader();
			result = aLoader.getRoot();
			if (JavaFxResource.locationUrl != null) {
				URL aLocation = JavaFxResource.locationUrl;
				aLoader.setLocation(aLocation);
			}
			if (result == null) {
				Parent layout = (Parent) aLoader.load(inputStream);
				result = layout;
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new MmsRuntimeException(e.getMessage());
		}
		return result;
	}

	public static $SchemaName$AppSetupFxApplication getInstance() {
		return instance;
	}

	public static void setInstance($SchemaName$AppSetupFxApplication instance) {
		$SchemaName$AppSetupFxApplication.instance = instance;
	}

	public void main(String[] args) {
		SpringApplication.run($SchemaName$AppSetupFxApplication.class, args);
	}
}
</GenRule>

</RuleSet>
