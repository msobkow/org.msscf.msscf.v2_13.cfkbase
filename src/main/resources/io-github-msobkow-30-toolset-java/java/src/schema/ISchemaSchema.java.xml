<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	Mark's Code Fractal CFKBase 3.1 Code Fractal Knowledge Base
 *
 *	Copyright 2016-2026 Mark Stephen Sobkow
 *
 *	This file is part of Mark's Code Fractal CFKBase.
 *
 *	Mark's Code Fractal CFKBase is available under dual commercial license from
 *	Mark Stephen Sobkow, or under the terms of the GNU General Public License,
 *	Version 3 or later.
 *
 *	Mark's Code Fractal CFKBase is free software: you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	Mark's Code Fractal CFKBase is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Mark's Code Fractal CFKBase.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 *
 *	If you wish to modify and use this code without publishing your changes,
 *	or integrate it with proprietary code, please contact Mark Stephen Sobkow
 *	for a commercial license at mark.sobkow@gmail.com
 * -->
<RuleSet
	xmlns="https://msobkow.github.io/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="https://msobkow.github.io/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd https://msobkow.github.io/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="java"
	Name="src/schema/ISchemaSchema.java"
	Revision="3.0"
	Descr="Java 25 interface for a $SchemaName$ schema.">

	<GenFile GenDef="SchemaDef" Name="fileSchemaISchemaJava"
			GenerateOnce="false"
		ModuleName="$reference ManufacturingSchema lower JavaPackage$"
		SourceBundle="java"
		BasePackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$/src/main/java"
		SubPackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$"
		ExpansionClassName="I$SchemaName$SchemaJava"
		ExpansionKeyName="I$SchemaName$SchemaJava"
		ExpansionFileName="I$SchemaName$Schema.java"
>// Description: Java 25 interface for a $SchemaName$ schema.

$MssSourceLicense$

package $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$;

import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.math.*;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.*;
import java.util.*;
import java.util.concurrent.atomic.*;
import io.github.msobkow.v3_1.cflib.*;
import io.github.msobkow.v3_1.cflib.dbutil.*;
import io.github.msobkow.v3_1.cflib.xml.CFLibXmlUtil;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.text.StringEscapeUtils;$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaName empty empty )$

public interface I$SchemaName$Schema$iterate SchemaRefs( first extendsPackageSchemaName each commaNewlinePackageSchemaName empty empty )$
{
	public static final String SCHEMA_NAME = "$SchemaName$";
	public static final String DBSCHEMA_NAME = "$DbSchemaName$";
$iterate SchemaRefs( each empty empty declISchemaClassMapEntry )$$declISchemaClassMapData$$iterate Types( empty empty each declISchemaEnumType )$$iterate SchemaRefs( empty declISchemaSecurityAttrs each empty )$$implISchemaClassMapAccessors$$iterate SchemaRefs( first declNewSchema each empty empty declNewSchema )$$iterate Id16Generators( each declNextIdGen empty empty)$$iterate Id32Generators( each declNextIdGen empty empty)$$iterate Id64Generators( each declNextIdGen empty empty)$$iterate DbKeyHash128Generators( each declNextIdGen empty empty )$$iterate DbKeyHash160Generators( each declNextIdGen empty empty )$$iterate DbKeyHash224Generators( each declNextIdGen empty empty )$$iterate DbKeyHash256Generators( each declNextIdGen empty empty )$$iterate DbKeyHash384Generators( each declNextIdGen empty empty )$$iterate DbKeyHash512Generators( each declNextIdGen empty empty )$$iterate UuidGenerators( each declNextIdGen empty empty )$$iterate Uuid6Generators( each declNextIdGen empty empty )$$iterate SchemaTables( each declTableMethods empty empty )$$iterate SchemaRefs( first declSchemaTablePermsAccessors each empty empty declSchemaTablePermsAccessors )$$declSchemaBootstrap$}
</GenFile>

	<GenRule GenDef="Object" Name="importsForApplicationContextAware">
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;</GenRule>

	<GenRule GenDef="Object" Name="implementsApplicationContextAware"> implements ApplicationContextAware</GenRule>

	<GenRule GenDef="Object" Name="commaApplicationContextAware">, ApplicationContextAware</GenRule>

	<GenRule GenDef="Object" Name="declApplicationContextAwareContext">
	private static ApplicationContext applicationContext = null;</GenRule>

	<GenRule GenDef="Object" Name="implApplicationContextAwareSetApplicationContext">
	@Override
	public void setApplicationContext(final ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}

	public static ApplicationContext getApplicationContext() {
		return( applicationContext );
	}
</GenRule>

	<GenRule GenDef="Object" Name="declISchemaSecurityAttrs">
	static final AtomicReference&lt;CFLibDbKeyHash256&gt; sysClusterId = new AtomicReference&lt;&gt;();
	static final AtomicReference&lt;CFLibDbKeyHash256&gt; sysTenantId = new AtomicReference&lt;&gt;();
	static final AtomicReference&lt;CFLibDbKeyHash256&gt; sysAdminId = new AtomicReference&lt;&gt;();

	public static String getPasswordHash(String pw) {
		if (pw == null || pw.isEmpty()) {
			throw new CFLibNullArgumentException(I$SecSchemaName$Schema.class, "getPasswordHash", 1, "pw");
		}
		try {
			MessageDigest md = MessageDigest.getInstance("SHA-512");
            byte[] bytes = md.digest(pw.getBytes(StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt; bytes.length; i++) {
                sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16).substring(1));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
	}

	public static CFLibDbKeyHash256 getSysClusterId() {
		return (sysClusterId.get());
	}

	public static void setSysClusterId(CFLibDbKeyHash256 argClusterId) {
		if (argClusterId == null || argClusterId.isNull()) {
			throw new CFLibNullArgumentException(I$SchemaName$Schema.class, "setSysClusterId", 1, "argClusterId");
		}
		CFLibDbKeyHash256 oldid = sysClusterId.get();
		if (oldid == null) {
			sysClusterId.compareAndSet(null, argClusterId);
		}
		else if (oldid.isNull()) {
			sysClusterId.compareAndSet(oldid, argClusterId);
		}
		else {
			throw new CFLibInvalidArgumentException(I$SchemaName$Schema.class, "setSysClusterId", "sysClusterId has already been set", "sysClusterId has already been set");
		}
	}

	public static CFLibDbKeyHash256 getSysTenantId() {
		return (sysTenantId.get());
	}

	public static void setSysTenantId(CFLibDbKeyHash256 argTenantId) {
		if (argTenantId == null || argTenantId.isNull()) {
			throw new CFLibNullArgumentException(I$SchemaName$Schema.class, "setSysTenantId", 1, "argTenantId");
		}
		CFLibDbKeyHash256 oldid = sysTenantId.get();
		if (oldid == null) {
			sysTenantId.compareAndSet(null, argTenantId);
		}
		else if (oldid.isNull()) {
			sysTenantId.compareAndSet(oldid, argTenantId);
		}
		else {
			throw new CFLibInvalidArgumentException(I$SchemaName$Schema.class, "setSysTenantId", "sysTenantId has already been set", "sysTenantId has already been set");
		}
	}

	public static CFLibDbKeyHash256 getSysAdminId() {
		return (sysAdminId.get());
	}

	public static void setSysAdminId(CFLibDbKeyHash256 argAdminId) {
		if (argAdminId == null || argAdminId.isNull()) {
			throw new CFLibNullArgumentException(I$SchemaName$Schema.class, "setSysAdminId", 1, "argAdminId");
		}
		CFLibDbKeyHash256 oldid = sysAdminId.get();
		if (oldid == null) {
			sysAdminId.compareAndSet(null, argAdminId);
		}
		else if (oldid.isNull()) {
			sysAdminId.compareAndSet(oldid, argAdminId);
		}
		else {
			throw new CFLibInvalidArgumentException(I$SchemaName$Schema.class, "setSysAdminId", "sysAdminId has already been set", "sysAdminId has already been set");
		}
	}
</GenRule>

<GenRule GenDef="SchemaDef" Name="declSchemaBootstrap">
	public void bootstrapSchema();
</GenRule>

<GenRule GenDef="Object" Name="declISchemaClassMapEntry">
	public static interface BackingRecConstructor {
		public Object instantiate();
	}
	
	public static class ClassMapEntry {
		final String schemaName;
		final String tableName;
		final int backingClassCode;
		int runtimeClassCode;
		BackingRecConstructor cbRecConstructor;
		
		public ClassMapEntry(String schemaName, String tableName, int backingClassCode) {
			this.schemaName = schemaName;
			this.tableName = tableName;
			this.backingClassCode = backingClassCode;
			runtimeClassCode = 0;
			cbRecConstructor = null;
		}
		
		public String getSchemaName() { return schemaName; }
		public String getTableName() { return tableName; }
		public int getBackingClassCode() { return backingClassCode; }

		public int getRuntimeClassCode() { return runtimeClassCode; }
		public void setRuntimeClassCode(int runtimeClassCode) { this.runtimeClassCode = runtimeClassCode; }
		
		public BackingRecConstructor getBackingRecConstructor() { return cbRecConstructor; }
		public void setBackingRecConstructor(BackingRecConstructor backingRecConstructor) { this.cbRecConstructor = backingRecConstructor; }
	}
</GenRule>

	<GenRule GenDef="SchemaDef" Name="declISchemaClassMapData">
		final static ArrayList&lt;I$SecSchemaName$Schema.ClassMapEntry&gt; entries = new ArrayList&lt;&gt;();
		final static HashMap&lt;Integer,I$SecSchemaName$Schema.ClassMapEntry&gt; mapBackingClassCodeToEntry = new HashMap&lt;&gt;();
		final static HashMap&lt;Integer,I$SecSchemaName$Schema.ClassMapEntry&gt; mapRuntimeClassCodeToEntry = new HashMap&lt;&gt;();
		final static AtomicReference&lt;I$SchemaName$Schema&gt; backing$SchemaName$ = new AtomicReference&lt;&gt;();</GenRule>

	<GenRule GenDef="SchemaDef" Name="implISchemaClassMapAccessors">
		public static I$SchemaName$Schema getBacking$SchemaName$() {
			return( I$SchemaName$Schema.backing$SchemaName$.get() );
		}
		
		public static void setBacking$SchemaName$(I$SchemaName$Schema backingSchema) {
			I$SchemaName$Schema.backing$SchemaName$.set(backingSchema);
		}
		
		public I$SchemaName$Schema get$SchemaName$Schema();
		public void set$SchemaName$Schema(I$SchemaName$Schema schema);
		
		public static int doInitClassMapEntries(int value) {$iterate SchemaRefs( each invokeSuperISchemaInitClassMapEntries empty empty )$
			if (I$SchemaName$Schema.entries.isEmpty()) {
				I$SecSchemaName$Schema.ClassMapEntry entry;$iterate Tables( each maybeWireToISchemaEntries )$
				for( I$SecSchemaName$Schema.ClassMapEntry cur: I$SchemaName$Schema.entries) {
					cur.setRuntimeClassCode(value++);
				}
				I$SchemaName$Schema.mapBackingClassCodeToEntry.clear();
				I$SchemaName$Schema.mapRuntimeClassCodeToEntry.clear();
				for( I$SecSchemaName$Schema.ClassMapEntry cur: I$SchemaName$Schema.entries) {
					I$SchemaName$Schema.mapBackingClassCodeToEntry.put(cur.getBackingClassCode(), cur);
					I$SchemaName$Schema.mapRuntimeClassCodeToEntry.put(cur.getRuntimeClassCode(), cur);
				}
			}
			return(value);
		}
		
		public static I$SecSchemaName$Schema.ClassMapEntry getClassMapByBackingClassCode(int code) {
			I$SecSchemaName$Schema.ClassMapEntry entry;$iterate SchemaRefs( each tryGetClassMapByBackingClassCode empty empty )$$tryGetClassMapByBackingClassCode$
			return( null );
		}
		
		public static I$SecSchemaName$Schema.ClassMapEntry getClassMapByRuntimeClassCode(int code) {
			I$SecSchemaName$Schema.ClassMapEntry entry;$iterate SchemaRefs( each tryGetClassMapByRuntimeClassCode empty empty )$$tryGetClassMapByRuntimeClassCode$
			return( null );
		}
		
		public int initClassMapEntries(int value);
		public void wireRecConstructors();
		public void wireTableTableInstances();
</GenRule>

	<GenRule GenDef="SchemaRef" Name="tryGetClassMapByBackingClassCode">$reference RefSchema tryGetClassMapByBackingClassCode$</GenRule>
	<GenRule GenDef="SchemaDef" Name="tryGetClassMapByBackingClassCode">
			entry = I$SchemaName$Schema.mapBackingClassCodeToEntry.get(code);
			if (entry != null) {
				return( entry );
			}</GenRule>

	<GenRule GenDef="SchemaRef" Name="tryGetClassMapByRuntimeClassCode">$reference RefSchema tryGetClassMapByRuntimeClassCode$</GenRule>
	<GenRule GenDef="SchemaDef" Name="tryGetClassMapByRuntimeClassCode">
			entry = I$SchemaName$Schema.mapRuntimeClassCodeToEntry.get(code);
			if (entry != null) {
				return( entry );
			}</GenRule>

	<GenRule GenDef="SchemaRef" Name="invokeSuperISchemaInitClassMapEntries">$reference RefSchema invokeSuperISchemaInitClassMapEntries$</GenRule>
	<GenRule GenDef="SchemaDef" Name="invokeSuperISchemaInitClassMapEntries">
			value = I$SchemaName$Schema.doInitClassMapEntries(value);</GenRule>

	<GenRule GenDef="Table" Name="maybeWireToISchemaEntries">$switch HasDefSchema yes empty default wireToISchemaEntries$</GenRule>
	<GenRule GenDef="Table" Name="wireToISchemaEntries">
				entry = new I$SecSchemaName$Schema.ClassMapEntry(I$SchemaName$Schema.SCHEMA_NAME, "$TableName$", I$DefSchemaName$$TableName$.CLASS_CODE);
				I$SchemaName$Schema.entries.add(entry);</GenRule>

        <GenRule GenDef="Object" Name="SecSchemaName">$poptop SchemaDef iterate SchemaRefs( first emitSecSchemaName each empty empty emitOnlySchemaName )$</GenRule>
        <GenRule GenDef="SchemaRef" Name="emitSecSchemaName">$reference RefSchema SchemaName$</GenRule>
        <GenRule GenDef="Object" Name="emitOnlySchemaName">$poptop SchemaDef SchemaName$</GenRule>
        
	<GenRule GenDef="EnumDef" Name="declISchemaEnumType"
		>$switch HasDefSchema yes empty default reallyDeclISchemaEnumType$</GenRule>

	<GenRule GenDef="EnumDef" Name="reallyDeclISchemaEnumType">
	public enum $Name$ {$iterate Tag( first declISchemaEnumTypeFirstTag each declISchemaEnumTypeEachTag )$
	};
$reallyImplSchemaParseEnum$</GenRule>

	<GenRule GenDef="EnumDef" Name="implSchemaParseEnum"
		>$switch HasDefSchema yes empty default reallyImplSchemaParseEnum$</GenRule>

	<GenRule GenDef="EnumDef" Name="reallyImplSchemaParseEnum"
		>$implSchemaParseEnumParse$$implSchemaParseEnumOrdinal$</GenRule>

	<GenRule GenDef="Value" Name="implSchemaParseEnum"></GenRule>

	<GenRule GenDef="EnumDef" Name="implSchemaParseEnumParse">
	static HashMap&lt;String,$Name$&gt; lookup$Name$ = new HashMap&lt;String,$Name$&gt;();

	public static $Name$ parse$Name$( String value ) {
		$Name$ retval = parse$Name$( I$DefSchemaName$Schema.class.getName(), value );
		return( retval );
	}

	public static $Name$ parse$Name$( String fieldOrClassName, String value ) {
		final String S_ProcName = "parse$Name$";
		if( lookup$Name$.isEmpty() ) {$iterate Tag( each implSchemaParseEnumAddTagToMap )$
		}
		$Name$ retval;
		if( ( value == null ) || ( value.length() &lt;= 0 ) ) {
			retval = null;
		}
		else {
			retval = lookup$Name$.get( value );
			if( retval == null ) {
				throw new CFLibInvalidArgumentException( fieldOrClassName,
					fieldOrClassName,
					S_ProcName,
					2,
					"value",
					"Invalid enum limb argument " + value,
					"Invalid enum limb argument " + value);
			}
		}
		return( retval );
	}
</GenRule>

	<GenRule GenDef="EnumTag" Name="implSchemaParseEnumAddTagToMap">
			lookup$popto EnumDef Name$.put( "$Name$", $popto EnumDef Name$.$Name$ );</GenRule>

	<GenRule GenDef="EnumDef" Name="implSchemaParseEnumOrdinal">
	static HashMap&lt;Integer,$Name$&gt; lookupOrdinal$Name$ = new HashMap&lt;Integer,$Name$&gt;();

	public static $Name$ ordinalTo$Name$( String fieldOrClassName, Short value ) {
		$Name$ retval;
		if( value == null ) {
			retval = null;
		}
		else {
			retval = ordinalTo$Name$( fieldOrClassName, Integer.valueOf( value.shortValue() ) );
		}
		return( retval );
	}

	public static $Name$ ordinalTo$Name$( Short value ) {
		$Name$ retval;
		if( value == null ) {
			retval = null;
		}
		else {
			retval = ordinalTo$Name$( Integer.valueOf( value.shortValue() ) );
		}
		return( retval );
	}

	public static $Name$ ordinalTo$Name$( Integer value ) {
		$Name$ retval;
		if( value == null ) {
			retval = null;
		}
		else {
			retval = ordinalTo$Name$( I$SchemaName$Schema.class.getName(), Integer.valueOf( value.shortValue() ) );
		}
		return( retval );
	}

	public static $Name$ ordinalTo$Name$( String fieldOrClassName, Integer value ) {
		final String S_ProcName = "ordinalTo$Name$";
		if( lookupOrdinal$Name$.isEmpty() ) {$iterate Tag( each implSchemaParseEnumAddOrdinalTagToMap )$
		}
		$Name$ retval;
		if( value == null ) {
			retval = null;
		}
		else {
			retval = lookupOrdinal$Name$.get( value );
			if( retval == null ) {
				throw new CFLibInvalidArgumentException( fieldOrClassName,
					fieldOrClassName,
					S_ProcName,
					2,
					"value",
					"Invalid enum limb argument " + value,
					"Invalid enum limb argument " + value);
			}
		}
		return( retval );
	}
</GenRule>

	<GenRule GenDef="EnumTag" Name="implSchemaParseEnumAddOrdinalTagToMap">
			lookupOrdinal$popto EnumDef Name$.put( Integer.valueOf( $popto EnumDef Name$.$Name$.ordinal() ), $popto EnumDef Name$.$Name$ );</GenRule>

	<GenRule GenDef="EnumTag" Name="declISchemaEnumTypeFirstTag">
		$Name$</GenRule>

	<GenRule GenDef="EnumTag" Name="declISchemaEnumTypeEachTag">,
		$Name$</GenRule>

	<GenRule GenDef="Value" Name="declISchemaEnumType"></GenRule>

	<GenRule GenDef="SchemaRef" Name="extendsPackageSchemaName">
extends I$PackageSchemaName$Schema</GenRule>
	<GenRule GenDef="SchemaRef" Name="commaNewlinePackageSchemaName">,
	I$PackageSchemaName$Schema</GenRule>

	<GenRule GenDef="SchemaRef" Name="PackageSchemaName"
		>$reference RefSchema PackageSchemaName$</GenRule>
	<GenRule GenDef="SchemaDef" Name="PackageSchemaName"
		>$SchemaName$</GenRule>

	<GenRule GenDef="SchemaRef" Name="importJavaPackageSchemaName">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;</GenRule>
	<GenRule GenDef="SchemaDef" Name="importJavaPackageSchemaName">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;</GenRule>
	<GenRule GenDef="Table" Name="importJavaPackageSchemaName">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;</GenRule>
	<GenRule GenDef="Object" Name="importJavaPackageSchemaName">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;</GenRule>

	<GenRule GenDef="SchemaRef" Name="importJavaPackageSchemaNameObj">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$obj.*;</GenRule>
	<GenRule GenDef="SchemaDef" Name="importJavaPackageSchemaNameObj">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$obj.*;</GenRule>
	<GenRule GenDef="Table" Name="importJavaPackageSchemaNameObj">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$obj.*;</GenRule>
	<GenRule GenDef="Object" Name="importJavaPackageSchemaNameObj">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$obj.*;</GenRule>

	<GenRule GenDef="SchemaRef" Name="importJavaPackageSchemaNameJpa">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.jpa.*;</GenRule>
	<GenRule GenDef="SchemaDef" Name="importJavaPackageSchemaNameJpa">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.jpa.*;</GenRule>
	<GenRule GenDef="Table" Name="importJavaPackageSchemaNameJpa">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.jpa.*;</GenRule>
	<GenRule GenDef="Object" Name="importJavaPackageSchemaNameJpa">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.jpa.*;</GenRule>

	<GenRule GenDef="SchemaRef" Name="importJavaPackageSchemaNameBuff">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.buff.*;</GenRule>
	<GenRule GenDef="SchemaDef" Name="importJavaPackageSchemaNameBuff">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.buff.*;</GenRule>
	<GenRule GenDef="Table" Name="importJavaPackageSchemaNameBuff">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.buff.*;</GenRule>
	<GenRule GenDef="Object" Name="importJavaPackageSchemaNameBuff">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.buff.*;</GenRule>

	<GenRule GenDef="SchemaRef" Name="importJavaPackageSchemaNameRam">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$ram.*;</GenRule>
	<GenRule GenDef="SchemaDef" Name="importJavaPackageSchemaNameRam">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$ram.*;</GenRule>
	<GenRule GenDef="Table" Name="importJavaPackageSchemaNameRam">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$ram.*;</GenRule>
	<GenRule GenDef="Object" Name="importJavaPackageSchemaNameRam">
import $lower DefTopProjectName$.$lower DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$ram.*;</GenRule>

	<GenRule GenDef="SchemaRef" Name="declNewSchema"
		>$reference RefSchema declNewSchema$</GenRule>

	<GenRule GenDef="SchemaDef" Name="declNewSchema">
	/**
	 *	Allocate a new schema instance.
	 *
	 *	@return	A new I$SchemaName$Schema instance.
	 */
	public I$DefSchemaName$Schema newSchema();
</GenRule>

	<GenRule GenDef="Object" Name="declNewSchema">
	/**
	 *	Allocate a new schema instance.
	 *
	 *	@return	A new I$SchemaName$Schema instance.
	 */
	public I$DefSchemaName$Schema newSchema();
</GenRule>

	<GenRule ScopeDef="SchemaDef" GenDef="Id16Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public short next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="Id32Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public int next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="Id64Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public long next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="UuidGen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public UUID next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="Uuid6Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibUuid6 next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="DbKeyHash128Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibDbKeyHash128 next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="DbKeyHash160Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibDbKeyHash160 next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="DbKeyHash224Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibDbKeyHash224 next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="DbKeyHash256Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibDbKeyHash256 next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="DbKeyHash384Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibDbKeyHash384 next$Name$();
</GenRule>
	<GenRule ScopeDef="SchemaDef" GenDef="DbKeyHash512Gen" Name="declNextIdGen">
	/**
	 *	Get the next $Name$ identifier.
	 *
	 *	@return	The next $Name$ identifier.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public CFLibDbKeyHash512 next$Name$();
</GenRule>

	<GenRule GenDef="Table" Name="declTableMethods"
		>$declSchemaTableTableAccessors$$declSchemaTableFactoryAccessors$</GenRule>

	<GenRule GenDef="Table" Name="declSchemaTableTableAccessors">
	/**
	 *	Get the $TableName$ Table interface for the schema.
	 *
	 *	@return	The $TableName$ Table interface for the schema.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public I$DefSchemaName$$TableName$Table getTable$TableName$();
</GenRule>

	<GenRule GenDef="Table" Name="declSchemaTableFactoryAccessors">
	/**
	 *	Get the $TableName$ Factory interface for the schema.
	 *
	 *	@return	The $TableName$ Factory interface for the schema.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	public I$DefSchemaName$$TableName$Factory getFactory$TableName$();
</GenRule>

	<GenRule GenDef="SchemaRef" Name="declSchemaTablePermsAccessors"
		>$reference RefSchema declSchemaTablePermsAccessors$</GenRule>

	<GenRule GenDef="SchemaDef" Name="declSchemaTablePermsAccessors">
	/**
	 *	Get the Table Permissions interface for the schema.
	 *
	 *	@return	The Table Permissions interface for the schema.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	//public static I$SecSchemaName$TablePerms getTablePerms();

	/**
	 *	Get the Table Permissions interface cast to this schema's implementation.
	 *
	 *	@return The Table Permissions interface for this schema.
	 */
	//public static I$SchemaName$TablePerms get$SchemaName$TablePerms();

	/**
	 *	Set the Table Permissions interface for the schema.  All fractal subclasses of
	 *	the I$SecSchemaName$TablePerms implement at least that interface plus their own
	 *	accessors.
	 *
	 *	@param	value	The Table Permissions interface to be used by the schema.
	 *
	 *	@throws CFLibNotSupportedException thrown by client-side implementations.
	 */
	//public static void setTablePerms( I$SecSchemaName$TablePerms value );
</GenRule>

</RuleSet>
