<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	Mark's Code Fractal CFKBase 3.1 Code Fractal Knowledge Base
 *
 *	Copyright 2016-2026 Mark Stephen Sobkow
 *
 *	This file is part of Mark's Code Fractal CFKBase.
 *
 *	Mark's Code Fractal CFKBase is available under dual commercial license from
 *	Mark Stephen Sobkow, or under the terms of the GNU General Public License,
 *	Version 3 or later.
 *
 *	Mark's Code Fractal CFKBase is free software: you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	Mark's Code Fractal CFKBase is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Mark's Code Fractal CFKBase.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 *
 *	If you wish to modify and use this code without publishing your changes,
 *	or integrate it with proprietary code, please contact Mark Stephen Sobkow
 *	for a commercial license at mark.sobkow@gmail.com
 * -->
<RuleSet
	xmlns="https://msobkow.github.io/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="https://msobkow.github.io/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd https://msobkow.github.io/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="java"
	Name="src/SchemaRam/SchemaRamTableTable.java"
	Revision="3.0"
	Descr="Java 25 in-memory RAM DbIO implementation for Table">

	<GenRule GenDef="IndexCol" Name="DbColumnName"
		>$reference Column DbColumnName$</GenRule>

	<GenRule GenDef="Table" Name="fileSchemaRamTableTableJava">$switch HasDefSchema yes empty default reallyFileSchemaRamTableTableJava$</GenRule>
	
	<GenFile GenDef="Table" Name="reallyFileSchemaRamTableTableJava"
			GenerateOnce="false"
		ModuleName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema SchemaName$Ram"
		SourceBundle="java"
		BasePackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$ram/src/main/java"
		SubPackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$ram"
		ExpansionClassName="$SchemaName$Ram$TableName$TableJava"
		ExpansionKeyName="$SchemaName$Ram$TableName$TableJava"
		ExpansionFileName="$SchemaName$Ram$TableName$Table.java">
// Description: Java 25 in-memory RAM DbIO implementation for $TableName$.

$MssSourceLicense$

package $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$ram;

import java.math.*;
import java.sql.*;
import java.text.*;
import java.time.*;
import java.util.*;
import org.apache.commons.codec.binary.Base64;
import io.github.msobkow.v3_1.cflib.*;
import io.github.msobkow.v3_1.cflib.dbutil.*;
$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaName empty empty )$$poptop SchemaDef importJavaPackageSchemaName$$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaNameBuff empty empty )$$poptop SchemaDef importJavaPackageSchemaNameBuff$$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaNameObj empty empty )$$poptop SchemaDef importJavaPackageSchemaNameObj$$JavaRamTableImport$

/*
 *	$SchemaName$Ram$TableName$Table in-memory RAM DbIO implementation
 *	for $TableName$.
 */
public class $SchemaName$Ram$TableName$Table
	implements I$SchemaName$$TableName$Table
{
	private I$SchemaName$Schema schema;$declRamTableByPKey$$iterate Index( each maybeDeclRamTableByIndex )$$JavaRamTableMembers$
$implConstructRamTableTable$$moreRamTableMethods$$JavaRamTableImplementation$}
</GenFile>

	<GenRule GenDef="Index" Name="PageData"
		>$poptop Table PageData$</GenRule>
	<GenRule GenDef="Index" Name="InheritsPageData"
		>$poptop Table InheritsPageData$</GenRule>

	<GenRule GenDef="ServerProc" Name="implServerMethod"
		>$switch IsInstanceMethod yes implInstServerProc default implClassServerProc$</GenRule>

	<GenRule GenDef="ServerProc" Name="implClassServerProc">
	@Override
	public boolean $leadlower Name$( I$DefSchemaName$SchemaObj schemaObj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$JavaMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerProc" Name="implInstServerProc">
	@Override
	public boolean $leadlower Name$( I$DefSchemaName$SchemaObj schemaObj,
		I$DefSchemaName$$TableName$Obj obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$JavaMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implServerMethod"
		>$switch IsInstanceMethod yes implInstServerObjFunc default implClassServerObjFunc$</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implClassServerObjFunc">
	public I$reference RetTable DefSchemaName$$reference RetTable Name$ $leadlower Name$( I$DefSchemaName$SchemaObj schemaObj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$JavaMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implInstServerObjFunc">
	@Override
	public I$reference RetTable DefSchemaName$$reference RetTable Name$ $leadlower Name$( I$DefSchemaName$SchemaObj schemaObj,
		I$DefSchemaName$$TableName$Obj obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$JavaMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implServerMethod"
		>$switch IsInstanceMethod yes implInstServerListFunc default implClassServerListFunc$</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implClassServerListFunc">
	@Override
	public I$reference RetTable DefSchemaName$$reference RetTable Name$[] $leadlower Name$( I$DefSchemaName$SchemaObj schemaObj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$JavaMethodBody$	}
</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implInstServerListFunc">
	@Override
	public I$reference RetTable DefSchemaName$$reference RetTable Name$[] $leadlower Name$( I$DefSchemaName$SchemaObj schemaObj,
		I$DefSchemaName$$TableName$Obj obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
$JavaMethodBody$	}
</GenRule>

	<GenRule GenDef="Table" Name="moreRamTableMethods"
		>$switch HasSuperClassRelation yes invokeBaseEnsureRec default implRamTableEnsureRec$$implRamCreateTable$$implRamReadTableDerivedByPKey$$implRamLockTableDerivedByPKey$$implRamReadAllTableDerived$$implRamReadTableDerivedByIndexes$$implRamReadTableRecByPKey$$implRamLockTableRecByPKey$$implRamReadAllTableRec$$switch InheritsPageData yes implRamPageAllTableRec default empty$$implRamReadTableRecByIndexes$$switch InheritsPageData yes implRamPageTableRecByIndexes default empty$$switch HasChain yes implRamMoveUpTableRec default empty$$switch HasChain yes implRamMoveDownTableRec default empty$$implRamUpdateTable$$implRamDeleteTable$$iterate ServerMethods( each implServerMethod empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="invokeBaseEnsureRec">
	public $reference BaseClass DefSchemaName$Buff$reference BaseClass TableName$ ensureRec(I$reference BaseClass DefSchemaName$$reference BaseClass TableName$ rec) {
		if (rec == null) {
			return( null );
		}
		else {
			return (($reference BaseClass DefSchemaName$Ram$reference BaseClass TableName$Table)(schema.getTable$reference BaseClass TableName$())).ensureRec((I$reference BaseClass DefSchemaName$$reference BaseClass TableName$)rec);
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamTableEnsureRec">
	public $DefSchemaName$Buff$TableName$ ensureRec(I$DefSchemaName$$TableName$ rec) {
		if (rec == null) {
			return( null );
		}
		else {
			int classCode = rec.getClassCode();
			if (classCode == I$DefSchemaName$$TableName$.CLASS_CODE) {
				return( (($DefSchemaName$Buff$TableName$DefaultFactory)(schema.getFactory$TableName$())).ensureRec((I$DefSchemaName$$TableName$)rec) );
			}$iterate TableSubClasses( each implRamTableEnsureRecWalkSubClass empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), "ensureRec", "rec", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamTableEnsureRecWalkSubClass">
			else if (classCode == I$DefSchemaName$$TableName$.CLASS_CODE) {
				return( (($DefSchemaName$Buff$TableName$DefaultFactory)(schema.getFactory$TableName$())).ensureRec((I$DefSchemaName$$TableName$)rec) );
			}$iterate TableSubClasses( each implRamTableEnsureRecWalkSubClass empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamMoveUpTableRec">
	/**
	 *	Move the specified buffer up in the chain (i.e. to the previous position.)
	 *
	 *	@return	The refreshed buffer after it has been moved
	 */
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$ moveRecUp( I$SecSchemaName$Authorization Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaColumnArg )$,
		int revision )
	{
		final String S_ProcName = "moveRecUp";

		I$EffSchemaName$$reference Chain reference Table TableName$ grandprev = null;
		I$EffSchemaName$$reference Chain reference Table TableName$ prev = null;
		I$EffSchemaName$$reference Chain reference Table TableName$ cur = null;
		I$EffSchemaName$$reference Chain reference Table TableName$ next = null;

		cur = schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each passCommaColumnArg )$);
		if( cur == null ) {
			throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object" );
		}

		if( $reference Chain reference PrevRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNull each implRamMoveBuffCurAndColNull )$ )
		{
			return( ($EffSchemaName$Buff$TableName$)cur );
		}

		prev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference PrevRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ ));
		if( prev == null ) {
			throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object.prev" );
		}

		if( $reference Chain reference PrevRel reference FromIndex iterate Columns( first implRamMoveBuffPrevColNotNull each implRamMoveBuffPrevAndColNotNull )$ )
		{
			grandprev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference PrevRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaPrevCol )$ ));
			if( grandprev == null ) {
				throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object.prev.prev" );
			}
		}

		if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNotNull each implRamMoveBuffCurAndColNotNull )$ )
		{
			next = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference NextRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ ));
			if( next == null ) {
				throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object.next" );
			}
		}

		int classCode = prev.getClassCode();
		I$EffSchemaName$$reference Chain reference Table TableName$ newInstance;$implRamSchemaMoveBuffInstantiateBuff$
		$EffSchemaName$Buff$reference Chain reference Table TableName$ editPrev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
		editPrev.set( prev );

		classCode = cur.getClassCode();$implRamSchemaMoveBuffInstantiateBuff$
		$EffSchemaName$Buff$reference Chain reference Table TableName$ editCur = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
		editCur.set( cur );

		$EffSchemaName$Buff$reference Chain reference Table TableName$ editGrandprev = null;
		if( grandprev != null ) {
			classCode = grandprev.getClassCode();$implRamSchemaMoveBuffInstantiateBuff$
			editGrandprev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
			editGrandprev.set( grandprev );
		}

		$EffSchemaName$Buff$reference Chain reference Table TableName$ editNext = null;
		if( next != null ) {
			classCode = next.getClassCode();$implRamSchemaMoveBuffInstantiateBuff$
			editNext = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
			editNext.set( next );
		}

		if( editGrandprev != null ) {$reference Chain reference NextRel implRamMoveSetGrandprevCur$$reference Chain reference PrevRel implRamMoveSetCurGrandprev$
		}
		else {$reference Chain reference PrevRel implRamMoveSetCurNull$
		}
$reference Chain reference PrevRel implRamMoveSetPrevCur$
$reference Chain reference NextRel implRamMoveSetCurPrev$

		if( next != null ) {$reference Chain reference NextRel implRamMoveSetPrevNext$$reference Chain reference PrevRel implRamMoveSetNextPrev$
		}
		else {$reference Chain reference NextRel implRamMoveSetPrevNull$
		}

		if( editGrandprev != null ) {
			classCode = editGrandprev.getClassCode();$implRamSchemaMoveBuffUpdateGrandprev$
		}

		classCode = editPrev.getClassCode();$implRamSchemaMoveBuffUpdatePrev$

		classCode = editCur.getClassCode();$implRamSchemaMoveBuffUpdateCur$

		if( editNext != null ) {
			classCode = editNext.getClassCode();$implRamSchemaMoveBuffUpdateNext$
		}

		return( ($EffSchemaName$Buff$TableName$)editCur );
	}
</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetGrandprevCur">
			editGrandprev.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassArg each implRamMoveCommaPassArg )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassArg">cur.get$reference ToCol reference Column OptionalOrRequired$$reference ToCol reference Column Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassArg">, $implRamMovePassArg$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetCurGrandprev">
			editCur.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassGrandprevArg each implRamMoveCommaPassGrandprevArg )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassGrandprevArg">grandprev.get$reference ToCol reference Column OptionalOrRequired$$reference ToCol reference Column Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassGrandprevArg">, $implRamMovePassArg$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetCurNull">
			editCur.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassNull each implRamMoveCommaPassNull )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassNull">($reference FromCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassNull">, $implRamMovePassNull$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetPrevCur">
			editPrev.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassPrevCur each implRamMoveCommaPassPrevCur )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassPrevCur">cur.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassPrevCur">, $implRamMovePassPrevCur$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetPrevNext">
			editPrev.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassPrevNext each implRamMoveCommaPassPrevNext )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassPrevNext">next.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassPrevNext">, $implRamMovePassPrevNext$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetPrevNull">
			editPrev.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassPrevNull each implRamMoveCommaPassPrevNull )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassPrevNull">($reference FromCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassPrevNull">, $implRamMovePassPrevNull$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetCurPrev">
			editCur.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassCurPrev each implRamMoveCommaPassCurPrev )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassCurPrev">prev.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassCurPrev">, $implRamMovePassCurPrev$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetCurNext">
			editCur.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassCurNext each implRamMoveCommaPassCurNext )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassCurNext">next.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassCurNext">, $implRamMovePassCurNext$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetCurGrandnext">
			editCur.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassCurGrandnext each implRamMoveCommaPassCurGrandnext )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassCurGrandnext">grandnext.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassCurGrandnext">, $implRamMovePassCurGrandnext$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetNextPrev">
			editNext.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassNextPrev each implRamMoveCommaPassNextPrev )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassNextPrev">prev.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassNextPrev">, $implRamMovePassNextPrev$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetNextCur">
			editNext.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassNextCur each implRamMoveCommaPassNextCur )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassNextCur">cur.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassNextCur">, $implRamMovePassNextCur$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetNextNull">
			editNext.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassNextNull each implRamMoveCommaPassNextNull )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassNextNull">($reference FromCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassNextNull">, $implRamMovePassNextNull$</GenRule>

	<GenRule GenDef="Relation" Name="implRamMoveSetGrandnextCur">
			editGrandnext.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamMovePassGrandnextCur each implRamMoveCommaPassGrandnextCur )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMovePassGrandnextCur">cur.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamMoveCommaPassGrandnextCur">, $implRamMovePassGrandnextCur$</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffInstantiateBuff">
			if( classCode == I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$.CLASS_CODE ) {
				newInstance = schema.getFactory$reference Chain reference Table TableName$().newRec();
			}$reference Chain reference Table iterate TableSubClasses( each implRamSchemaMoveBuffWalkInstantiateBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-instantiate-buff-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkInstantiateBuff">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				newInstance = schema.getFactory$TableName$().newRec();
			}$iterate TableSubClasses( each implRamSchemaMoveBuffWalkInstantiateBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateCur">
			if( classCode == I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$.CLASS_CODE ) {
				schema.getTable$reference Chain reference Table TableName$().update$reference Chain reference Table TableName$( Authorization, editCur );
			}$reference Chain reference Table iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateCur empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-update-cur-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateCur">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editCur );
			}$iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateCur empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdatePrev">
			if( classCode == I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$.CLASS_CODE ) {
				schema.getTable$reference Chain reference Table TableName$().update$reference Chain reference Table TableName$( Authorization, editPrev );
			}$reference Chain reference Table iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdatePrev empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-update-prev-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdatePrev">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editPrev );
			}$iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdatePrev empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateNext">
			if( classCode == I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$.CLASS_CODE ) {
				schema.getTable$reference Chain reference Table TableName$().update$reference Chain reference Table TableName$( Authorization, editNext );
			}$reference Chain reference Table iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateNext empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-update-next-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateNext">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editNext );
			}$iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateNext empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateGrandnext">
			if( classCode == I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$.CLASS_CODE ) {
				schema.getTable$reference Chain reference Table TableName$().update$reference Chain reference Table TableName$( Authorization, editGrandnext );
			}$reference Chain reference Table iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateGrandnext empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-update-grand-next-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateGrandnext">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editGrandnext );
			}$iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateGrandnext empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffUpdateGrandprev">
			if( classCode == I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$.CLASS_CODE ) {
				schema.getTable$reference Chain reference Table TableName$().update$reference Chain reference Table TableName$( Authorization, editGrandprev );
			}$reference Chain reference Table iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateGrandprev empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-update-grand-prev-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}</GenRule>

	<GenRule GenDef="Table" Name="implRamSchemaMoveBuffWalkUpdateGrandprev">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editGrandprev );
			}$iterate TableSubClasses( each implRamSchemaMoveBuffWalkUpdateGrandprev empty empty )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaPrevCol"
		>, prev.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaNextCol"
		>, next.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPassCommaCurCol"
		>, cur.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurColNull"
		>( cur.get$OptionalOrRequired$$Name$() == null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurAndColNull">
			&amp;&amp; ( cur.get$OptionalOrRequired$$Name$() == null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPrevColNotNull"
		>( prev.get$OptionalOrRequired$$Name$() != null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffPrevAndColNotNull">
			&amp;&amp; ( prev.get$OptionalOrRequired$$Name$() != null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurColNotNull"
		>( cur.get$OptionalOrRequired$$Name$() != null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffCurAndColNotNull">
			&amp;&amp; ( cur.get$OptionalOrRequired$$Name$() != null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffNextColNotNull"
		>( next.get$OptionalOrRequired$$Name$() != null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamMoveBuffNextAndColNotNull">
			&amp;&amp; ( next.get$OptionalOrRequired$$Name$() != null )</GenRule>

	<GenRule GenDef="IndexCol" Name="passCommaColumnArg"
		>, $Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamMoveDownTableRec">
	/**
	 *	Move the specified buffer down in the chain (i.e. to the next position.)
	 *
	 *	@return	The refreshed buffer after it has been moved
	 */
	@Override
	public I$popto Table DefSchemaName$$poptop Table TableName$ moveRecDown( I$SecSchemaName$Authorization Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaColumnArg )$,
		int revision )
	{
		final String S_ProcName = "moveRecDown";

		$EffSchemaName$Buff$reference Chain reference Table TableName$ prev = null;
		$EffSchemaName$Buff$reference Chain reference Table TableName$ cur = null;
		$EffSchemaName$Buff$reference Chain reference Table TableName$ next = null;
		$EffSchemaName$Buff$reference Chain reference Table TableName$ grandnext = null;

		cur = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each passCommaColumnArg )$));
		if( cur == null ) {
			throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object" );
		}

		if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNull each implRamMoveBuffCurAndColNull )$ )
		{
			return( ($EffSchemaName$Buff$TableName$)cur );
		}

		next = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference NextRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ ));
		if( next == null ) {
			throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object.next" );
		}

		if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamMoveBuffNextColNotNull each implRamMoveBuffNextAndColNotNull )$ )
		{
			grandnext = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference NextRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaNextCol )$ ));
			if( grandnext == null ) {
				throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object.next.next" );
			}
		}

		if( $reference Chain reference PrevRel reference FromIndex iterate Columns( first implRamMoveBuffCurColNotNull each implRamMoveBuffCurAndColNotNull )$ )
		{
			prev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$(Authorization$reference Chain reference PrevRel reference FromIndex iterate Columns( each implRamMoveBuffPassCommaCurCol )$ ));
			if( prev == null ) {
				throw new CFLibCollisionDetectedException( getClass(), S_ProcName, "Could not locate object.prev" );
			}
		}

		int classCode = cur.getClassCode();
		I$EffSchemaName$$reference Chain reference Table TableName$ newInstance;$implRamSchemaMoveBuffInstantiateBuff$
		$EffSchemaName$Buff$reference Chain reference Table TableName$ editCur = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
		editCur.set( cur );

		classCode = next.getClassCode();$implRamSchemaMoveBuffInstantiateBuff$
		$EffSchemaName$Buff$reference Chain reference Table TableName$ editNext = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
		editNext.set( next );

		$EffSchemaName$Buff$reference Chain reference Table TableName$ editGrandnext = null;
		if( grandnext != null ) {
			classCode = grandnext.getClassCode();$implRamSchemaMoveBuffInstantiateBuff$
			editGrandnext = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
			editGrandnext.set( grandnext );
		}

		$EffSchemaName$Buff$reference Chain reference Table TableName$ editPrev = null;
		if( prev != null ) {
			classCode = prev.getClassCode();$implRamSchemaMoveBuffInstantiateBuff$
			editPrev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)newInstance;
			editPrev.set( prev );
		}

		if( prev != null ) {$reference Chain reference NextRel implRamMoveSetPrevNext$$reference Chain reference PrevRel implRamMoveSetNextPrev$
		}
		else {$reference Chain reference PrevRel implRamMoveSetNextNull$
		}
$reference Chain reference PrevRel implRamMoveSetCurNext$
$reference Chain reference NextRel implRamMoveSetNextCur$

		if( editGrandnext != null ) {$reference Chain reference NextRel implRamMoveSetCurGrandnext$$reference Chain reference PrevRel implRamMoveSetGrandnextCur$
		}
		else {$reference Chain reference NextRel implRamMoveSetCurNull$
		}

		if( editPrev != null ) {
			classCode = editPrev.getClassCode();$implRamSchemaMoveBuffUpdatePrev$
		}

		classCode = editCur.getClassCode();$implRamSchemaMoveBuffUpdateCur$

		classCode = editNext.getClassCode();$implRamSchemaMoveBuffUpdateNext$

		if( editGrandnext != null ) {
			classCode = editGrandnext.getClassCode();$implRamSchemaMoveBuffUpdateGrandnext$
		}

		return( ($EffSchemaName$Buff$TableName$)editCur );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamNextIdGenApplyArgToKey">
		key.set$OptionalOrRequired$$Name$( arg$Name$ );</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableRecByIndex"
		>$switch IsUnique
			yes implRamReadTableRecByUniqueIndex
			default implRamReadTableRecByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamPageTableRecByIndex"
		>$switch IsUnique
			yes empty
			default maybe_implRamPageTableRecByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="maybe_implRamPageTableRecByDuplicateIndex"
		>$switch PageData
			yes implRamPageTableRecByDuplicateIndex
			default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedByPKey">$switch IsPrimaryIndexKeyAtomic yes implRamReadTableDerivedByAtomicPKey default implRamReadTableDerivedByCompositePKey$</GenRule>
	<GenRule GenDef="Table" Name="implRamReadTableDerivedByAtomicPKey">
	@Override
	public I$popto Table DefSchemaName$$poptop Table TableName$ readDerived( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerived";
		I$popto Table DefSchemaName$$poptop Table TableName$ buff;
		if( dictByPKey.containsKey( PKey ) ) {
			buff = dictByPKey.get( PKey );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>
	<GenRule GenDef="Table" Name="implRamReadTableDerivedByCompositePKey">
	@Override
	public I$DefSchemaName$$TableName$ readDerived( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$BuffCompactedPrimaryIndexClass$ key = ($BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());$iterate SuperiorPrimaryKeyRelations( each implRamReadTableKeySetSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetKeyAttr empty empty )$
		return( readDerived( Authorization, key ) );
	}

	public I$popto Table DefSchemaName$$poptop Table TableName$ readDerived( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerived";
		$BuffCompactedPrimaryIndexClass$ key = ($BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());$iterate SuperiorPrimaryKeyRelations( each implRamReadTablePKeySetSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetPKeyAttr empty empty )$
		I$popto Table DefSchemaName$$poptop Table TableName$ buff;
		if( dictByPKey.containsKey( key ) ) {
			buff = dictByPKey.get( key );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Relation" Name="implRamReadTableKeySetSuperiorRelation">
		key.set$OptionalOrRequired$$RelationType$$Suffix$( $iterate Columns( first implRamReadTableKeyArgRelation each implRamReadTableCommaKeyArgRelation empty empty )$ );</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamReadTableKeyArgRelation">$reference FromCol reference Column Name$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamReadTableCommaKeyArgRelation">,
			$implRamReadTableKeyArgRelation$</GenRule>

	<GenRule GenDef="Relation" Name="implRamReadTablePKeySetSuperiorRelation">
		key.set$OptionalOrRequired$$RelationType$$Suffix$( $iterate Columns( first implRamReadTablePKeyArgRelation each implRamReadTableCommaPKeyArgRelation empty empty )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamReadTablePKeyArgRelation">PKey.get$reference FromCol reference Column implColumnAttrOptionality$$reference FromCol reference Column Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamReadTableCommaPKeyArgRelation">,
			$implRamReadTablePKeyArgRelation$</GenRule>

	<GenRule GenDef="Table" Name="implRamLockTableDerivedByPKey">$switch IsPrimaryIndexKeyAtomic yes implRamLockTableDerivedByAtomicPKey default implRamLockTableDerivedByCompositePKey$</GenRule>
	<GenRule GenDef="Table" Name="implRamLockTableDerivedByAtomicPKey">
	@Override
	public I$popto Table DefSchemaName$$poptop Table TableName$ lockDerived( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.lockDerived";
		I$popto Table DefSchemaName$$poptop Table TableName$ buff;
		if( dictByPKey.containsKey( PKey ) ) {
			buff = dictByPKey.get( PKey );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>
	<GenRule GenDef="Table" Name="implRamLockTableDerivedByCompositePKey">
	@Override
	public I$popto Table DefSchemaName$$poptop Table TableName$ lockDerived( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.lockDerived";
		$BuffCompactedPrimaryIndexClass$ key = ($BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());$iterate SuperiorPrimaryKeyRelations( each implRamReadTablePKeySetSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetPKeyAttr empty empty )$
		I$popto Table DefSchemaName$$poptop Table TableName$ buff;
		if( dictByPKey.containsKey( key ) ) {
			buff = dictByPKey.get( key );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeImplRamReadTableSetPKeyAttr">$switch InSuperiorPrimaryKeyRelation yes empty default implRamReadTableSetPKeyAttr$</GenRule>
	<GenRule GenDef="IndexCol" Name="implRamReadTableSetPKeyAttr">
		key.set$implColumnAttrOptionality$$Name$( PKey.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeImplRamReadTableSetKeyAttr">$switch InSuperiorPrimaryKeyRelation yes empty default implRamReadTableSetKeyAttr$</GenRule>
	<GenRule GenDef="IndexCol" Name="implRamReadTableSetKeyAttr">
		key.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeImplRamReadTableSetArgAttr">$switch InSuperiorPrimaryKeyRelation yes empty default implRamReadTableSetArgAttr$</GenRule>
	<GenRule GenDef="IndexCol" Name="implRamReadTableSetArgAttr">
		key.set$implColumnAttrOptionality$$Name$( arg$Name$ );</GenRule>

	<GenRule GenDef="Table" Name="implRamReadAllTableDerived">
	@Override
	public I$DefSchemaName$$TableName$[] readAllDerived( I$SecSchemaName$Authorization Authorization ) {
		final String S_ProcName = "$SchemaName$Ram$TableName$.readAllDerived";
		I$DefSchemaName$$TableName$[] retList = new I$DefSchemaName$$TableName$[ dictByPKey.values().size() ];
		Iterator&lt; $DefSchemaName$Buff$TableName$ &gt; iter = dictByPKey.values().iterator();
		int idx = 0;
		while( iter.hasNext() ) {
			retList[ idx++ ] = iter.next();
		}
		return( retList );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedByIndexes"
		>$switch HasSuperClassRelation yes implRamReadTableDerivedByInhIndexes default empty$$iterate Index( each implRamReadTableDerivedByThisNonPrimaryIndex )$$reference BaseClass reference PrimaryKeyIndex implRamReadTableDerivedByThisPrimaryIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedBySubIndexes"
		>$switch HasSuperClassRelation yes implRamReadTableDerivedByInhIndexes default empty$$iterate Index( each implRamReadTableDerivedByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="TableHasSuperClassRelation"
		>$popto Table HasSuperClassRelation$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamReadTableDerivedByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamReadTableDerivedByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableDerivedByInhIndexes"
		>$reference SuperClassRelation reference ToTable implRamReadTableDerivedBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisIndex"
		>$switch IsUnique
			yes implRamReadTableDerivedByThisUniqueIndex
			default implRamReadTableDerivedByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhIndex"
		>$switch IsUnique
			yes implRamReadTableDerivedByInhUniqueIndex
			default implRamReadTableDerivedByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByIndex"
		>$switch IsUnique
			yes implRamReadTableDerivedByUniqueIndex
			default implRamReadTableDerivedByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisUniqueIndex">
	@Override
	public I$popto Table DefSchemaName$$poptop Table TableName$ readDerivedBy$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerivedBy$Suffix$";
		$DefSchemaName$Buff$TableName$By$Suffix$Key key = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamReadTableSetKeyAttr )$
		I$DefSchemaName$$TableName$ buff;
		if( dictBy$Suffix$.containsKey( key ) ) {
			buff = dictBy$Suffix$.get( key );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisPrimaryIndex">$switch IsPrimaryIndexKeyAtomic yes implRamReadTableDerivedByThisAtomicPrimaryIndex default implRamReadTableDerivedByThisCompositePrimaryIndex$</GenRule>
	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisAtomicPrimaryIndex">
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$ readDerivedBy$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerivedBy$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$() ";
		I$poptop Table DefSchemaName$$poptop Table TableName$ buff;
		if( dictByPKey.containsKey( $poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns ( first Name each empty empty empty )$ ) ) {
			buff = dictByPKey.get( $poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns ( first Name each empty empty empty )$ );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>
	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisCompositePrimaryIndex">
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$ readDerivedBy$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerivedBy$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$() ";
		$poptop Table BuffCompactedPrimaryIndexClass$ key = ($poptop Table BuffCompactedPrimaryIndexClass$)(schema.getFactory$poptop Table reference BaseClass TableName$().newPKey());$poptop Table iterate SuperiorPrimaryKeyRelations( each implRamReadTableKeySetSuperiorRelation empty empty )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetKeyAttr empty empty )$
		I$poptop Table DefSchemaName$$poptop Table TableName$ buff;
		if( dictByPKey.containsKey( key ) ) {
			buff = dictByPKey.get( key );
		}
		else {
			buff = null;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhUniqueIndex">
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$ readDerivedBy$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerivedBy$Suffix$";
		I$reference Table DefSchemaName$$reference Table TableName$ buff = schema.getTable$reference Table TableName$().readDerivedBy$Suffix$( Authorization$iterate Columns( each implCommaColPassInvokeIndex )$ );
		if( buff == null ) {
			return( null );
		}
		else if( buff instanceof I$DefSchemaName$$poptop Table TableName$ ) {
			return( (I$DefSchemaName$$poptop Table TableName$)buff );
		}
		else {
			return( null );
		}
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implCommaColPassInvokeIndex">,
			$Name$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByThisDuplicateIndex">
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$[] readDerivedBy$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerivedBy$Suffix$";
		$poptop Table DefSchemaName$Buff$poptop Table TableName$By$Suffix$Key key = ($poptop Table DefSchemaName$Buff$poptop Table TableName$By$Suffix$Key)schema.getFactory$poptop Table TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamReadTableSetKeyAttr )$
		I$poptop Table DefSchemaName$$poptop Table TableName$[] recArray;
		if( dictBy$Suffix$.containsKey( key ) ) {
			Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $poptop Table DefSchemaName$Buff$poptop Table TableName$ &gt; subdict$Suffix$
				= dictBy$Suffix$.get( key );
			recArray = new I$popto Table DefSchemaName$$poptop Table TableName$[ subdict$Suffix$.size() ];
			Iterator&lt; $poptop Table DefSchemaName$Buff$poptop Table TableName$ &gt; iter = subdict$Suffix$.values().iterator();
			int idx = 0;
			while( iter.hasNext() ) {
				recArray[ idx++ ] = iter.next();
			}
		}
		else {
			Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $poptop Table DefSchemaName$Buff$poptop Table TableName$ &gt; subdict$Suffix$
				= new HashMap&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt;();
			dictBy$Suffix$.put( key, subdict$Suffix$ );
			recArray = new I$DefSchemaName$$TableName$[0];
		}
		return( recArray );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableDerivedByInhDuplicateIndex">
	@Override
	public I$DefSchemaName$$poptop Table TableName$[] readDerivedBy$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readDerivedBy$Suffix$";
		I$DefSchemaName$$reference Table TableName$ buffList[] = schema.getTable$reference Table TableName$().readDerivedBy$Suffix$( Authorization$iterate Columns( each implCommaColPassInvokeIndex )$ );
		if( buffList == null ) {
			return( null );
		}
		else {
			I$DefSchemaName$$reference Table TableName$ buff;
			ArrayList&lt;I$DefSchemaName$$poptop Table TableName$&gt; filteredList = new ArrayList&lt;I$DefSchemaName$$poptop Table TableName$&gt;();
			for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
				buff = buffList[idx];
				if( ( buff != null ) &amp;&amp; ( buff instanceof I$DefSchemaName$$poptop Table TableName$ ) ) {
					filteredList.add( (I$DefSchemaName$$poptop Table TableName$)buff );
				}
			}
			return( filteredList.toArray( new I$DefSchemaName$$poptop Table TableName$[0] ) );
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableRecByPKey">$switch IsPrimaryIndexKeyAtomic yes implRamReadTableRecByAtomicPKey default implRamReadTableRecByCompositePKey$</GenRule>
	<GenRule GenDef="Table" Name="implRamReadTableRecByAtomicPKey">
	@Override
	public I$DefSchemaName$$TableName$ readRec( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readRec";
		I$DefSchemaName$$TableName$ buff = readDerived( Authorization, PKey );
		if( ( buff != null ) &amp;&amp; ( buff.getClassCode() != I$DefSchemaName$$TableName$.CLASS_CODE ) ) {
			buff = null;
		}
		return( buff );
	}
</GenRule>
	<GenRule GenDef="Table" Name="implRamReadTableRecByCompositePKey">
	@Override
	public I$DefSchemaName$$TableName$ readRec( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$BuffCompactedPrimaryIndexClass$ key = ($BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());$iterate SuperiorPrimaryKeyRelations( each implRamReadTableKeySetSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetKeyAttr empty empty )$
		return( readRec( Authorization, key ) );
	}

	@Override
	public I$DefSchemaName$$TableName$ readRec( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readRec";
		I$DefSchemaName$$TableName$ buff = readDerived( Authorization, PKey );
		if( ( buff != null ) &amp;&amp; ( buff.getClassCode() != I$DefSchemaName$$TableName$.CLASS_CODE ) ) {
			buff = null;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamLockTableRecByPKey">
	@Override
	public I$DefSchemaName$$TableName$ lockRec( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		final String S_ProcName = "lockRec";
		I$DefSchemaName$$TableName$ buff = readDerived( Authorization, PKey );
		if( ( buff != null ) &amp;&amp; ( buff.getClassCode() != I$DefSchemaName$$TableName$.CLASS_CODE ) ) {
			buff = null;
		}
		return( buff );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadAllTableRec">
	@Override
	public I$DefSchemaName$$TableName$[] readAllRec( I$SecSchemaName$Authorization Authorization )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readAllRec";
		I$DefSchemaName$$TableName$ buff;
		ArrayList&lt;I$poptop Table DefSchemaName$$poptop Table TableName$&gt; filteredList = new ArrayList&lt;I$poptop Table DefSchemaName$$poptop Table TableName$&gt;();
		I$poptop Table DefSchemaName$$poptop Table TableName$[] buffList = readAllDerived( Authorization );
		for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
			buff = buffList[idx];
			if( ( buff != null ) &amp;&amp; ( buff.getClassCode() == I$DefSchemaName$$TableName$.CLASS_CODE ) ) {
				filteredList.add( buff );
			}
		}
		return( filteredList.toArray( new I$poptop Table DefSchemaName$$poptop Table TableName$[0] ) );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamPageAllTableRec">
	/**
	 *	Read a page of all the specific $TableName$ buffer instances.
	 *
	 *	@param	Authorization	The session authorization information.
	 *
	 *	@return All the specific $TableName$ instances in the database accessible for the Authorization.
	 */
	@Override
	public I$DefSchemaName$$TableName$[] pageAllRec( I$SecSchemaName$Authorization Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaOptPriorArg )$ )
	{
		final String S_ProcName = "pageAllRec";
		throw new CFLibNotImplementedYetException( getClass(), S_ProcName );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamPageTableRecByDuplicateIndex">
	/**
	 *	Read a page array of the specific $poptop Table TableName$ buffer instances identified by the duplicate key $Suffix$.
	 *
	 *	@param	Authorization	The session authorization information.$iterate Columns( each implCommentKeyAttr empty empty )$
	 *
	 *	@return An array of derived buffer instances for the specified key, potentially with 0 elements in the set.
	 *
	 *	@throws	CFLibNotSupportedException thrown by client-side implementations.
	 */
	@Override
	public I$DefSchemaName$$poptop Table TableName$[] pageRecBy$declReadTableSuffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaOptPriorArg )$ )
	{
		final String S_ProcName = "pageRecBy$declReadTableSuffix$";
		throw new CFLibNotImplementedYetException( getClass(), S_ProcName );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableRecByIndexes"
		>$switch HasSuperClassRelation yes implRamReadTableRecByInhIndexes default implRamReadTableRecByBaseIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableRecByInhIndexes"
		>$reference SuperClassRelation reference ToTable implRamReadTableRecByIndexes$$iterate Index( each implRamReadTableRecByNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableRecByBaseIndexes"
		>$iterate Index( each implRamReadTableRecByIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableRecByNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamReadTableRecByIndex$</GenRule>

	<GenRule GenDef="Table" Name="implRamPageTableRecByIndexes"
		>$switch HasSuperClassRelation yes implRamPageTableRecByInhIndexes default implRamPageTableRecByBaseIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamPageTableRecByInhIndexes"
		>$reference SuperClassRelation reference ToTable implRamPageTableRecByIndexes$$iterate Index( each implRamPageTableRecByNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implRamPageTableRecByBaseIndexes"
		>$iterate Index( each implRamPageTableRecByNonPrimaryIndex )$</GenRule>
		<!-->$iterate Index( each maybe_pagedata_implRamPageTableRecByIndex )$</GenRule-->

	<GenRule GenDef="Index" Name="implRamPageTableRecByNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default maybe_implRamPageTableRecByIndex$</GenRule>

	<GenRule GenDef="Index" Name="maybe_pagedata_implRamPageTableRecByIndex"
		>$switch InheritsPageData yes maybe_implRamPageTableRecByIndex default empty$</GenRule>

	<GenRule GenDef="Index" Name="maybe_implRamPageTableRecByIndex"
		>$switch IsUnique yes empty default implRamPageTableRecByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableRecByUniqueIndex">
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$ readRecBy$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readRecBy$Suffix$() ";
		I$poptop Table DefSchemaName$$poptop Table TableName$ buff = readDerivedBy$Suffix$( Authorization$iterate Columns( each implRamReadTableRecCommaPassColArg )$ );
		if( ( buff != null ) &amp;&amp; ( buff.getClassCode() == I$DefSchemaName$$TableName$.CLASS_CODE ) ) {
			return( (I$poptop Table DefSchemaName$$poptop Table TableName$)buff );
		}
		else {
			return( null );
		}
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableRecByDuplicateIndex">
	@Override
	public I$poptop Table DefSchemaName$$poptop Table TableName$[] readRecBy$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$.readRecBy$Suffix$() ";
		I$poptop Table DefSchemaName$$poptop Table TableName$ buff;
		ArrayList&lt;I$popto Table DefSchemaName$$poptop Table TableName$&gt; filteredList = new ArrayList&lt;I$popto Table DefSchemaName$$poptop Table TableName$&gt;();
		I$popto Table DefSchemaName$$poptop Table TableName$[] buffList = readDerivedBy$Suffix$( Authorization$iterate Columns( each implRamReadTableRecCommaPassColArg )$ );
		for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
			buff = buffList[idx];
			if( ( buff != null ) &amp;&amp; ( buff.getClassCode() == I$DefSchemaName$$TableName$.CLASS_CODE ) ) {
				filteredList.add( (I$popto Table DefSchemaName$$poptop Table TableName$)buff );
			}
		}
		return( filteredList.toArray( new I$popto Table DefSchemaName$$poptop Table TableName$[0] ) );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamReadTableRecCommaPassColArg">,
			$Name$</GenRule>

	<GenRule GenDef="Table" Name="declRamTableByPKey">
	private Map&lt; $ICompactedPrimaryIndexClass$,
				$DefSchemaName$Buff$TableName$ &gt; dictByPKey
		= new HashMap&lt; $ICompactedPrimaryIndexClass$,
				$DefSchemaName$Buff$TableName$ &gt;();</GenRule>

	<GenRule GenDef="Object" Name="declRamTableByPKey">
	private Map&lt; $ICompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; dictByPKey = new HashMap&lt; $ICompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt;();</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclRamTableByIndex"
		>$switch IsPrimaryIndex yes empty default declRamTableByIndex$</GenRule>

	<GenRule GenDef="Index" Name="declRamTableByIndex"
		>$switch IsUnique yes declRamTableByUniqueIndex default declRamTableByDupIndex$</GenRule>

	<GenRule GenDef="Index" Name="declRamTableByUniqueIndex">
	private Map&lt; $DefSchemaName$Buff$TableName$By$Suffix$Key,
			$DefSchemaName$Buff$TableName$ &gt; dictBy$Suffix$
		= new HashMap&lt; $DefSchemaName$Buff$TableName$By$Suffix$Key,
			$DefSchemaName$Buff$TableName$ &gt;();</GenRule>

	<GenRule GenDef="Index" Name="declRamTableByDupIndex">
	private Map&lt; $DefSchemaName$Buff$TableName$By$Suffix$Key,
				Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$,
					$DefSchemaName$Buff$TableName$ &gt;&gt; dictBy$Suffix$
		= new HashMap&lt; $DefSchemaName$Buff$TableName$By$Suffix$Key,
				Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$,
					$DefSchemaName$Buff$TableName$ &gt;&gt;();</GenRule>

	<GenRule GenDef="Table" Name="implConstructRamTableTable">
	public $SchemaName$Ram$TableName$Table( I$SchemaName$Schema argSchema ) {
		schema = argSchema;
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeImplRamCreateTablePKeyToBuff">$switch InSuperiorPrimaryKeyRelation yes empty default implRamCreateTablePKeyToBuff$</GenRule>
	<GenRule GenDef="IndexCol" Name="implRamCreateTablePKeyToBuff">$switch IsPrimaryIndexKeyAtomic yes implRamCreateTableAtomicPKeyToBuff default implRamCreateTableCompositePKeyToBuff$</GenRule>
	<GenRule GenDef="IndexCol" Name="implRamCreateTableAtomicPKeyToBuff">
		Buff.set$reference Column Optionality$$reference Column Name$( pkey );</GenRule>
	<GenRule GenDef="IndexCol" Name="implRamCreateTableCompositePKeyToBuff">
		Buff.set$reference Column Optionality$$reference Column Name$( pkey.get$reference Column Optionality$$reference Column Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableCopyBackPKeyToBuff"
		>$iterate SuperiorPrimaryKeyRelations( each implRamCreateTableSetBuffSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamCreateTablePKeyToBuff )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTablePKeyGenNew"
		>$iterate SuperiorPrimaryKeyRelations( each implRamCreateTablePKeySetSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamCreateTablePKey empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTablePKeyCopyBuff"
		>$iterate SuperiorPrimaryKeyRelations( each implRamCreateTablePKeySetSuperiorRelation empty empty )$$reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamCreateTablePKeyCopyId empty empty )$</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTableSetBuffSuperiorRelation">
		Buff.set$OptionalOrRequired$$RelationType$$Suffix$( $iterate Columns( first implRamCreateTableRecArgRelation each implRamCreateTableCommaBuffArgRelation empty empty )$ );</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableRecArgRelation">pkey.get$reference FromCol reference Column implColumnAttrOptionality$$reference FromCol reference Column Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCommaBuffArgRelation">,
			$implRamCreateTableRecArgRelation$</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTablePKeySetSuperiorRelation">
		pkey.set$OptionalOrRequired$$RelationType$$Suffix$( $iterate Columns( first implRamCreateTablePKeyArgRelation each implRamCreateTableCommaPKeyArgRelation empty empty )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTablePKeyArgRelation">Buff.get$reference FromCol reference Column implColumnAttrOptionality$$reference FromCol reference Column Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCommaPKeyArgRelation">,
			$implRamCreateTablePKeyArgRelation$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTable">$switch IsPrimaryIndexKeyAtomic yes implRamCreateAtomicTable default implRamCreateCompositeTable$</GenRule>
	<GenRule GenDef="Table" Name="implRamCreateAtomicTable">
	@Override
	public I$DefSchemaName$$TableName$ create$TableName$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$ iBuff )
	{
		final String S_ProcName = "create$TableName$";
		$switch HasSuperClassRelation yes implRamCreateTableInvokeSuper default implRamCreateTableImplBase$
		$ICompactedPrimaryIndexClass$ pkey;$switch HasSuperClassRelation no implRamCreateTablePKeyGenNew default implRamCreateTablePKeyCopyBuff$$switch HasSuperClassRelation no implRamCreateTableCopyBackPKeyToBuff default empty$$iterate Index( each maybeImplRamCreateTableInitIndexKey )$
		// Validate unique indexes

		if( dictByPKey.containsKey( pkey ) ) {
			throw new CFLibPrimaryKeyNotNewException( getClass(), S_ProcName, pkey );
		}
$iterate Index( each maybeImplRamCreateTableCheckUniqueIndex )$
		// Validate foreign keys
$iterate Relation( each implRamCreateTableIntegrityCheck empty empty )$
		// Proceed with adding the new record

		dictByPKey.put( pkey, Buff );
$iterate Index( each maybeImplRamCreateTableAddToIndex )$$switch IsInstantiable yes implRamCreateTableMaybeChainLinkTail default empty$
		if (Buff == null) {
			return( null );
		}
		else {
			int classCode = Buff.getClassCode();
			if (classCode == I$DefSchemaName$$TableName$.CLASS_CODE) {
				$DefSchemaName$Buff$TableName$ retbuff = (($DefSchemaName$Buff$TableName$)(schema.getFactory$TableName$().newRec()));
				retbuff.set(Buff);
				return( retbuff );
			}$iterate TableSubClasses( each implRamCreateTableWalkRetBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-create-buff-cloning-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableWalkRetBuff">
			else if (classCode == I$DefSchemaName$$TableName$.CLASS_CODE) {
				$DefSchemaName$Buff$TableName$ retbuff = (($DefSchemaName$Buff$TableName$)(schema.getFactory$TableName$().newRec()));
				retbuff.set((I$DefSchemaName$$TableName$)Buff);
				return( retbuff );
			}$iterate TableSubClasses( each implRamCreateTableWalkRetBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableImplBase">
		$DefSchemaName$Buff$TableName$ Buff = ($DefSchemaName$Buff$TableName$)ensureRec(iBuff);$switch IsInstantiable yes implRamCreateTableMaybeInitChainLinks default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateCompositeTable">
	@Override
	public I$DefSchemaName$$TableName$ create$TableName$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$ iBuff )
	{
		final String S_ProcName = "create$TableName$";
		$switch HasSuperClassRelation yes implRamCreateTableInvokeSuper default implRamCreateTableImplBase$
		$BuffCompactedPrimaryIndexClass$ pkey = ($BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());$switch HasSuperClassRelation no implRamCreateTablePKeyGenNew default implRamCreateTablePKeyCopyBuff$$switch HasSuperClassRelation no implRamCreateTableCopyBackPKeyToBuff default empty$$iterate Index( each maybeImplRamCreateTableInitIndexKey )$
		// Validate unique indexes

		if( dictByPKey.containsKey( pkey ) ) {
			throw new CFLibPrimaryKeyNotNewException( getClass(), S_ProcName, pkey );
		}
$iterate Index( each maybeImplRamCreateTableCheckUniqueIndex )$
		// Validate foreign keys
$iterate Relation( each implRamCreateTableIntegrityCheck empty empty )$
		// Proceed with adding the new record

		dictByPKey.put( pkey, Buff );
$iterate Index( each maybeImplRamCreateTableAddToIndex )$$switch IsInstantiable yes implRamCreateTableMaybeChainLinkTail default empty$
		if (Buff == null) {
			return( null );
		}
		else {
			int classCode = Buff.getClassCode();
			if (classCode == I$DefSchemaName$$TableName$.CLASS_CODE) {
				$DefSchemaName$Buff$TableName$ retbuff = (($DefSchemaName$Buff$TableName$)(schema.getFactory$TableName$().newRec()));
				retbuff.set(Buff);
				return( retbuff );
			}$iterate TableSubClasses( each implRamCreateTableWalkRetBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-create-buff-cloning-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableMaybeInitChainLinks"
		>$switch HasChain yes implRamCreateTableInitChainLinks default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinks"
		>$switch HasClassCode yes implRamCreateTableInitChainLinksWithCC default implRamCreateTableInitChainLinksNoCC$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinksWithCC">
		I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$ tail = null;
		if( Buff.getClassCode() == I$DefSchemaName$$TableName$.CLASS_CODE ) {$implRamCreateTableInitChainLinksBody$
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinksNoCC">
			I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$ tail = null;
$implRamCreateTableInitChainLinksBody$
		</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInitChainLinksBody">
			I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$[] siblings = schema.getTable$reference Chain reference Table TableName$().readDerivedBy$reference ChainContainerComponents reference ToIndex Suffix$( Authorization$reference ContainerRelation reference FromIndex iterate Columns( each implRamCreateTableInitChainLinksCommaPassArg )$ );
			for( int idx = 0; ( tail == null ) &amp;&amp; ( idx &lt; siblings.length ); idx ++ ) {
				if( $reference Chain reference NextRel reference FromIndex iterate Columns( first implRamCreateTableInitChainLinksCheckNext each implRamCreateTableInitChainLinksCheckAndNext )$ )
				{
					tail = siblings[idx];
				}
			}
			if( tail != null ) {$reference Chain reference PrevRel implRamCreateTableInitChainLinksAssignPrev$
			}
			else {$reference Chain reference PrevRel implRamCreateTableInitChainLinksClearPrev$
			}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitChainLinksCommaPassArg">,
				Buff.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTableInitChainLinksClearPrev">
				Buff.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamCreateTableInitChainLinksClearPrev each implRamCreateTableInitChainLinksCommaClearPrev )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksClearPrev">($reference FromCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksCommaClearPrev">, $implRamCreateTableInitChainLinksClearPrev$</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTableInitChainLinksAssignPrev">
				Buff.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamCreateTableInitChainLinksAssignPrev each implRamCreateTableInitChainLinksCommaAssignPrev )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksAssignPrev">tail.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableInitChainLinksCommaAssignPrev">, $implRamCreateTableInitChainLinksAssignPrev$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitChainLinksCheckNext"
		>( siblings[idx].get$OptionalOrRequired$$Name$() == null )</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitChainLinksCheckAndNext">
					&amp;&amp; $implRamCreateTableInitChainLinksCheckNext$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableMaybeChainLinkTail"
		>$switch HasChain yes implRamCreateTableChainLinkTail default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTail"
		>$reference Chain reference Table switch HasClassCode yes implRamCreateTableChainLinkTailWithCC default implRamCreateTableChainLinkTailNoCC$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailNoCC">
		if( tail != null ) {
			I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$ tailEdit = schema.getFactory$reference Chain reference Table TableName$().newRec();
			tailEdit.set( (I$DefSchemaName$$TableName$)tail );$reference Chain reference NextRel implRamCreateTableChainTailLinkAssignNext$
			schema.getTable$reference Chain reference Table TableName$().update$reference Chain reference Table TableName$( Authorization, tailEdit );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailWithCC">
		if( tail != null ) {
			int tailClassCode = tail.getClassCode();
			if( tailClassCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {$implRamCreateTableChainLinkTailBody$
			}$iterate TableSubClasses( each implRamCreateTableChainLinkTailWithCCWalkHierarchy empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-create-table-chain-link-tail-", (Integer)tailClassCode, "Classcode not recognized: " + Integer.toString(tailClassCode));
			}
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailWithCCWalkHierarchy">
			else if( tailClassCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {$implRamCreateTableChainLinkTailBody$
			}$iterate TableSubClasses( each implRamCreateTableChainLinkTailWithCCWalkHierarchy empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableChainLinkTailBody">
				I$DefSchemaName$$TableName$ tailEdit = schema.getFactory$TableName$().newRec();
				tailEdit.set( (I$DefSchemaName$$TableName$)tail );$reference Chain reference NextRel implRamCreateTableChainTailLinkAssignNext$
				schema.getTable$TableName$().update$TableName$( Authorization, tailEdit );</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTableChainTailLinkAssignNext">
				tailEdit.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamCreateTableChainTailLinkAssignNext each implRamCreateTableChainTailCommaLinkAssignNext )$);</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailLinkAssignNext">Buff.get$reference ToCol OptionalOrRequired$$reference ToCol Name$()</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableChainTailCommaLinkAssignNext">, $implRamCreateTableChainTailCommaLinkAssignNext$</GenRule>

	<GenRule GenDef="Table" Name="implRamCreateTableInvokeSuper">
		$DefSchemaName$Buff$TableName$ Buff = ($DefSchemaName$Buff$TableName$)(schema.getTable$reference SuperClassRelation reference ToTable TableName$().create$reference SuperClassRelation reference ToTable TableName$( Authorization,
			iBuff ));$switch IsInstantiable yes implRamCreateTableMaybeInitChainLinks default empty$</GenRule>

	<GenRule GenDef="TableCol" Name="checkPKeyHasValue"
		>$reference DataType checkPKeyHasTableColValue$</GenRule>
	<GenRule GenDef="Atom" Name="checkPKeyHasValue"
		>$checkPKeyHasTableColValue$</GenRule>

	<GenRule GenDef="TableCol" Name="checkHasValue"
		>$reference DataType checkHasTableColValue$</GenRule>
	<GenRule GenDef="Atom" Name="checkHasValue"
		>$checkHasTableColValue$</GenRule>

	<GenRule GenDef="Atom" Name="checkPKeyHasTableColValue"
		>$checkPKeyTypeHasValue$</GenRule>

	<GenRule GenDef="Atom" Name="checkHasTableColValue"
		>$checkTypeHasValue$</GenRule>

	<GenRule GenDef="Object" Name="checkPKeyTypeHasValue"
		>$checkPKeyPointerHasValue$</GenRule>
	<GenRule GenDef="Object" Name="checkPKeyAttrHasValue"
		>( pkey.get$Optionality$$Name$() != null )</GenRule>

	<GenRule GenDef="Object" Name="checkTypeHasValue"
		>$checkPointerHasValue$</GenRule>
	<GenRule GenDef="Object" Name="checkAttrHasValue"
		>( get$Optionality$$Name$() != null )</GenRule>

	<GenRule GenDef="BoolDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Int16Def" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Int32Def" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Int64Def" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Id16Gen" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Id32Gen" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="Id64Gen" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="FloatDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="DoubleDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>
	<GenRule GenDef="NumberDef" Name="checkPKeyTypeHasValue"
		>$checkPKeyAttrHasValue$</GenRule>

	<GenRule GenDef="BoolDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Int16Def" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Int32Def" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Int64Def" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Id16Gen" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Id32Gen" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="Id64Gen" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="FloatDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="DoubleDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>
	<GenRule GenDef="NumberDef" Name="checkTypeHasValue"
		>$checkAttrHasValue$</GenRule>

	<GenRule GenDef="Object" Name="checkPKeyPointerHasValue"
		>pkey.get$Optionality$$Name$() != null</GenRule>

	<GenRule GenDef="Object" Name="checkPointerHasValue"
		>get$Optionality$$Name$() != null</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyValue"
		>$switch IsNullable yes derefPKeyIfNotNull default derefPKeyDirect$</GenRule>
	<GenRule GenDef="Object" Name="derefPKeyIfNotNull"
		>( $switch BaseModelAtomClass
			BoolDef derefPKeyCheckHasValue
			Int16Def derefPKeyCheckHasValue
			Int32Def derefPKeyCheckHasValue
			Int64Def derefPKeyCheckHasValue
			Id16Gen derefPKeyCheckHasValue
			Id32Gen derefPKeyCheckHasValue
			Id64Gen derefPKeyCheckHasValue
			FloatDef derefPKeyCheckHasValue
			DoubleDef derefPKeyCheckHasValue
			default derefPKeyCheckPointerNotNull$ ) ? ( "\\"" + xmlEncodeString( $derefPKeyValue$.ToString() + "\\"" ) : "null" </GenRule>

	<GenRule GenDef="Object" Name="derefValue"
		>$switch IsNullable yes derefIfNotNull default derefDirect$</GenRule>
	<GenRule GenDef="Object" Name="derefIfNotNull"
		>( $switch BaseModelAtomClass
			BoolDef derefCheckHasValue
			Int16Def derefCheckHasValue
			Int32Def derefCheckHasValue
			Int64Def derefCheckHasValue
			Id16Gen derefCheckHasValue
			Id32Gen derefCheckHasValue
			Id64Gen derefCheckHasValue
			FloatDef derefCheckHasValue
			DoubleDef derefCheckHasValue
			default derefCheckPointerNotNull$ ) ? ( "\\"" + xmlEncodeString( $derefValue$.ToString() + "\\"" ) : "null" </GenRule>

	<GenRule GenDef="Object" Name="derefDotValue"
		>get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefDotPointer"
		>get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="TableCol" Name="derefPKeyValue"
		>$switch BaseModelAtomClass
			BoolDef derefPKeyDotValue
			Int16Def derefPKeyDotValue
			Int32Def derefPKeyDotValue
			Int64Def derefPKeyDotValue
			Id16Gen derefPKeyDotValue
			Id32Gen derefPKeyDotValue
			Id64Gen derefPKeyDotValue
			FloatDef derefPKeyDotValue
			DoubleDef derefPKeyDotValue
			default derefPKeyDotPointer$</GenRule>

	<GenRule GenDef="Atom" Name="derefPKeyValue"
		>$switch BaseModelAtomClass
			BoolDef derefPKeyDotValue
			Int16Def derefPKeyDotValue
			Int32Def derefPKeyDotValue
			Int64Def derefPKeyDotValue
			Id16Gen derefPKeyDotValue
			Id32Gen derefPKeyDotValue
			Id64Gen derefPKeyDotValue
			FloatDef derefPKeyDotValue
			DoubleDef derefPKeyDotValue
			default derefPKeyDotPointer$</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyDotValue"
		>pkey.get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyDotPointer"
		>pkey.get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefCheckHasValue"
		>get$Optionality$$Name$() != null</GenRule>

	<GenRule GenDef="Object" Name="derefCheckPointerNotNull"
		>get$Optionality$$Name$() != null</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyCheckHasValue"
		>pkey.get$Optionality$$Name$() != null</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyCheckPointerNotNull"
		>pkey.get$Optionality$$Name$() != null</GenRule>

	<GenRule GenDef="Object" Name="derefPKeyDirect"
		>pkey.get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="Object" Name="derefDirect"
		>get$Optionality$$Name$()</GenRule>

	<GenRule GenDef="TableCol" Name="Optionality"
		>$switch IsNullable yes implOptionalityOptional default implOptionalityRequired$</GenRule>
	<GenRule ScopeDef="Table" GenDef="Atom" Name="Optionality"
		>$switch IsNullable yes implOptionalityOptional default implOptionalityRequired$</GenRule>

	<GenRule GenDef="Object" Name="implOptionalityOptional"
		>Optional</GenRule>
	<GenRule GenDef="Object" Name="implOptionalityRequired"
		>Required</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTableIntegrityCheck"
		>$switch RelationTypeTag
			Superclass implRamCreateTableCheckSuperClassReference
			Lookup implRamCreateTableCheckReference
			Master implRamCreateTableCheckReference
			Container implRamCreateTableCheckReference
			Owner implRamCreateTableCheckReference
			default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamCreateTableCheckReference"
		>$switch IsRequired yes implRamCreateTableCheckReqRef default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamCreateTableCheckSuperClassReference">
		{
			boolean allNull = true;$iterate Columns( each implRamCreateTableCheckRefIsNull )$
			if( ! allNull ) {
				if( null == schema.getTable$reference ToTable Name$().readDerivedBy$reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$iterate Columns( each implRamCreateTableCheckRefCommaPassArg )$ ) )
				{
					throw new CFLibUnresolvedRelationException( getClass(),
						S_ProcName,
						"$RelationTypeTag$",
						"$RelationTypeTag$",
						"$Name$",
						"$Name$",
						"$reference ToTable Name$",
						"$reference ToTable Name$",
						null );
				}
			}
		}
</GenRule>
	<GenRule GenDef="Relation" Name="implRamCreateTableCheckReqRef">
		{
			boolean allNull = true;$iterate Columns( each implRamCreateTableCheckRefIsNull )$
			if( ! allNull ) {
				if( null == schema.getTable$reference ToTable Name$().readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamCreateTableCheckRefCommaPassArg )$ ) )
				{
					throw new CFLibUnresolvedRelationException( getClass(),
						S_ProcName,
						"$RelationTypeTag$",
						"$RelationTypeTag$",
						"$Name$",
						"$Name$",
						"$reference ToTable Name$",
						"$reference ToTable Name$",
						null );
				}
			}
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="IsFromColNullable"
		>$reference FromCol IsNullable$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefIsNull"
		>$switch IsFromColNullable yes implRamCreateTableCheckRefIsOptNull default implRamCreateTableReqIsNotNull$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableReqIsNotNull">
			allNull = false;</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefIsOptNull">
			if( Buff.get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$() != null ) {
				allNull = false;
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefCommaPassArg">,
						$implRamCreateTableCheckRefPassArg$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamCreateTableCheckRefPassArg"
		>Buff.get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamCreateTableCheckUniqueIndex"
		>$switch IsPrimaryIndex yes empty default implRamCreateTableCheckUniqueIndex$</GenRule>
	<GenRule GenDef="Index" Name="implRamCreateTableCheckUniqueIndex"
		>$switch IsUnique yes implRamCreateTableReallyCheckUniqueIndex default empty$</GenRule>
	<GenRule GenDef="Index" Name="implRamCreateTableReallyCheckUniqueIndex">
		if( dictBy$Suffix$.containsKey( key$Suffix$ ) ) {
			throw new CFLibUniqueIndexViolationException( getClass(),
				S_ProcName,
				"$Name$",
				"$Name$",
				key$Suffix$ );
		}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableNLAttrNameValue">
				+	"$implColumnAttrOptionality$$Name$=" + $reference Column emitKeyValueString$</GenRule>

	<GenRule GenDef="TableCol" Name="emitKeyValueString"
		>$switch IsNullable yes emitKeyOptValueString default emitKeyReqValueString$</GenRule>
	<GenRule GenDef="Atom" Name="emitKeyValueString"
		>$switch IsNullable yes emitKeyOptValueString default emitKeyReqValueString$</GenRule>

	<GenRule GenDef="TableCol" Name="ErrorUnrecognizedBaseModelAtomClass"
		>$$Error unsupported Base Model Atom Class $BaseModelAtomClass$$$</GenRule>
	<GenRule GenDef="Atom" Name="ErrorUnrecognizedBaseModelAtomClass"
		>$$Error unsupported Base Model Atom Class $BaseModelAtomClass$$$</GenRule>

	<GenRule GenDef="TableCol" Name="emitKeyOptValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyOptBlobValueString
			BoolDef emitKeyOptBoolValueString
			EnumDef emitKeyOptEnumValueString
			Int16Def emitKeyOptInt16ValueString
			Int32Def emitKeyOptInt32ValueString
			Int64Def emitKeyOptInt64ValueString
			Id16Gen emitKeyOptInt16ValueString
			Id32Gen emitKeyOptInt32ValueString
			Id64Gen emitKeyOptInt64ValueString
			UInt16Def emitKeyOptUInt16ValueString
			UInt32Def emitKeyOptUInt32ValueString
			UInt64Def emitKeyOptUInt64ValueString
			FloatDef emitKeyOptFloatValueString
			DoubleDef emitKeyOptDoubleValueString
			NumberDef emitKeyOptNumberValueString
			StringDef emitKeyOptStringValueString
			TextDef emitKeyOptStringValueString
			TokenDef emitKeyOptStringValueString
			NmTokenDef emitKeyOptStringValueString
			NmTokensDef emitKeyOptStringValueString
			DateDef emitKeyOptDateValueString
			TimeDef emitKeyOptTimeValueString
			TimestampDef emitKeyOptTimestampValueString
			TZDateDef emitKeyOptTZDateValueString
			TZTimeDef emitKeyOptTZTimeValueString
			TZTimestampDef emitKeyOptTZTimestampValueString
			UuidGen emitKeyOptUuidValueString
			UuidDef emitKeyOptUuidValueString
			DbKeyHash128Gen emitKeyOptDbKeyHashValueString
			DbKeyHash160Gen emitKeyOptDbKeyHashValueString
			DbKeyHash224Gen emitKeyOptDbKeyHashValueString
			DbKeyHash256Gen emitKeyOptDbKeyHashValueString
			DbKeyHash384Gen emitKeyOptDbKeyHashValueString
			DbKeyHash512Gen emitKeyOptDbKeyHashValueString
			DbKeyHash128Def emitKeyOptDbKeyHashValueString
			DbKeyHash160Def emitKeyOptDbKeyHashValueString
			DbKeyHash224Def emitKeyOptDbKeyHashValueString
			DbKeyHash256Def emitKeyOptDbKeyHashValueString
			DbKeyHash384Def emitKeyOptDbKeyHashValueString
			DbKeyHash512Def emitKeyOptDbKeyHashValueString
			Uuid6Gen emitKeyOptUuid6ValueString
			Uuid6Def emitKeyOptUuid6ValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>
	<GenRule GenDef="Atom" Name="emitKeyOptValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyOptBlobValueString
			BoolDef emitKeyOptBoolValueString
			EnumDef emitKeyOptEnumValueString
			Int16Def emitKeyOptInt16ValueString
			Int32Def emitKeyOptInt32ValueString
			Int64Def emitKeyOptInt64ValueString
			Id16Gen emitKeyOptInt16ValueString
			Id32Gen emitKeyOptInt32ValueString
			Id64Gen emitKeyOptInt64ValueString
			UInt16Def emitKeyOptUInt16ValueString
			UInt32Def emitKeyOptUInt32ValueString
			UInt64Def emitKeyOptUInt64ValueString
			FloatDef emitKeyOptFloatValueString
			DoubleDef emitKeyOptDoubleValueString
			NumberDef emitKeyOptNumberValueString
			StringDef emitKeyOptStringValueString
			TextDef emitKeyOptStringValueString
			TokenDef emitKeyOptStringValueString
			NmTokenDef emitKeyOptStringValueString
			NmTokensDef emitKeyOptStringValueString
			DateDef emitKeyOptDateValueString
			TimeDef emitKeyOptTimeValueString
			TimestampDef emitKeyOptTimestampValueString
			TZDateDef emitKeyOptTZDateValueString
			TZTimeDef emitKeyOptTZTimeValueString
			TZTimestampDef emitKeyOptTZTimestampValueString
			UuidGen emitKeyOptUuidValueString
			UuidDef emitKeyOptUuidValueString
			DbKeyHash128Gen emitKeyOptDbKeyHashValueString
			DbKeyHash160Gen emitKeyOptDbKeyHashValueString
			DbKeyHash224Gen emitKeyOptDbKeyHashValueString
			DbKeyHash256Gen emitKeyOptDbKeyHashValueString
			DbKeyHash384Gen emitKeyOptDbKeyHashValueString
			DbKeyHash512Gen emitKeyOptDbKeyHashValueString
			DbKeyHash128Def emitKeyOptDbKeyHashValueString
			DbKeyHash160Def emitKeyOptDbKeyHashValueString
			DbKeyHash224Def emitKeyOptDbKeyHashValueString
			DbKeyHash256Def emitKeyOptDbKeyHashValueString
			DbKeyHash384Def emitKeyOptDbKeyHashValueString
			DbKeyHash512Def emitKeyOptDbKeyHashValueString
			Uuid6Gen emitKeyOptUuid6ValueString
			Uuid6Def emitKeyOptUuid6ValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>
	<GenRule GenDef="TableCol" Name="emitKeyReqValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyReqBlobValueString
			BoolDef emitKeyReqBoolValueString
			EnumDef emitKeyReqEnumValueString
			Int16Def emitKeyReqInt16ValueString
			Int32Def emitKeyReqInt32ValueString
			Int64Def emitKeyReqInt64ValueString
			Id16Gen emitKeyReqInt16ValueString
			Id32Gen emitKeyReqInt32ValueString
			Id64Gen emitKeyReqInt64ValueString
			UInt16Def emitKeyReqUInt16ValueString
			UInt32Def emitKeyReqUInt32ValueString
			UInt64Def emitKeyReqUInt64ValueString
			FloatDef emitKeyReqFloatValueString
			DoubleDef emitKeyReqDoubleValueString
			NumberDef emitKeyReqNumberValueString
			StringDef emitKeyReqStringValueString
			TextDef emitKeyReqStringValueString
			TokenDef emitKeyReqStringValueString
			NmTokenDef emitKeyReqStringValueString
			NmTokensDef emitKeyReqStringValueString
			DateDef emitKeyReqDateValueString
			TimeDef emitKeyReqTimeValueString
			TimestampDef emitKeyReqTimestampValueString
			TZDateDef emitKeyReqTZDateValueString
			TZTimeDef emitKeyReqTZTimeValueString
			TZTimestampDef emitKeyReqTZTimestampValueString
			UuidGen emitKeyReqUuidValueString
			UuidDef emitKeyReqUuidValueString
			DbKeyHash128Gen emitKeyReqDbKeyHashValueString
			DbKeyHash160Gen emitKeyReqDbKeyHashValueString
			DbKeyHash224Gen emitKeyReqDbKeyHashValueString
			DbKeyHash256Gen emitKeyReqDbKeyHashValueString
			DbKeyHash384Gen emitKeyReqDbKeyHashValueString
			DbKeyHash512Gen emitKeyReqDbKeyHashValueString
			DbKeyHash128Def emitKeyReqDbKeyHashValueString
			DbKeyHash160Def emitKeyReqDbKeyHashValueString
			DbKeyHash224Def emitKeyReqDbKeyHashValueString
			DbKeyHash256Def emitKeyReqDbKeyHashValueString
			DbKeyHash384Def emitKeyReqDbKeyHashValueString
			DbKeyHash512Def emitKeyReqDbKeyHashValueString
			Uuid6Gen emitKeyReqUuid6ValueString
			Uuid6Def emitKeyReqUuid6ValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>
	<GenRule GenDef="Atom" Name="emitKeyReqValueString"
		>$switch BaseModelAtomClass
			BlobDef emitKeyReqBlobValueString
			BoolDef emitKeyReqBoolValueString
			EnumDef emitKeyReqEnumValueString
			Int16Def emitKeyReqInt16ValueString
			Int32Def emitKeyReqInt32ValueString
			Int64Def emitKeyReqInt64ValueString
			Id16Gen emitKeyReqInt16ValueString
			Id32Gen emitKeyReqInt32ValueString
			Id64Gen emitKeyReqInt64ValueString
			UInt16Def emitKeyReqUInt16ValueString
			UInt32Def emitKeyReqUInt32ValueString
			UInt64Def emitKeyReqUInt64ValueString
			FloatDef emitKeyReqFloatValueString
			DoubleDef emitKeyReqDoubleValueString
			NumberDef emitKeyReqNumberValueString
			StringDef emitKeyReqStringValueString
			TextDef emitKeyReqStringValueString
			TokenDef emitKeyReqStringValueString
			NmTokenDef emitKeyReqStringValueString
			NmTokensDef emitKeyReqStringValueString
			DateDef emitKeyReqDateValueString
			TimeDef emitKeyReqTimeValueString
			TimestampDef emitKeyReqTimestampValueString
			TZDateDef emitKeyReqTZDateValueString
			TZTimeDef emitKeyReqTZTimeValueString
			TZTimestampDef emitKeyReqTZTimestampValueString
			UuidGen emitKeyReqUuidValueString
			UuidDef emitKeyReqUuidValueString
			DbKeyHash128Gen emitKeyReqDbKeyHashValueString
			DbKeyHash160Gen emitKeyReqDbKeyHashValueString
			DbKeyHash224Gen emitKeyReqDbKeyHashValueString
			DbKeyHash256Gen emitKeyReqDbKeyHashValueString
			DbKeyHash384Gen emitKeyReqDbKeyHashValueString
			DbKeyHash512Gen emitKeyReqDbKeyHashValueString
			DbKeyHash128Def emitKeyReqDbKeyHashValueString
			DbKeyHash160Def emitKeyReqDbKeyHashValueString
			DbKeyHash224Def emitKeyReqDbKeyHashValueString
			DbKeyHash256Def emitKeyReqDbKeyHashValueString
			DbKeyHash384Def emitKeyReqDbKeyHashValueString
			DbKeyHash512Def emitKeyReqDbKeyHashValueString
			Uuid6Gen emitKeyReqUuid6ValueString
			Uuid6Def emitKeyReqUuid6ValueString
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="emitKeyReqBlobValueString"
		>new String( Base64.encodeBase64( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqBoolValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) ? "true" : "false" )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqEnumValueString"
		>Short.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqInt16ValueString"
		>Short.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqInt32ValueString"
		>Integer.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqInt64ValueString"
		>Long.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUInt16ValueString"
		>Integer.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUInt32ValueString"
		>Long.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUInt64ValueString"
		>BigDecimal.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqFloatValueString"
		>Float.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqDoubleValueString"
		>Double.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqNumberValueString"
		>BigNumber.toString( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqStringValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqDateValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTimeValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTimestampValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTZDateValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTZTimeValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqTZTimestampValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqObjToStringValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUuidValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqDbKeyHashValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>
	<GenRule GenDef="Value" Name="emitKeyReqUuid6ValueString"
		>"\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\""</GenRule>

		<GenRule GenDef="Value" Name="emitKeyOptBlobValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + new String( Base64.encodeBase64( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) ) + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptBoolValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : (( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() ) ? "true" : "false" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptEnumValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptInt16ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptInt32ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptInt64ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUInt16ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUInt32ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUInt64ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptFloatValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptDoubleValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptNumberValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() )</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptStringValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptDateValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTimeValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTimestampValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTZDateValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTZTimeValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptTZTimestampValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptDbKeyHashValueString"
		>((( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) || ( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().isNull())) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUuid6ValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptUuidValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>
	<GenRule GenDef="Value" Name="emitKeyOptObjToStringValueString"
		>(( key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$() == null ) ? "null" : ( "\\"" + key$popto Index Suffix$.get$implColumnAttrOptionality$$Name$().toString() + "\\"" ))</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamCreateTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implRamCreateTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableInitIndexKey">
		$DefSchemaName$Buff$TableName$By$Suffix$Key key$Suffix$ = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamCreateTableInitKeyAttr )$</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamCreateTableAddToIndex"
		>$switch IsPrimaryIndex yes empty default implRamCreateTableAddToIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableAddToIndex"
		>$switch IsUnique yes implRamCreateTableAddUniqueKey default implRamCreateTableAddDupKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableAddUniqueKey">
		dictBy$Suffix$.put( key$Suffix$, Buff );
</GenRule>

	<GenRule GenDef="Index" Name="implRamCreateTableAddDupKey">
		Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict$Suffix$;
		if( dictBy$Suffix$.containsKey( key$Suffix$ ) ) {
			subdict$Suffix$ = dictBy$Suffix$.get( key$Suffix$ );
		}
		else {
			subdict$Suffix$ = new HashMap&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt;();
			dictBy$Suffix$.put( key$Suffix$, subdict$Suffix$ );
		}
		subdict$Suffix$.put( pkey, Buff );
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTableInitKeyAttr"
>		key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( Buff.get$implColumnAttrOptionality$$Name$() );
</GenRule>

	<GenRule GenDef="Object" Name="implRamCreateTableSetPKeyClassCode">
		pkey.setClassCode( Buff.getClassCode() );</GenRule>

	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKey"
		>$switch GenerateId yes implRamCreateTablePKeyGenId default maybeImplRamCreateTablePKeyCopyId$</GenRule>

	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKeyGenId"
		>$reference Column implRamCreateTablePKeyGenId$</GenRule>

	<GenRule GenDef="IndexCol" Name="InSuperiorPrimaryKeyRelation">$reference Column InSuperiorPrimaryKeyRelation$</GenRule>
	
	<GenRule GenDef="IndexCol" Name="maybeImplRamCreateTablePKeyCopyId">$switch InSuperiorPrimaryKeyRelation yes empty default implRamCreateTablePKeyCopyId$</GenRule>
	
	<GenRule ScopeDef="Index" GenDef="IndexCol" Name="implRamCreateTablePKeyCopyId"
		>$reference Column implRamCreateTableKeysCopyId$</GenRule>

	<GenRule GenDef="TableCol" Name="HasDispenser"
		>$reference DataType HasDispenser$</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenId">$switch HasDispenser yes implRamCreateTablePKeyGenIdInvokeTableNext default implRamCreateTablePKeyGenIdInvokeSchemaNext$</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeTableNext">
		pkey.set$implColumnAttrOptionality$$Name$( (($SchemaName$Ram$reference DataType reference Dispenser TableName$Table)schema.getTable$reference DataType reference Dispenser TableName$()).next$reference DataType Name$( Authorization$popto Table iterate OnlyOwnerRelations( first implRamCreateTablePKeyGenIdInvokeTableNextPassArgs each empty )$ ) );</GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTablePKeyGenIdInvokeTableNextPassArgs"
		>$reference FromIndex iterate Columns( each implRamCreateTablePKeyGenIdInvokeTableNextCommaPassArg )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamCreateTablePKeyGenIdInvokeTableNextCommaPassArg">,
			Buff.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeSchemaNext">$switch IsPrimaryIndexKeyAtomic yes implRamCreateTablePKeyGenIdInvokeAtomicSchemaNext default implRamCreateTablePKeyGenIdInvokeCompositeSchemaNext$</GenRule>
	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeAtomicSchemaNext">
		pkey = schema.next$reference DataType Name$();</GenRule>
	<GenRule GenDef="TableCol" Name="implRamCreateTablePKeyGenIdInvokeCompositeSchemaNext">
		pkey.set$implColumnAttrOptionality$$Name$( schema.next$reference DataType Name$() );</GenRule>

	<GenRule GenDef="Atom" Name="implRamCreateTableKeys"
		></GenRule>

	<GenRule GenDef="Relation" Name="implRamCreateTablePKeyGenIdInitCols"
		>$iterate Columns( each implRamCreateTablePKeyGenIdInitContainerKeyCol )$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamCreateTablePKeyGenIdInitContainerKeyCol">
	 	$leadlower popto TableCol reference DataType reference Dispenser reference BaseClass TableName$PKey.set$reference FromCol OptionalOrRequired$$reference FromCol Name$( Buff.get$reference FromCol OptionalOrRequired$$reference FromCol Name$() );</GenRule>

	<GenRule GenDef="TableCol" Name="implRamCreateTableKeysCopyId">$switch IsPrimaryIndexKeyAtomic yes implRamCreateTableKeysCopyAtomicId default implRamCreateTableKeysCopyCompositeId$</GenRule>
	<GenRule GenDef="TableCol" Name="implRamCreateTableKeysCopyAtomicId">
		pkey = Buff.get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$();</GenRule>
	<GenRule GenDef="TableCol" Name="implRamCreateTableKeysCopyCompositeId">
		pkey.set$implColumnAttrOptionality$$Name$( Buff.get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$() );</GenRule>
	<GenRule GenDef="Atom" Name="implRamCreateTableKeysCopyId">$switch IsPrimaryIndexKeyAtomic yes implRamCreateTableKeysCopyAtomicId default implRamCreateTableKeysCopyCompositeId$</GenRule>
	<GenRule GenDef="Atom" Name="implRamCreateTableKeysCopyAtomicId">
		pkey = Buff.get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$();</GenRule>
	<GenRule GenDef="Atom" Name="implRamCreateTableKeysCopyCompositeId">
		pkey.set$implColumnAttrOptionality$$Name$( Buff.get$switch IsNullable yes implColumnAttrOptional default implColumnAttrRequired$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implRamReadTableByPKey">
	@Override
	public I$DefSchemaName$$TableName$ read$TableName$( I$SecSchemaName$Authorization Authorization,
		$ICompactedPrimaryIndexClass$ PKey )
	{
		I$DefSchemaName$$TableName$ rec;
		if( dictByPKey.containsKey( PKey ) ) {
			rec = dictByPKey.get( PKey );
		}
		else {
			rec = null;
		}
		return( rec );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamReadAllTable">
	@Override
	public I$DefSchemaName$$TableName$[] readAll$TableName$( I$SecSchemaName$Authorization Authorization )
	{
		I$DefSchemaName$$TableName$[] retList = new I$DefSchemaName$$TableName$[ dictByPKey.values().size() ];
		Iterator&lt; $DefSchemaName$Buff$TableName$ &gt; iter = dictByPKey.values().iterator();
		int idx = 0;
		while( iter.hasNext() ) {
			retList[ idx++ ] = iter.next();
		}
		return( retList );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByIndex"
		>$switch IsUnique
			yes maybeImplRamReadTableByUniqueIndex
			default implRamReadTableByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamReadTableByUniqueIndex"
		>$switch IsPrimaryIndex yes implRamReadTableByUniquePIndex default implRamReadTableByUniqueIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByUniquePIndex">
	@Override
	public I$DefSchemaName$$TableName$ read$TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$reference Table reference BaseClass BuffCompactedPrimaryIndexClass$ key = ($reference Table reference BaseClass BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());
$iterate Columns( each implRamReadTableSetKeyAttr )$
		I$DefSchemaName$$TableName$ rec;
		if( dictByPKey.containsKey( key ) ) {
			rec = dictByPKey.get( key );
		}
		else {
			rec = null;
		}
		return( rec );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByUniqueIndex">
	@Override
	public I$DefSchemaName$$TableName$ read$TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$DefSchemaName$Buff$TableName$By$Suffix$Key key = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();$iterate Columns( each implRamReadTableSetKeyAttr )$
		I$DefSchemaName$$TableName$ rec;
		if( dictBy$Suffix$.containsKey( key ) ) {
			rec = dictBy$Suffix$.get( key );
		}
		else {
			rec = null;
		}
		return( rec );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamReadTableByDuplicateIndex">
	@Override
	public I$DefSchemaName$$TableName$[] read$TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$DefSchemaName$Buff$TableName$By$Suffix$Key key = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamReadTableSetKeyAttr )$
		I$DefSchemaName$$TableName$[] recArray;
		if( dictBy$Suffix$.containsKey( key ) ) {
			Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict$Suffix$
				= dictBy$Suffix$.get( key );
			recArray = new I$DefSchemaName$$TableName$[ subdict$Suffix$.size() ];
			Iterator&lt; $DefSchemaName$Buff$TableName$ &gt; iter = subdict$Suffix$.values().iterator();
			int idx = 0;
			while( iter.hasNext() ) {
				recArray[ idx++ ] = iter.next();
			}
		}
		else {
			Map&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict$Suffix$
				= new HashMap&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt;();
			dictBy$Suffix$.put( key, subdict$Suffix$ );
			recArray = new I$DefSchemaName$$TableName$[0];
		}
		return( recArray );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableCheckRevision">
		if( existing.getRequiredRevision() != Buff.getRequiredRevision() ) {
			throw new CFLibCollisionDetectedException( getClass(),
				"update$TableName$",
				pkey );
		}
		Buff.setRequiredRevision( Buff.getRequiredRevision() + 1 );</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTable">$switch IsPrimaryIndexKeyAtomic yes implRamUpdateAtomicTable default implRamUpdateCompositeTable$</GenRule>
	<GenRule GenDef="Table" Name="implRamUpdateAtomicTable">
	public I$DefSchemaName$$TableName$ update$TableName$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$ iBuff )
	{$switch HasSuperClassRelation yes implRamUpdateTableInvokeSuper default implRamUpdateTableImplBase$
		$BuffCompactedPrimaryIndexClass$ pkey = Buff.getPKey();
		$DefSchemaName$Buff$TableName$ existing = dictByPKey.get( pkey );
		if( existing == null ) {
			throw new CFLibStaleCacheDetectedException( getClass(),
				"update$TableName$",
				"Existing record not found",
				"Existing record not found",
				"$TableName$",
				"$TableName$",
				pkey );
		}$switch HasSuperClassRelation no implRamUpdateTableCheckRevision default empty$$iterate Index( each maybeImplRamUpdateTableInitIndexKey )$
		// Check unique indexes
$iterate Index( each maybeImplRamUpdateTableCheckUniqueKey )$
		// Validate foreign keys
$iterate Relation( each implRamUpdateTableIntegrityCheck empty empty )$
		// Update is valid

		Map&lt; $BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict;

		dictByPKey.remove( pkey );
		dictByPKey.put( pkey, Buff );
$iterate Index( each maybeImplRamUpdateTableReplaceIndexEntry )$
		return(Buff);
	}
</GenRule>
	<GenRule GenDef="Table" Name="implRamUpdateCompositeTable">
	@Override
	public I$DefSchemaName$$TableName$ update$TableName$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$ iBuff )
	{$switch HasSuperClassRelation yes implRamUpdateTableInvokeSuper default implRamUpdateTableImplBase$
		$BuffCompactedPrimaryIndexClass$ pkey = ($BuffCompactedPrimaryIndexClass$)(schema.getFactory$reference BaseClass TableName$().newPKey());$implRamCreateTablePKeyCopyBuff$
		$DefSchemaName$Buff$TableName$ existing = dictByPKey.get( pkey );
		if( existing == null ) {
			throw new CFLibStaleCacheDetectedException( getClass(),
				"update$TableName$",
				"Existing record not found",
				"Existing record not found",
				"$TableName$",
				"$TableName$",
				pkey );
		}$switch HasSuperClassRelation no implRamUpdateTableCheckRevision default empty$$iterate Index( each maybeImplRamUpdateTableInitIndexKey )$
		// Check unique indexes
$iterate Index( each maybeImplRamUpdateTableCheckUniqueKey )$
		// Validate foreign keys
$iterate Relation( each implRamUpdateTableIntegrityCheck empty empty )$
		// Update is valid

		Map&lt; $BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict;

		dictByPKey.remove( pkey );
		dictByPKey.put( pkey, Buff );
$iterate Index( each maybeImplRamUpdateTableReplaceIndexEntry )$
		return(Buff);
	}
</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableImplBase">
		$DefSchemaName$Buff$TableName$ Buff = ($DefSchemaName$Buff$TableName$)ensureRec(iBuff);</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableInvokeSuper">
		$DefSchemaName$Buff$TableName$ Buff = ($DefSchemaName$Buff$TableName$)(schema.getTable$reference SuperClassRelation reference ToTable TableName$().update$reference SuperClassRelation reference ToTable TableName$( Authorization,	iBuff ));</GenRule>

	<GenRule GenDef="Table" Name="implRamUpdateTableSetPKeyClassCode">
		pkey.setClassCode( Buff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTablePKey">
		pkey.set$implColumnAttrOptionality$$Name$( Buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Relation" Name="implRamUpdateTableIntegrityCheck"
		>$switch RelationTypeTag
			Superclass implRamUpdateTableCheckSuperClassReference
			Lookup implRamUpdateTableCheckReference
			Master implRamUpdateTableCheckReference
			Container implRamUpdateTableCheckReference
			Owner implRamUpdateTableCheckReference
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implRamToIndexSuffix"
		>$reference ToIndex implRamIndexSuffix$</GenRule>
	<GenRule GenDef="Index" Name="implRamIndexSuffix"
		>$switch IsPrimaryIndex yes implRamIndexBasePrimarySuffix default Suffix$</GenRule>
	<GenRule GenDef="Index" Name="implRamIndexBasePrimarySuffix"
		>$reference Table reference BaseClass reference PrimaryKeyIndex Suffix$</GenRule>

	<GenRule GenDef="Relation" Name="implRamFromIndexSuffix"
		>$reference FromIndex implRamIndexSuffix$</GenRule>

	<GenRule GenDef="Relation" Name="implRamUpdateTableCheckReference"
		>$switch IsRequired yes implRamUpdateTableCheckReqRef default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamUpdateTableCheckSuperClassReference">
		{
			boolean allNull = true;
$iterate Columns( each implRamUpdateTableCheckReqRefColIsNull )$
			if( allNull ) {
				if( null == schema.getTable$reference ToTable Name$().readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamUpdateTableCheckRefCommaPassArg )$ ) )
				{
					throw new CFLibUnresolvedRelationException( getClass(),
						"update$TableName$",
						"$RelationTypeTag$",
						"$RelationTypeTag$",
						"$Name$",
						"$Name$",
						"$reference ToTable Name$",
						"$reference ToTable Name$",
						null );
				}
			}
		}
</GenRule>
	<GenRule GenDef="Relation" Name="implRamUpdateTableCheckReqRef">
		{
			boolean allNull = true;
$iterate Columns( each implRamUpdateTableCheckReqRefColIsNull )$
			if( allNull ) {
				if( null == schema.getTable$reference ToTable Name$().readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamUpdateTableCheckRefCommaPassArg )$ ) )
				{
					throw new CFLibUnresolvedRelationException( getClass(),
						"update$TableName$",
						"$RelationTypeTag$",
						"$RelationTypeTag$",
						"$Name$",
						"$Name$",
						"$reference ToTable Name$",
						"$reference ToTable Name$",
						null );
				}
			}
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckReqRefColIsNull"
		>$switch IsFromColNullable yes implRamUpdateTableCheckRefColIsOptNull default empty$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefColIsOptNull"
>			if( Buff.get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$() != null ) {
				allNull = false;
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefCommaPassArg">,
						$implRamUpdateTableCheckRefPassArg$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefPassArg"
		>Buff.get$reference FromCol implColumnAttrOptionality$$reference FromCol Name$$switch IsFromColNullable yes implRamUpdateTableCheckRefPassArgDotValue default empty$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamUpdateTableCheckRefPassArgDotValue"
		></GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamUpdateTableCheckUniqueKey"
		>$switch IsPrimaryIndex yes empty default implRamUpdateTableCheckUniqueKey$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableCheckUniqueKey"
		>$switch IsUnique yes implRamUpdateTableReallyCheckUniqueKey default empty$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReallyCheckUniqueKey">
		if( ! existingKey$Suffix$.equals( newKey$Suffix$ ) ) {
			if( dictBy$Suffix$.containsKey( newKey$Suffix$ ) ) {
				throw new CFLibUniqueIndexViolationException( getClass(),
					"update$TableName$",
					"$IndexName$",
					"$IndexName$",
					newKey$Suffix$ );
			}
		}
</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamUpdateTableReplaceIndexEntry"
		>$switch IsPrimaryIndex yes empty default implRamUpdateTableReplaceIndexEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReplaceIndexEntry"
		>$switch IsUnique yes implRamUpdateTableReplaceUniqueEntry default implRamUpdateTableReplaceDupEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReplaceUniqueEntry">
		dictBy$Suffix$.remove( existingKey$Suffix$ );
		dictBy$Suffix$.put( newKey$Suffix$, Buff );
</GenRule>
	<GenRule GenDef="Index" Name="implRamUpdateTableReplaceDupEntry">
		subdict = dictBy$Suffix$.get( existingKey$Suffix$ );
		if( subdict != null ) {
			subdict.remove( pkey );
		}
		if( dictBy$Suffix$.containsKey( newKey$Suffix$ ) ) {
			subdict = dictBy$Suffix$.get( newKey$Suffix$ );
		}
		else {
			subdict = new HashMap&lt; $reference Table reference BaseClass BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt;();
			dictBy$Suffix$.put( newKey$Suffix$, subdict );
		}
		subdict.put( pkey, Buff );
</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamUpdateTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implRamUpdateTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamUpdateTableInitIndexKey">
		$DefSchemaName$Buff$TableName$By$Suffix$Key existingKey$Suffix$ = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamUpdateTableInitExistingKeyAttr )$
		$DefSchemaName$Buff$TableName$By$Suffix$Key newKey$Suffix$ = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamUpdateTableInitNewKeyAttr )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitExistingKeyAttr"
>		existingKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( existing.get$implColumnAttrOptionality$$Name$() );
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamUpdateTableInitNewKeyAttr"
>		newKey$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( Buff.get$implColumnAttrOptionality$$Name$() );
</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableCheckRevision">
		if( existing.getRequiredRevision() != Buff.getRequiredRevision() )
		{
			throw new CFLibCollisionDetectedException( getClass(),
				"delete$TableName$",
				pkey );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTable">$switch IsPrimaryIndexKeyAtomic yes implRamDeleteAtomicTable default implRamDeleteCompositeTable$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteAtomicTable">
	@Override
	public void delete$TableName$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$ iBuff )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$Table.delete$TableName$() ";
		$DefSchemaName$Buff$TableName$ Buff = ($DefSchemaName$Buff$TableName$)ensureRec(iBuff);
		int classCode;
		$BuffCompactedPrimaryIndexClass$ pkey = ($BuffCompactedPrimaryIndexClass$)(Buff.getPKey());
		$DefSchemaName$Buff$TableName$ existing = dictByPKey.get( pkey );
		if( existing == null ) {
			return;
		}$implRamDeleteTableCheckRevision$$switch HasChain yes implRamDeleteTableFetchContainerKeys default empty$$switch HasChain yes implRamDeleteTableFetchContainer default empty$$switch HasChain yes implRamDeleteTableChainSelectChainLinks default empty$$switch HasChain yes implRamDeleteTableUpdatePrev default empty$$switch HasChain yes implRamDeleteTableUpdateNext default empty$$implRamDeleteTableClearDeps$$switch ClassHierarchyHasSubObjectLookup yes implRamDeleteTableClearRootSubObjectRefs default empty$$switch HasDelDeps no implRamDeleteCascades default implRamDeleteTableDelDeps$$iterate Index( each maybeImplRamDeleteTableInitIndexKey )$
		// Validate reverse foreign keys
$iterate ReverseRelations( each implRamDeleteTableIntegrityCheck empty empty )$
		// Delete is valid
		Map&lt; $BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict;

		dictByPKey.remove( pkey );
$iterate Index( each maybeImplRamDeleteTableRemoveIndexEntry )$$switch HasSuperClassRelation yes implRamDeleteTableInvokeSuper default empty$
	}$implRamDeleteTableByInheritedIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteCompositeTable">
	@Override
	public void delete$TableName$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$ iBuff )
	{
		final String S_ProcName = "$SchemaName$Ram$TableName$Table.delete$TableName$() ";
		$DefSchemaName$Buff$TableName$ Buff = ($DefSchemaName$Buff$TableName$)ensureRec(iBuff);
		int classCode;
		$BuffCompactedPrimaryIndexClass$ pkey = ($BuffCompactedPrimaryIndexClass$)(Buff.getPKey());
		$DefSchemaName$Buff$TableName$ existing = dictByPKey.get( pkey );
		if( existing == null ) {
			return;
		}$implRamDeleteTableCheckRevision$$switch HasChain yes implRamDeleteTableFetchContainerKeys default empty$$switch HasChain yes implRamDeleteTableFetchContainer default empty$$switch HasChain yes implRamDeleteTableChainSelectChainLinks default empty$$switch HasChain yes implRamDeleteTableUpdatePrev default empty$$switch HasChain yes implRamDeleteTableUpdateNext default empty$$implRamDeleteTableClearDeps$$switch ClassHierarchyHasSubObjectLookup yes implRamDeleteTableClearRootSubObjectRefs default empty$$switch HasDelDeps no implRamDeleteCascades default implRamDeleteTableDelDeps$$iterate Index( each maybeImplRamDeleteTableInitIndexKey )$
		// Validate reverse foreign keys
$iterate ReverseRelations( each implRamDeleteTableIntegrityCheck empty empty )$
		// Delete is valid
		Map&lt; $BuffCompactedPrimaryIndexClass$, $DefSchemaName$Buff$TableName$ &gt; subdict;

		dictByPKey.remove( pkey );
$iterate Index( each maybeImplRamDeleteTableRemoveIndexEntry )$$switch HasSuperClassRelation yes implRamDeleteTableInvokeSuper default empty$
	}$implRamDeleteTableByInheritedIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteCascades"
		>$implRamReallyDeleteCascades$</GenRule>

	<GenRule GenDef="Table" Name="implRamReallyDeleteCascades"
		>$iterate Relation( each implRamDeleteCascadeRelation empty empty )$$switch HasSuperClassRelation yes implRamDeleteSuperCascades default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteSuperCascades"
		>$reference SuperClassRelation reference ToTable implRamReallyDeleteCascades$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascadeRelation"
		>$switch RelationTypeTag
			Components implRamDeleteCascade
			Children implRamDeleteCascade
			Details implRamDeleteCascade
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascade"
		>$switch ToIndexIsUnique yes implRamDeleteCascadeSingleton default implRamDeleteCascadeMany$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascadeSingleton">
		// Short circuit self-referential code to prevent stack overflows
		if( null != schema.getTable$reference ToTable TableName$().readDerivedBy$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ ) ) {
			schema.getTable$reference ToTable TableName$().delete$reference ToTable TableName$By$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );
		}</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteCascadeMany">
		// Short circuit self-referential code to prevent stack overflows
		Object arrCheck$Name$[] = schema.getTable$reference ToTable TableName$().readDerivedBy$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );
		if( arrCheck$Name$.length &gt; 0 ) {
			schema.getTable$reference ToTable TableName$().delete$reference ToTable TableName$By$reference ToIndex Suffix$( Authorization$iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );
		}</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableDelDeps"
		>$implRamReallyDeleteTableDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamReallyDeleteTableDelDeps"
		>$switch HasSuperClassRelation yes implRamDeleteTableInhDelDeps default implRamDeleteTableBaseDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInhDelDeps"
		>$iterate ReverseDelDeps( each implRamDeleteTableDelDep empty empty )$$reference SuperClassRelation reference ToTable implRamReallyDeleteTableDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableBaseDelDeps"
		>$iterate ReverseDelDeps( each implRamDeleteTableDelDep empty empty )$</GenRule>

	<GenRule GenDef="DelDep" Name="RelationIsUnique"
		>$reference Relation IsUnique$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelThisOne">
					schema.getTable$reference Relation reference ToTable TableName$().delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelExistingPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelExistingPassArg">,
						existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelUniqueDepChaseDown">
		I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ buff$Name$ = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
		if( buff$Name$ != null ) {$reference DelSubDep implRamDeleteTableDelDep$
		}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaExistingArg">,
			existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelTopDep" Name="implRamDeleteTableDelDupDepChaseDown">
		$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
		I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
		for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
			buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference DelSubDep implRamDeleteTableDelDep$
		}</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelThisOne">
					schema.getTable$reference Relation reference ToTable TableName$().delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelTopDepPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelTopDepPassArg">,
						buff$popto DelTopDep Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelUniqueDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelTopDepArg )$ ));
			if( buff$Name$ != null ) {$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelTopDepArg">,
				buff$popto DelTopDep Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implRamDeleteTableDelDupDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelTopDepArg )$ );
			for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
				buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelThisOne">
					schema.getTable$reference Relation reference ToTable TableName$().delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelSubDep1PassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep1PassArg">,
						buff$popto DelSubDep1 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep1Arg">,
					buff$popto DelSubDep1 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelUniqueDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep1Arg )$ ));
			if( buff$Name$ != null ) {$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implRamDeleteTableDelDupDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep1Arg )$ );
			for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
				buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelDep"
		>$switch RelationIsUnique yes implRamDeleteTableDelUniqueDep default implRamDeleteTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelUniqueDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelUniqueDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelDupDep"
		>$switch HasDelSubDep yes implRamDeleteTableDelDupDepChaseDown default implRamDeleteTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelThisOne">
					schema.getTable$reference Relation reference ToTable TableName$().delete$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTableDelSubDep2PassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableDelSubDep2PassArg">,
						buff$popto DelSubDep2 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelUniqueDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep2Arg )$ ));
			if( buff$Name$ != null ) {$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaDelSubDep2Arg">,
				buff$popto DelSubDep2 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implRamDeleteTableDelDupDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaDelSubDep2Arg )$ );
			for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
				buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference DelSubDep implRamDeleteTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelDep" Name="implRamDeleteTableDelDepWalkAllocEditBuff">
					else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
						editBuff = schema.getFactory$TableName$().newRec();
					}$iterate TableSubClasses( each implRamDeleteTableDelDepWalkAllocEditBuff empty empty )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearRootSubObjectExistingArg">,
			existing.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearRootSubObjectRefs">
		$EffSchemaName$Buff$TableName$ editSubobj = ($EffSchemaName$Buff$TableName$)(schema.getTable$TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearRootSubObjectExistingArg )$ ));$implRamDeleteTableClearSubObjectRefs$
		classCode = editSubobj.getClassCode();
		if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
			schema.getTable$TableName$().update$TableName$( Authorization, editSubobj );
		}$iterate TableSubClasses( each implRamDeleteTableSubObjectWalkSaveEditBuff empty empty )$
		else {
			throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-clear-root-subobject-refs-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
		}
		existing = editSubobj;</GenRule>

	<GenRule GenDef="Table" Name="ClassHierarchyHasSubObjectLookup"
		>$switch MaybeHasSubObjectLookup empty no default yes$</GenRule>

	<GenRule GenDef="Table" Name="MaybeHasSubObjectLookup"
		>$switch HasSubObjectLookup yes yes default empty$$switch HasSuperClassRelation yes InhMaybeHasSubObjectLookup default empty$</GenRule>

	<GenRule GenDef="Table" Name="InhMaybeHasSubObjectLookup"
		>$reference SuperClassRelation reference ToTable MaybeHasSubObjectLookup$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearSubObjectRefs"
		>$switch HasSuperClassRelation yes implRamDeleteTableInhClearSubObjectRefs default implRamDeleteTableBaseClearSubObjectRefs$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInhClearSubObjectRefs"
		>$reference SuperClassRelation reference ToTable implRamDeleteTableClearSubObjectRefs$$switch HasSubObjectLookup yes implRamDeleteTableClearSubObjectLookups default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableBaseClearSubObjectRefs"
		>$switch HasSubObjectLookup yes implRamDeleteTableClearSubObjectLookups default empty$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearSubObjectLookups"
		>$iterate Relation( each implRamDeleteTableClearSubObjectLookupCols empty empty )$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableClearSubObjectLookupCols"
			>$switch IsSubObjectLookup yes implRamDeleteTableReallyClearSubObjectLookupCols default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableReallyClearSubObjectLookupCols">
			editSubobj.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamDeleteTableClearSubObjectPassFromCol each implRamDeleteTableClearSubObjectCommaPassFromCol )$);</GenRule>

	<GenRule GenDef="Object" Name="implRamDeleteTableClearSubObjectPassFromCol">($reference FromCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="Object" Name="implRamDeleteTableClearSubObjectCommaPassFromCol">, $implRamDeleteTableClearSubObjectPassFromCol$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableSubObjectWalkSaveEditBuff">
		else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
			schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editSubobj );
		}$iterate TableSubClasses( each implRamDeleteTableSubObjectWalkSaveEditBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableSubObjectWalkAllocEditBuff">
		else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
			editSubobj = schema.getFactory$TableName$().newRec();
		}$iterate TableSubClasses( each implRamDeleteTableSubObjectWalkAllocEditBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearDeps"
		>$switch HasSuperClassRelation yes implRamDeleteTableInhClearDeps default implRamDeleteTableBaseClearDeps$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInhClearDeps"
		>$reference SuperClassRelation reference ToTable implRamDeleteTableClearDeps$$iterate ReverseClearDeps( each implRamDeleteTableClearDep empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableBaseClearDeps"
		>$iterate ReverseClearDeps( each implRamDeleteTableClearDep empty empty )$</GenRule>

	<GenRule GenDef="ClearDep" Name="RelationIsUnique"
		>$reference Relation IsUnique$</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearDep"
		>$switch RelationIsUnique yes implRamDeleteTableClearUniqueDep default implRamDeleteTableClearDupDep$</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearUniqueDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearUniqueDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearDupDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearDupDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassExistingArg">,
						existing.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearThisOne">
					{
						$reference Relation reference FromTable EffSchemaName$Buff$reference Relation reference FromTable Name$ editBuff = ($reference Relation reference FromTable EffSchemaName$Buff$reference Relation reference FromTable Name$)(schema.getTable$reference Relation reference FromTable TableName$().readDerivedBy$reference Relation reference FromTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$reference Relation reference FromTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassExistingArg )$ ));
						editBuff.set$reference Relation OptionalOrRequired$$reference Relation RelationType$$reference Relation Suffix$($reference Relation iterate Columns( first implRamDeleteTableClearRelationPassFromAttr each implRamDeleteTableClearRelationCommaPassFromAttr empty empty )$);
						classCode = editBuff.getClassCode();
						if( classCode == I$reference Relation reference FromTable DefSchemaName$$reference Relation reference FromTable Name$.CLASS_CODE ) {
							schema.getTable$reference Relation reference FromTable TableName$().update$popto ClearTopDep reference Relation reference FromTable TableName$( Authorization, editBuff );
						}$reference Relation reference FromTable iterate TableSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-clear-top-dep-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
						}
					}</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearUniqueDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ ));
			if( buff$Name$ != null ) {$reference ClearSubDep implRamDeleteTableClearDep$
			}</GenRule>

	<GenRule GenDef="ClearTopDep" Name="implRamDeleteTableClearDupDepChaseDown">
			$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaExistingArg )$ );
			for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
				buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference ClearSubDep implRamDeleteTableClearDep$
			}</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearDep"
		>$switch RelationIsUnique yes implRamDeleteTableClearUniqueDep default implRamDeleteTableClearDupDep$</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearUniqueDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearUniqueDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearDupDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearDupDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassTopDepArg">,
							buff$popto ClearTopDep Name$.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearThisOne">
					{
						$popto ClearTopDep reference Relation reference ToTable EffSchemaName$Buff$popto ClearTopDep reference Relation reference ToTable Name$ editBuff = ($popto ClearTopDep reference Relation reference ToTable EffSchemaName$Buff$popto ClearTopDep reference Relation reference ToTable Name$)(schema.getTable$popto ClearTopDep reference Relation reference ToTable TableName$().readDerivedBy$popto ClearTopDep reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$popto ClearTopDep reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassTopDepArg )$ ));$reference Relation implRamDeleteTableClearRelationFromAttr$
						classCode = editBuff.getClassCode();
						if( classCode == I$popto ClearTopDep reference Relation reference ToTable DefSchemaName$$popto ClearTopDep reference Relation reference ToTable Name$.CLASS_CODE ) {
							schema.getTable$popto ClearTopDep reference Relation reference ToTable TableName$().update$popto ClearTopDep reference Relation reference ToTable TableName$( Authorization, editBuff );
						}$popto ClearTopDep reference Relation reference ToTable iterate TableSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-clear-sub-dep-1-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
						}
					}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearTopDepArg">,
				buff$popto ClearTopDep Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearUniqueDepChaseDown">
				$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference FromIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearTopDepArg )$ ));
				if( buff$Name$ != null ) {$reference ClearSubDep implRamDeleteTableClearDep$
				}</GenRule>

	<GenRule GenDef="ClearSubDep1" Name="implRamDeleteTableClearDupDepChaseDown">
				$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
				I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearTopDepArg )$ );
				for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
					buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference ClearSubDep implRamDeleteTableClearDep$
				}</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearDep"
		>$switch RelationIsUnique yes implRamDeleteTableClearUniqueDep default implRamDeleteTableClearDupDep$</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearUniqueDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearUniqueDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearDupDep"
		>$switch HasClearSubDep yes implRamDeleteTableClearDupDepChaseDown default implRamDeleteTableClearThisOne$</GenRule>

<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassSubDep1Arg">,
							buff$popto ClearSubDep1 Name$.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearThisOne">
					{
						$popto ClearSubDep1 reference Relation reference ToTable EffSchemaName$Buff$popto ClearSubDep1 reference Relation reference ToTable Name$ editBuff = ($popto ClearSubDep1 reference Relation reference ToTable EffSchemaName$Buff$popto ClearSubDep1 reference Relation reference ToTable Name$)(schema.getTable$popto ClearSubDep1 reference Relation reference ToTable TableName$().readDerivedBy$popto ClearSubDep1 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$popto ClearSubDep1 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassSubDep1Arg )$ ));$reference Relation implRamDeleteTableClearRelationFromAttr$
						classCode = editBuff.getClassCode();
						if( classCode == I$popto ClearSubDep1 reference Relation reference ToTable EffSchemaName$$popto ClearSubDep1 reference Relation reference ToTable TableName$.CLASS_CODE ) {
							schema.getTable$popto ClearSubDep1 reference Relation reference ToTable TableName$().update$popto ClearSubDep1 reference Relation reference ToTable TableName$( Authorization, editBuff );
						}$popto ClearSubDep1 reference Relation reference ToTable iterate TableSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-clear-sub-dep-2-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
						}
					}</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearUniqueDepChaseDown">
					$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearSubDep1Arg )$ ));
					if( buff$Name$ != null ) {$reference ClearSubDep implRamDeleteTableClearDep$
					}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaClearSubDep1Arg">,
						buff$popto ClearSubDep1 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="ClearSubDep2" Name="implRamDeleteTableClearDupDepChaseDown">
					$reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$ buff$Name$;
					I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$ arr$Name$[] = schema.getTable$reference Relation reference ToTable TableName$().readDerivedBy$reference Relation reference ToIndex Suffix$( Authorization$reference Relation iterate Columns( each implRamDeleteTablePassCommaClearSubDep1Arg )$ );
					for( int idx$Name$ = 0; idx$Name$ &lt; arr$Name$.length; idx$Name$++ ) {
						buff$Name$ = ($reference Relation reference ToTable EffSchemaName$Buff$reference Relation reference ToTable TableName$)(arr$Name$[idx$Name$]);$reference ClearSubDep implRamDeleteTableClearThisOne$
					}</GenRule>

	<GenRule GenDef="ClearDep" Name="implRamDeleteTableClearDepWalkAllocEditBuff">
						else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
							editBuff = schema.getFactory$TableName$().newRec();
						}$iterate TableSubClasses( each implRamDeleteTableClearDepWalkAllocEditBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableClearDepWalkSaveEditBuff">
						else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
							schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editBuff );
						}$iterate TableSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$</GenRule>

<GenRule GenDef="IndexCol" Name="implRamDeleteTableClearPassSubDep2Arg">,
							buff$popto ClearSubDep1 Name$.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="ClearSubDep3" Name="implRamDeleteTableClearThisOne">
					{
						$popto ClearSubDep2 reference Relation reference ToTable EffSchemaName$Buff$popto ClearSubDep2 reference Relation reference ToTable Name$ editBuff = ($popto ClearSubDep2 reference Relation reference ToTable EffSchemaName$Buff$popto ClearSubDep2 reference Relation reference ToTable Name$)(schema.getTable$popto ClearSubDep2 reference Relation reference ToTable TableName$().readDerivedBy$popto ClearSubDep2 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$popto ClearSubDep2 reference Relation reference ToTable reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableClearPassSubDep2Arg )$ ));$reference Relation implRamDeleteTableClearRelationFromAttr$
						classCode = editBuff.getClassCode();
						if( classCode == I$popto ClearSubDep2 reference Relation reference ToTable DefSchemaName$$popto ClearSubDep2 reference Relation reference ToTable Name$.CLASS_CODE ) {
							schema.getTable$popto ClearSubDep2 reference Relation reference ToTable TableName$().update$popto ClearSubDep2 reference Relation reference ToTable TableName$( Authorization, editBuff );
						}$popto ClearSubDep2 reference Relation reference ToTable iterate TableSubClasses( each implRamDeleteTableClearDepWalkSaveEditBuff empty empty )$
						else {
							throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-clear-sub-dep-3-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
						}
					}
				</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableClearRelationToAttr">
						editBuff.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamDeleteTableClearRelationPassToAttr each implRamDeleteTableClearRelationCommaPassToAttr )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearRelationPassToAttr">($reference ToCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearRelationCommaPassToAttr">, $implRamDeleteTableClearRelationPassToAttr$</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableClearRelationFromAttr">
						editBuff.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamDeleteTableClearRelationPassFromAttr each implRamDeleteTableClearRelationCommaPassFromAttr )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearRelationPassFromAttr">($reference FromCol reference Column implJavaOptAtomType$)null</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableClearRelationCommaPassFromAttr">, $implRamDeleteTableClearRelationPassFromAttr$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdatePrev">
		$reference Chain reference PrevRel reference ToTable EffSchemaName$Buff$reference Chain reference PrevRel reference ToTable TableName$ prev = null;
		if( $reference Chain reference PrevRel iterate Columns( first implRamDeleteTableUpdatePrevCheckNotNull each implRamDeleteTableUpdatePrevCheckAndNotNull )$ )
		{
			prev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference PrevRel reference ToTable TableName$().readDerivedBy$reference Chain reference PrevRel reference ToIndex Suffix$( Authorization$reference Chain reference PrevRel iterate Columns( each implRamTableUpdatePrevPassCommaVar )$ ));
			if( prev == null ) {
				throw new CFLibNullArgumentException( getClass(),
					S_ProcName,
					0,
					"prev" );
			}
			$reference Chain reference PrevRel reference ToTable EffSchemaName$Buff$reference Chain reference PrevRel reference ToTable TableName$ editPrev;
			classCode = prev.getClassCode();
			if( classCode == I$reference Chain reference PrevRel reference ToTable DefSchemaName$$reference Chain reference PrevRel reference ToTable Name$.CLASS_CODE ) {
				editPrev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getFactory$reference Chain reference PrevRel reference ToTable TableName$().newRec());
			}$reference Chain reference PrevRel reference ToTable iterate TableSubClasses( each implRamDeleteTableUpdatePrevWalkAllocBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-update-prev-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
			editPrev.set( prev );$reference Chain reference NextRel implRamDeleteTableUpdatePrevSetPrevNext$
			if( classCode == I$reference Chain reference PrevRel reference ToTable DefSchemaName$$reference Chain reference PrevRel reference ToTable TableName$.CLASS_CODE ) {
				schema.getTable$reference Chain reference PrevRel reference ToTable TableName$().update$reference Chain reference PrevRel reference ToTable TableName$( Authorization, editPrev );
			}$reference Chain reference PrevRel reference ToTable iterate TableSubClasses( each implRamDeleteTableUpdatePrevWalkUpdateBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-edit-prev-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
		}
</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableUpdatePrevSetPrevNext">
			editPrev.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamDeleteTableUpdatePrevSetPrevNext each implRamDeleteTableUpdatePrevCommaSetPrevNext )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevSetPrevNext">next$reference ToCol Name$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevCommaSetPrevNext">, $implRamDeleteTableUpdatePrevSetPrevNext$</GenRule>
	
	<GenRule GenDef="Table" Name="implRamDeleteTableUpdatePrevWalkUpdateBuff">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editPrev );
			}$iterate TableSubClasses( each implRamDeleteTableUpdatePrevWalkUpdateBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdatePrevWalkAllocBuff">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				editPrev = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getFactory$TableName$().newRec());
			}$iterate TableSubClasses( each implRamDeleteTableUpdatePrevWalkAllocBuff empty empty )$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevCheckNotNull"
		>( prev$reference ToCol Name$ != null )</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdatePrevCheckAndNotNull">
			&amp;&amp; $implRamDeleteTableUpdatePrevCheckNotNull$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamTableUpdatePrevPassCommaVar">,
				prev$reference ToCol Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdateNext">
		$reference Chain reference NextRel reference ToTable EffSchemaName$Buff$reference Chain reference NextRel reference ToTable TableName$ next = null;
		if( $reference Chain reference NextRel iterate Columns( first implRamDeleteTableUpdateNextCheckNotNull each implRamDeleteTableUpdateNextCheckAndNotNull )$ )
		{
			next = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getTable$reference Chain reference NextRel reference ToTable TableName$().readDerivedBy$reference Chain reference NextRel reference ToIndex Suffix$( Authorization$reference Chain reference NextRel iterate Columns( each implRamTableUpdateNextPassCommaVar )$ ));
			if( next == null ) {
				throw new CFLibNullArgumentException( getClass(),
					S_ProcName,
					0,
					"next" );
			}
			$reference Chain reference NextRel reference ToTable EffSchemaName$Buff$reference Chain reference NextRel reference ToTable TableName$ editNext;
			classCode = next.getClassCode();
			if( classCode == I$reference Chain reference NextRel reference ToTable DefSchemaName$$reference Chain reference NextRel reference ToTable Name$.CLASS_CODE ) {
				editNext = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getFactory$reference Chain reference NextRel reference ToTable TableName$().newRec());
			}$reference Chain reference NextRel reference ToTable iterate TableSubClasses( each implRamDeleteTableUpdateNextWalkAllocBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-update-next-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
			editNext.set( next );$reference Chain reference PrevRel implRamDeleteTableUpdateNextSetNextPrev$
			if( classCode == I$reference Chain reference NextRel reference ToTable DefSchemaName$$reference Chain reference NextRel reference ToTable Name$.CLASS_CODE ) {
				schema.getTable$reference Chain reference NextRel reference ToTable TableName$().update$reference Chain reference NextRel reference ToTable TableName$( Authorization, editNext );
			}$reference Chain reference NextRel reference ToTable iterate TableSubClasses( each implRamDeleteTableUpdateNextWalkUpdateBuff empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-edit-next-", (Integer)classCode, "Classcode not recognized: " + Integer.toString(classCode));
			}
		}
</GenRule>

	<GenRule GenDef="Relation" Name="implRamDeleteTableUpdateNextSetNextPrev">
			editNext.set$OptionalOrRequired$$RelationType$$Suffix$($iterate Columns( first implRamDeleteTableUpdateNextSetNextPrev each implRamDeleteTableUpdateNextCommaSetNextPrev )$);</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextSetNextPrev">prev$reference ToCol Name$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextCommaSetNextPrev">, $implRamDeleteTableUpdateNextSetNextPrev$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdateNextWalkUpdateBuff">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				schema.getTable$TableName$().update$TableName$( Authorization, ($EffSchemaName$Buff$TableName$)editNext );
			}$iterate TableSubClasses( each implRamDeleteTableUpdateNextWalkUpdateBuff empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableUpdateNextWalkAllocBuff">
			else if( classCode == I$DefSchemaName$$TableName$.CLASS_CODE ) {
				editNext = ($EffSchemaName$Buff$reference Chain reference Table TableName$)(schema.getFactory$TableName$().newRec());
			}$iterate TableSubClasses( each implRamDeleteTableUpdateNextWalkAllocBuff empty empty )$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextCheckNotNull"
		>( next$reference ToCol Name$ != null )</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableUpdateNextCheckAndNotNull">
			&amp;&amp; $implRamDeleteTableUpdateNextCheckNotNull$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamTableUpdateNextPassCommaVar">,
				next$reference ToCol Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableChainSelectChainLinks">
$reference Chain reference PrevRel iterate Columns( each implRamDeleteTableChainSelectPrevChainLink )$$reference Chain reference NextRel iterate Columns( each implRamDeleteTableChainSelectNextChainLink )$
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableChainSelectPrevChainLink">
		$reference FromCol implJavaAtomType$ prev$reference ToCol Name$ = existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$();</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableChainSelectNextChainLink">
		$reference FromCol implJavaAtomType$ next$reference ToCol Name$ = existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$();</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableFetchContainerKeys"
		>$reference ContainerRelation iterate Columns( each implRamDeleteTableFetchContainerKey )$</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableFetchContainerKey">
		$reference FromCol implJavaAtomType$ var$reference FromCol Name$ = existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$();</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableFetchContainer">
		$reference ContainerRelation reference ToTable EffSchemaName$Buff$reference ContainerRelation reference ToTable TableName$ container = ($reference ContainerRelation reference ToTable EffSchemaName$Buff$reference ContainerRelation reference ToTable TableName$)(schema.getTable$reference ContainerRelation reference ToTable TableName$().readDerivedBy$reference ContainerRelation reference ToIndex Suffix$( Authorization$reference ContainerRelation iterate Columns( each implRamDeleteTablePassCommaContainerVar )$ ));
		if( container == null ) {
			throw new CFLibNullArgumentException( getClass(),
				S_ProcName,
				0,
				"container" );
		}</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTablePassCommaContainerVar">,
			var$reference FromCol Name$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableInvokeSuper">
		schema.getTable$reference SuperClassRelation reference ToTable TableName$().delete$reference SuperClassRelation reference ToTable TableName$( Authorization,
			Buff );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableCommaPassBuffArg">,
			Buff.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableByInheritedIndexes"
		>$switch HasSuperClassRelation yes implRamDeleteTableByInhIndexes default implRamDeleteTableByBaseIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableByInhIndexes"
		>$iterate Index( each implRamDeleteTableByNonPrimaryIndex empty empty )$$reference SuperClassRelation reference ToTable implRamDeleteTableByInheritedIndexes$</GenRule>

	<GenRule GenDef="Table" Name="implRamDeleteTableByBaseIndexes"
		>$iterate Index( each implRamDeleteTableBySpecialIndex empty empty )$</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implRamDeleteTableByIndex$</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableBySpecialIndex"
		>$switch IsPrimaryIndex yes implRamDeleteTableByPrimaryIndex default implRamDeleteTableByIndex$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableByIndexCheckForNotNullColumn"
		>$switch IsNullable yes implRamDeleteTableByIndexCheckNullableColumn default implRamDeleteTableByIndexCheckRequiredColumn$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableByIndexCheckNullableColumn">
		if( argKey.get$OptionalOrRequired$$Name$() != null ) {
			anyNotNull = true;
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableByIndexCheckRequiredColumn">
		anyNotNull = true;</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByIndex">
	@Override
	public void delete$poptop Table TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each implNextIdGenDeclAttr )$ )
	{
		$DefSchemaName$Buff$TableName$By$Suffix$Key key = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();$iterate Columns( each implRamDeleteApplyArgToKey )$
		delete$poptop Table TableName$By$Suffix$( Authorization, key );
	}

	@Override
	public void delete$poptop Table TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization,
		I$DefSchemaName$$TableName$By$Suffix$Key argKey )
	{$switch implDeleteTableBySuffixNeedProcName yes implDeleteTableBySuffixImplProcName default empty$
		$popto Table DefSchemaName$Buff$poptop Table TableName$ cur;
		boolean anyNotNull = false;$iterate Columns( each implRamDeleteTableByIndexCheckForNotNullColumn )$
		if( ! anyNotNull ) {
			return;
		}
		LinkedList&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; matchSet = new LinkedList&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt;();
		Iterator&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; values = dictByPKey.values().iterator();
		while( values.hasNext() ) {
			cur = values.next();
			if( argKey.equals( cur ) ) {
				matchSet.add( cur );
			}
		}
		Iterator&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; iterMatch = matchSet.iterator();
		while( iterMatch.hasNext() ) {
			cur = iterMatch.next();
			cur = ($popto Table DefSchemaName$Buff$poptop Table TableName$)(schema.getTable$poptop Table TableName$().readDerivedBy$poptop Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableBySuffixPassCurPKeyArg )$ ));$poptop Table switch HasSubClasses yes implDeleteTableBySuffixClassWalker default implDeleteTableBySuffixDirect$
		}
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableBySuffixPassCurPKeyArg">,
				cur.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Index" Name="implDeleteTableBySuffixNeedProcName"
		>$poptop Table HasSubClasses$</GenRule>

	<GenRule GenDef="Index" Name="implDeleteTableBySuffixImplProcName">
		final String S_ProcName = "delete$poptop Table TableName$By$Suffix$";</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableBySuffixDirect">
			delete$TableName$( Authorization, cur );</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableBySuffixClassWalker">
			int subClassCode = cur.getClassCode();
			if( I$DefSchemaName$$TableName$.CLASS_CODE == subClassCode ) {
				schema.getTable$TableName$().delete$TableName$( Authorization, cur );
			}$iterate ReverseRelations( each implDeleteTableBySuffixClassWalker empty empty )$
			else {
				throw new CFLibUnsupportedClassException(getClass(), S_ProcName, "-delete-by-suffix-class-walker-", (Integer)subClassCode, "Classcode not recognized: " + Integer.toString(subClassCode));
			}</GenRule>

	<GenRule GenDef="Relation" Name="implDeleteTableBySuffixClassWalker"
		>$switch RelationTypeTag
			Superclass implDeleteTableBySuffixWalkClass
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implDeleteTableBySuffixWalkClass"
		>$reference FromTable implDeleteTableBySuffixWalkClass$</GenRule>

	<GenRule GenDef="Table" Name="implDeleteTableBySuffixWalkClass">
			else if( I$DefSchemaName$$TableName$.CLASS_CODE == subClassCode ) {
				schema.getTable$TableName$().delete$TableName$( Authorization, (I$DefSchemaName$$TableName$)cur );
			}$iterate ReverseRelations( each implDeleteTableBySuffixClassWalker empty empty )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteApplyArgToKey">
		key.set$OptionalOrRequired$$Name$( arg$Name$ );</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteCommaPassArgColumn">,
			argKey.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByPrimaryIndex">$switch IsPrimaryIndexKeyAtomic yes implRamDeleteTableByPrimaryAtomicIndex default implRamDeleteTableByPrimaryCompositeIndex$</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableByPrimaryAtomicIndex">
	@Override
	public void delete$poptop Table TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization,
		$poptop Table reference BaseClass ICompactedPrimaryIndexClass$ argKey )
	{$switch implDeleteTableBySuffixNeedProcName yes implDeleteTableBySuffixImplProcName default empty$
		boolean anyNotNull = false;$iterate Columns( each implRamDeleteTableByIndexCheckForNotNullColumn )$
		if( ! anyNotNull ) {
			return;
		}
		$popto Table DefSchemaName$Buff$poptop Table TableName$ cur;
		LinkedList&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; matchSet = new LinkedList&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt;();
		Iterator&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; values = dictByPKey.values().iterator();
		while( values.hasNext() ) {
			cur = values.next();
			if( argKey.equals( cur ) ) {
				matchSet.add( cur );
			}
		}
		Iterator&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; iterMatch = matchSet.iterator();
		while( iterMatch.hasNext() ) {
			cur = iterMatch.next();
			cur = ($popto Table DefSchemaName$Buff$poptop Table TableName$)(schema.getTable$poptop Table TableName$().readDerivedBy$poptop Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableBySuffixPassCurPKeyArg )$ ));$poptop Table switch HasSubClasses yes implDeleteTableBySuffixClassWalker default implDeleteTableBySuffixDirect$
		}
	}
</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableByPrimaryCompositeIndex">
	@Override
	public void delete$poptop Table TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization$iterate Columns( each declCommaColumnArg )$ )
	{
		$poptop Table BuffCompactedPrimaryIndexClass$ key = ($poptop Table BuffCompactedPrimaryIndexClass$)(schema.getFactory$poptop Table reference BaseClass TableName$().newPKey());$poptop Table iterate SuperiorPrimaryKeyRelations( each implRamReadTableKeySetSuperiorRelation empty empty )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetKeyAttr empty empty )$
		delete$poptop Table TableName$By$Suffix$( Authorization, key );
	}

	@Override
	public void delete$poptop Table TableName$By$Suffix$( I$SecSchemaName$Authorization Authorization,
		$poptop Table reference BaseClass ICompactedPrimaryIndexClass$ PKey )
	{$switch implDeleteTableBySuffixNeedProcName yes implDeleteTableBySuffixImplProcName default empty$
		$poptop Table BuffCompactedPrimaryIndexClass$ key = ($poptop Table BuffCompactedPrimaryIndexClass$)(schema.getFactory$poptop Table reference BaseClass TableName$().newPKey());$poptop Table iterate SuperiorPrimaryKeyRelations( each implRamReadTablePKeySetSuperiorRelation empty empty )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each maybeImplRamReadTableSetPKeyAttr empty empty )$
		$poptop Table BuffCompactedPrimaryIndexClass$ argKey = key;
		boolean anyNotNull = false;$iterate Columns( each implRamDeleteTableByIndexCheckForNotNullColumn )$
		if( ! anyNotNull ) {
			return;
		}
		$popto Table DefSchemaName$Buff$poptop Table TableName$ cur;
		LinkedList&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; matchSet = new LinkedList&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt;();
		Iterator&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; values = dictByPKey.values().iterator();
		while( values.hasNext() ) {
			cur = values.next();
			if( argKey.equals( cur ) ) {
				matchSet.add( cur );
			}
		}
		Iterator&lt;$popto Table DefSchemaName$Buff$poptop Table TableName$&gt; iterMatch = matchSet.iterator();
		while( iterMatch.hasNext() ) {
			cur = iterMatch.next();
			cur = ($popto Table DefSchemaName$Buff$poptop Table TableName$)(schema.getTable$poptop Table TableName$().readDerivedBy$poptop Table reference BaseClass reference PrimaryKeyIndex Suffix$( Authorization$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each implRamDeleteTableBySuffixPassCurPKeyArg )$ ));$poptop Table switch HasSubClasses yes implDeleteTableBySuffixClassWalker default implDeleteTableBySuffixDirect$
		}
	}
</GenRule>
	
	<GenRule GenDef="Relation" Name="implRamDeleteTableIntegrityCheck"
		>$switch RelationTypeTag
			Superclass implRamDeleteTableCheckSuperClassReference
			Lookup implRamDeleteTableCheckReference
			Master empty
			Container empty
			Owner empty
			default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckReference"
		>$switch IsRequired yes implRamDeleteTableCheckReqRef default empty$</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckSuperClassReference">
		if( schema.getTable$reference FromTable Name$().readDerivedBy$implRamToIndexSuffix$( Authorization$iterate Columns( each implRamDeleteTableCheckRefCommaPassArg )$ ) != null )
		{
			throw new CFLibDependentsDetectedException( getClass(),
				"delete$popto Table TableName$",
				"$RelationTypeTag$",
				"$RelationTypeTag$",
				"$Name$",
				"$Name$",
				"$reference FromTable Name$",
				"$reference FromTable Name$",
				pkey );
		}
</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckReqRef"
>$switch IsFromIndexUnique yes implRamDeleteTableCheckUniqueRef default implRamDeleteTableCheckDupRef$</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckUniqueRef">
		if( null != schema.getTable$reference FromTable Name$().readDerivedBy$implRamFromIndexSuffix$( Authorization$iterate Columns( each implRamDeleteTableCheckRefCommaPassArg )$ ) )
		{
			throw new CFLibDependentsDetectedException( getClass(),
				"delete$popto Table TableName$",
				"$RelationTypeTag$",
				"$RelationTypeTag$",
				"$Name$",
				"$Name$",
				"$reference FromTable Name$",
				"$reference FromTable Name$",
				pkey );
		}
</GenRule>
	<GenRule GenDef="Relation" Name="implRamDeleteTableCheckDupRef">
		if( schema.getTable$reference FromTable Name$().readDerivedBy$implRamFromIndexSuffix$( Authorization$iterate Columns( each implRamDeleteTableCheckRefCommaPassArg )$ ).length &gt; 0 )
		{
			throw new CFLibDependentsDetectedException( getClass(),
				"delete$popto Table TableName$",
				"$RelationTypeTag$",
				"$RelationTypeTag$",
				"$Name$",
				"$Name$",
				"$reference FromTable Name$",
				"$reference FromTable Name$",
				pkey );
		}
</GenRule>

	<GenRule GenDef="RelationCol" Name="implRamDeleteTableCheckRefCommaPassArg">,
					$implRamDeleteTableCheckRefPassArg$</GenRule>
	<GenRule GenDef="RelationCol" Name="implRamDeleteTableCheckRefPassArg"
		>existing.get$reference ToCol implColumnAttrOptionality$$reference ToCol Name$()</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamDeleteTableRemoveIndexEntry"
		>$switch IsPrimaryIndex yes empty default implRamDeleteTableRemoveIndexEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableRemoveIndexEntry"
		>$switch IsUnique yes implRamDeleteTableRemoveUniqueEntry default implRamDeleteTableRemoveDupEntry$</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableRemoveUniqueEntry">
		dictBy$Suffix$.remove( key$Suffix$ );
</GenRule>
	<GenRule GenDef="Index" Name="implRamDeleteTableRemoveDupEntry">
		subdict = dictBy$Suffix$.get( key$Suffix$ );
		subdict.remove( pkey );
</GenRule>

	<GenRule GenDef="Index" Name="maybeImplRamDeleteTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implRamDeleteTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implRamDeleteTableInitIndexKey">
		$DefSchemaName$Buff$TableName$By$Suffix$Key key$Suffix$ = ($DefSchemaName$Buff$TableName$By$Suffix$Key)schema.getFactory$TableName$().newBy$Suffix$Key();
$iterate Columns( each implRamDeleteTableInitExistingKeyAttr )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implRamDeleteTableInitExistingKeyAttr"
>		key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( existing.get$implColumnAttrOptionality$$Name$() );
</GenRule>

</RuleSet>
