<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	Mark's Code Fractal CFKBase 3.1 Code Fractal Knowledge Base
 *
 *	Copyright 2016-2025 Mark Stephen Sobkow
 *
 *	This file is part of Mark's Code Fractal CFKBase.
 *
 *	Mark's Code Fractal CFKBase is available under dual commercial license from
 *	Mark Stephen Sobkow, or under the terms of the GNU General Public License,
 *	Version 3 or later.
 *
 *	Mark's Code Fractal CFKBase is free software: you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	Mark's Code Fractal CFKBase is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Mark's Code Fractal CFKBase.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 *
 *	If you wish to modify and use this code without publishing your changes,
 *	or integrate it with proprietary code, please contact Mark Stephen Sobkow
 *	for a commercial license at mark.sobkow@gmail.com
 * -->
<RuleSet
	xmlns="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="java"
	Name="src/schemaobj/buff/SchemaBuffTableObj.java"
	Revision="3.0"
	Descr="Java buffer-focused Table Object implementation">

	<GenFile GenDef="Table" Name="fileBuffSchemaTableObjJava"
			GenerateOnce="false"
		ModuleName="$reference ManufacturingSchema lower JavaPackage$"
		SourceBundle="java"
		BasePackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$/src/main/java"
		SubPackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$obj.buff"
		ExpansionClassName="$SchemaName$Buff$TableName$TableObjJava"
		ExpansionKeyName="$SchemaName$Buff$TableName$TableObjJava"
		ExpansionFileName="$SchemaName$Buff$TableName$TableObj.java"
>// Description: Java buffer-focused Table Object implementation for $SchemaName$.

$MssSourceLicense$

package $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$obj.buff;

import java.math.*;
import java.sql.*;
import java.text.*;
import java.util.*;
import server.markhome.mcf.v3_1.cflib.*;
import server.markhome.mcf.v3_1.cflib.dbutil.*;
import org.apache.commons.text.StringEscapeUtils;$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaName empty empty )$
import $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaNameObj empty empty )$
import $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$obj.*;$importJavaPackageSchemaName$$JavaTableObjImport$
$implBuffSchemaTableObjClassBody$</GenFile>

<GenRule GenDef="Table" Name="implBuffSchemaTableObjClassBody">
public class $SchemaName$Buff$TableName$TableObj
	implements I$SchemaName$$TableName$TableObj
{
	protected I$poptop SchemaDef SchemaName$SchemaObj schema;
	private Map&lt;$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, I$DefSchemaName$$TableName$Obj&gt; members;
	private Map&lt;$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, I$DefSchemaName$$TableName$Obj&gt; all$TableName$;$declBuffTableObjIndexMapByIndexes$
	public static String TABLE_NAME = "$TableName$";
	public static String TABLE_DBNAME = "$lower DbTableName$";$JavaTableObjMembers$

	public $SchemaName$Buff$TableName$TableObj() {
		schema = null;
		members = new HashMap&lt;$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, I$DefSchemaName$$TableName$Obj&gt;();
		all$TableName$ = null;$initBuffTableObjIndexMapByIndexes$
	}

	public $SchemaName$Buff$TableName$TableObj( I$reference BaseClass DefSchemaName$SchemaObj argSchema ) {
		schema = (I$poptop SchemaDef SchemaName$SchemaObj)argSchema;
		members = new HashMap&lt;$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey, I$reference BaseClass DefSchemaName$$TableName$Obj&gt;();
		all$TableName$ = null;$initBuffTableObjIndexMapByIndexes$
	}
$implBuffSchemaTableObjMethods$$implBuffNewInstance$$implBuffNewEditInstance$$switch IsBaseTable yes implBuffConstructByClassCode default empty$$implBuffRealiseObj$$implBuffCreateObj$$implBuffReadObjByPKey$$implBuffReadCachedObjByPKey$$implBuffReallyDeepDisposeTable$$implBuffDeepDisposeObjByPKey$$implBuffLockObjByPKey$$implBuffReadAllObj$$implBuffReadCachedAllObj$$switch PageData yes implBuffTablePageAllObj default empty$$implBuffTableObjReadByIndexes$$implBuffTableObjReadCachedByIndexes$$implBuffTableObjDeepDisposeByIndexes$$switch PageData yes implBuffTableObjPageByIndex default empty$$implBuffUpdateObj$$implBuffDeleteObj$$implBuffTableObjDeleteByIndexes$$switch HasChain yes implBuffTableObjMoveUp default empty$$switch HasChain yes implBuffTableObjMoveDown default empty$$iterate ServerMethods( each implJavaBuffTableObjServerMethod empty empty )$$JavaTableObjImplementation$}</GenRule>

	<GenRule GenDef="Table" Name="implBuffTablePageAllObj">
	/**
	 *	Return a sorted map of a page of the $TableName$-derived instances in the database.
	 *
	 *	@return	List of I$DefSchemaName$$TableName$Obj instance, sorted by their primary keys, which
	 *		may include an empty set.
	 */
	public List&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt; pageAll$poptop Table TableName$($reference BaseClass reference PrimaryKeyIndex iterate Columns( first declOptPriorArg each declCommaOptPriorArg )$ )
	{
		final String S_ProcName = "pageAll$poptop Table TableName$";
		Map&lt;$DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$DefSchemaName$$TableName$Obj&gt; map = new HashMap&lt;$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey,I$DefSchemaName$$TableName$Obj&gt;();
		$DefSchemaName$$TableName$Buff[] buffList = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().pageAllBuff( schema.getAuthorization()$reference BaseClass reference PrimaryKeyIndex iterate Columns( each passCommaOptPriorArg )$ );
		$DefSchemaName$$TableName$Buff buff;
		I$DefSchemaName$$TableName$Obj obj;
		I$DefSchemaName$$TableName$Obj realised;
		ArrayList&lt;I$DefSchemaName$$TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$TableName$Obj&gt;( buffList.length );
		for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
			buff = buffList[ idx ];$switch HasClassCode yes implBuffReadAllObjConsObjByClassCode default implBuffReadAllObjConsObj$
			obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference BaseClass TableName$().newPKey() );
			obj.setBuff( buff );
			realised = (I$DefSchemaName$$TableName$Obj)obj.realise();
			arrayList.add( realised );
		}
		return( arrayList );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjPageByIndex"
		>$switch HasSuperClassRelation yes implBuffTableObjPageByInhIndex default implBuffTableObjPageByBaseIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjPageBySubIndex"
		>$switch HasSuperClassRelation yes implBuffTableObjPageByInhIndex default empty$$iterate Index( each implBuffTableObjPageByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjPageByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default ifdup_implBuffTableObjPageByIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjPageByInhIndex"
		>$reference SuperClassRelation reference ToTable implBuffTableObjPageBySubIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjPageByBaseIndex"
		>$iterate Index( each implBuffTableObjPageByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="ifdup_implBuffTableObjPageByIndex"
		>$switch IsUnique
			yes empty
			default implBuffTablePageObjByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTablePageObjByIndex"
		>$switch IsUnique yes empty default implBuffTablePageObjByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTablePageObjByDuplicateIndex">
	/**
	 *	Read a page of data as a List of $TableName$-derived instances sorted by their primary keys,
	 *	as identified by the duplicate $Suffix$ key attributes.$iterate Columns( each implCommentKeyAttr empty empty )$
	 *
	 *	@return	A List of $TableName$-derived instances sorted by their primary keys,
	 *		as identified by the key attributes, which may be an empty set.
	 */
	public List&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt; page$TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each declCommaOptPriorArg )$ )
	{
		final String S_ProcName = "page$poptop Table TableName$By$Suffix$";
		$DefSchemaName$$TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadObjByDuplicateIndexAssignKey )$$implBuffTableObjPageByIndexCalcList$
		return( retList );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjPageByThisDuplicateIndexReturnSortedList">
		int len = dict.size();
		I$DefSchemaName$$poptop Table TableName$Obj arr[] = new I$DefSchemaName$$poptop Table TableName$Obj[len];
		Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = dict.values().iterator();
		int idx = 0;
		while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
			arr[idx++] = valIter.next();
		}
		if( idx &lt; len ) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"idx",
				idx,
				len );
		}
		else if( valIter.hasNext() ) {
			throw new CFLibArgumentOverflowException( getClass(),
					S_ProcName,
					0,
					"idx",
					idx,
					len );
		}
		ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;(len);
		for( idx = 0; idx &lt; len; idx ++ ) {
			arrayList.add( arr[idx] );
		}
$implBuffReadAllObjComparator$
		Collections.sort( arrayList, cmp );
		List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; sortedList = arrayList;
		return( sortedList );</GenRule>

	<GenRule GenDef="ServerProc" Name="implJavaBuffTableObjServerMethod"
		>$switch IsInstanceMethod yes implJavaBuffTableObjInstServerProc default implJavaBuffTableObjClassServerProc$</GenRule>

	<GenRule GenDef="ServerProc" Name="implJavaBuffTableObjClassServerProc">
	public boolean $leadlower Name$($iterate Params( first declServerMethodParamNoComma each declServerMethodParam empty empty )$ )
	{
		boolean retval = ((I$poptop SchemaDef SchemaName$$TableName$Table)((I$poptop SchemaDef SchemaName$Schema)(schema.getBackingStore())).getTable$TableName$()).$leadlower Name$( ((I$poptop SchemaDef SchemaName$SchemaObj)schema)$iterate Params( each passServerMethodParam empty empty )$ );
		return( retval );
	}
</GenRule>

	<GenRule GenDef="ServerProc" Name="implJavaBuffTableObjInstServerProc">
	public boolean $leadlower Name$( I$DefSchemaName$$TableName$Obj obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
		boolean retval = ((I$poptop SchemaDef SchemaName$$TableName$Table)((I$poptop SchemaDef SchemaName$Schema)(schema.getBackingStore())).getTable$TableName$()).$leadlower Name$( ((I$poptop SchemaDef SchemaName$SchemaObj)schema),
			obj$iterate Params( each passServerMethodParam empty empty )$ );
		return( retval );
	}
</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implJavaBuffTableObjServerMethod"
		>$switch IsInstanceMethod yes implJavaBuffTableObjInstServerObjFunc default implJavaBuffTableObjClassServerObjFunc$</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implJavaBuffTableObjClassServerObjFunc">
	public I$reference RetTable DefSchemaName$$reference RetTable Name$Obj $leadlower Name$($iterate Params( first declServerMethodParamNoComma each declServerMethodParam empty empty )$ )
	{
		I$reference RetTable DefSchemaName$$reference RetTable Name$Obj retobj = null;
		$reference RetTable DefSchemaName$$reference RetTable Name$Buff readBuff = ((I$poptop SchemaDef SchemaName$$TableName$Table)((I$poptop SchemaDef SchemaName$Schema)(schema.getBackingStore())).getTable$TableName$()).$leadlower Name$( ((I$poptop SchemaDef SchemaName$SchemaObj)schema)$iterate Params( each passServerMethodParam empty empty )$ );
		if( readBuff != null ) {$reference RetTable switch HasClassCode yes implJavaBuffTableObjServerMethodConsObjByClassCode default implJavaBuffTableObjServerMethodConsObj$
			retobj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference RetTable reference BaseClass TableName$().newPKey() );
			retobj.setBuff( readBuff );
			retobj = (I$DefSchemaName$$reference RetTable TableName$Obj)retobj.realise();
		}
		return( retobj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implJavaBuffTableObjServerMethodConsObjByClassCode">
			retobj = (I$popto ServerMethod reference RetTable DefSchemaName$$popto ServerMethod reference RetTable TableName$Obj)((I$SchemaName$SchemaObj)schema).get$reference BaseClass TableName$TableObj().constructByClassCode( readBuff.getClassCode() );</GenRule>

	<GenRule GenDef="Table" Name="implJavaBuffTableObjServerMethodConsObj">
			retobj = (I$popto ServerMethod reference RetTable DefSchemaName$$popto ServerMethod reference RetTable TableName$Obj)((I$SchemaName$SchemaObj)schema).get$TableName$TableObj().newInstance();</GenRule>

	<GenRule GenDef="ServerObjFunc" Name="implJavaBuffTableObjInstServerObjFunc">
	public I$reference RetTable DefSchemaName$$reference RetTable Name$Obj $leadlower Name$( I$DefSchemaName$$TableName$Obj obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
		I$DefSchemaName$$reference RetTable Name$Obj retobj = null;
		$DefSchemaName$$reference RetTable Name$Buff readBuff = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().$leadlower Name$( schema,
			obj$iterate Params( each passServerMethodParam empty empty )$ );
		if( readBuff != null ) {$reference RetTable switch HasClassCode yes implJavaBuffTableObjServerMethodConsObjByClassCode default implJavaBuffTableObjServerMethodConsObj$
			retobj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference RetTable reference BaseClass TableName$().newPKey() );
			retobj.setBuff( readBuff );
			retobj = (I$DefSchemaName$$reference RetTable TableName$Obj)retobj.realise();
		}
		return( retobj );
	}
</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implJavaBuffTableObjServerMethod"
		>$switch IsInstanceMethod yes implJavaBuffTableObjInstServerListFunc default implJavaBuffTableObjClassServerListFunc$</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implJavaBuffTableObjClassServerListFunc">
	public List&lt;I$reference RetTable DefSchemaName$$reference RetTable Name$Obj&gt; $leadlower Name$($iterate Params( first declServerMethodParamNoComma each declServerMethodParam empty empty )$ )
	{
		LinkedList&lt;I$reference RetTable DefSchemaName$$reference RetTable Name$Obj&gt; list = new LinkedList&lt;I$reference RetTable DefSchemaName$$reference RetTable Name$Obj&gt;();
		I$reference RetTable DefSchemaName$$reference RetTable Name$Obj retobj = null;
		$reference RetTable DefSchemaName$$reference RetTable Name$Buff readBuff;
		$reference RetTable DefSchemaName$$reference RetTable Name$Buff readArray[] = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().$leadlower Name$( schema$iterate Params( each passServerMethodParam empty empty )$ );
		if( readArray == null ) {
			return( list );
		}
		int sz = readArray.length;
		for( int i = 0; i &lt; sz; i ++ ) {
			readBuff = readArray[i];$reference RetTable switch HasClassCode yes implJavaBuffTableObjServerMethodConsObjByClassCode default implJavaBuffTableObjServerMethodConsObj$
			retobj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference RetTable reference BaseClass TableName$().newPKey() );
			retobj.setBuff( readBuff );
			retobj = (I$DefSchemaName$$reference RetTable TableName$Obj)retobj.realise();
			list.add( retobj );
		}
		return( list );
	}
</GenRule>

	<GenRule GenDef="ServerListFunc" Name="implJavaBuffTableObjInstServerListFunc">
	public List&lt;I$reference RetTable DefSchemaName$$reference RetTable Name$Obj&gt; $leadlower Name$( I$DefSchemaName$$TableName$Obj obj$iterate Params( each declServerMethodParam empty empty )$ )
	{
		LinkedList&lt;I$reference RetTable DefSchemaName$$reference RetTable Name$Obj&gt; list = new LinkedList&lt;I$reference RetTable DefSchemaName$$reference RetTable Name$Obj&gt;();
		I$reference RetTable DefSchemaName$$reference RetTable Name$Obj retobj = null;
		$reference RetTable DefSchemaName$$reference RetTable Name$Buff readBuff;
		$reference RetTable DefSchemaName$$reference RetTable Name$Buff readArray[] = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().$leadlower Name$( schema,
			obj$iterate Params( each passServerMethodParam empty empty )$ );
		if( readArray == null ) {
			return( list );
		}
		int sz = readArray.length;
		for( int i = 0; i &lt; sz; i ++ ) {
			readBuff = readArray[i];$reference RetTable switch HasClassCode yes implJavaBuffTableObjServerMethodConsObjByClassCode default implJavaBuffTableObjServerMethodConsObj$
			retobj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference RetTable reference BaseClass TableName$().newPKey() );
			retobj.setBuff( readBuff );
			retobj = (I$reference RetTable DefSchemaName$$reference RetTable TableName$Obj)retobj.realise();
			list.add( retobj );
		}
		return( list );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implGetBuffTableObjQualifyingClass">

	public Class getObjQualifyingClass() {
		return( $switch HasQualTable yes implGetBuffTableObjQualifyingClassQualTableXFace default implGetBuffTableObjQualifyingClassNull$ );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implGetBuffTableObjQualifyingClassQualTableXFace"
		>I$SchemaName$$reference QualTable Name$Obj.class</GenRule>

	<GenRule GenDef="Table" Name="implGetBuffTableObjQualifyingClassNull"
		>null</GenRule>

	<GenRule GenDef="Table" Name="implBuffSchemaTableObjMethods">
	public I$reference BaseClass DefSchemaName$SchemaObj getSchema() {
		return( schema );
	}

	public void setSchema( I$reference BaseClass DefSchemaName$SchemaObj value ) {
		schema = (I$poptop SchemaDef SchemaName$SchemaObj)value;
	}

	public String getTableName() {
		return( TABLE_NAME );
	}

	public String getTableDbName() {
		return( TABLE_DBNAME );
	}$implGetBuffTableObjQualifyingClass$

	public void minimizeMemory() {$implBuffTableMinimizeMemoryResetByIndexes$$implBuffTableMinimizeMemoryForgetCached$
	}</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableMinimizeMemoryForgetCached">
		List&lt;I$DefSchemaName$$TableName$Obj&gt; toForget = new LinkedList&lt;I$DefSchemaName$$TableName$Obj&gt;();
		I$DefSchemaName$$TableName$Obj cur = null;
		Iterator&lt;I$DefSchemaName$$TableName$Obj&gt; iter = members.values().iterator();
		while( iter.hasNext() ) {
			cur = iter.next();
			toForget.add( cur );
		}
		iter = toForget.iterator();
		while( iter.hasNext() ) {
			cur = iter.next();
			cur.forget();
		}</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableMinimizeMemoryResetByIndexes">
		all$TableName$ = null;$switch HasSuperClassRelation yes implBuffTableMinimizeMemoryResetByInhIndexes default empty$$iterate Index( each implBuffTableMinimizeMemoryResetByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableMinimizeMemoryResetBySubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableMinimizeMemoryResetByInhIndexes default empty$$iterate Index( each implBuffTableMinimizeMemoryResetByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableMinimizeMemoryResetByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableMinimizeMemoryResetByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableMinimizeMemoryResetByInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableMinimizeMemoryResetBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByThisIndex"
		>$switch IsUnique
			yes implBuffTableMinimizeMemoryResetByThisUniqueIndex
			default implBuffTableMinimizeMemoryResetByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByInhIndex"
		>$switch IsUnique
			yes implBuffTableMinimizeMemoryResetByInhUniqueIndex
			default implBuffTableMinimizeMemoryResetByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByIndex"
		>$switch IsUnique
			yes implBuffTableMinimizeMemoryResetByUniqueIndex
			default implBuffTableMinimizeMemoryResetByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByThisUniqueIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByInhUniqueIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByThisDuplicateIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableMinimizeMemoryResetByInhDuplicateIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Table" Name="declBuffTableObjIndexMapByIndexes"
		>$switch HasSuperClassRelation yes declBuffTableObjIndexMapByInhIndexes default empty$$iterate Index( each declBuffTableObjIndexMapByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="declBuffTableObjIndexMapBySubIndexes"
		>$switch HasSuperClassRelation yes declBuffTableObjIndexMapByInhIndexes default empty$$iterate Index( each declBuffTableObjIndexMapByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default declBuffTableObjIndexMapByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default declBuffTableObjIndexMapByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="declBuffTableObjIndexMapByInhIndexes"
		>$reference SuperClassRelation reference ToTable declBuffTableObjIndexMapBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByThisIndex"
		>$switch IsUnique
			yes declBuffTableObjIndexMapByThisUniqueIndex
			default declBuffTableObjIndexMapByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByInhIndex"
		>$switch IsUnique
			yes declBuffTableObjIndexMapByInhUniqueIndex
			default declBuffTableObjIndexMapByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByIndex"
		>$switch IsUnique
			yes declBuffTableObjIndexMapByUniqueIndex
			default declBuffTableObjIndexMapByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByThisUniqueIndex">
	private Map&lt; $reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key,
		I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; indexBy$Suffix$;</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByInhUniqueIndex">
	private Map&lt; $reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key,
		I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; indexBy$Suffix$;</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByThisDuplicateIndex">
	private Map&lt; $reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key,
		Map&lt;$poptop Table DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; &gt; indexBy$Suffix$;</GenRule>

	<GenRule GenDef="Index" Name="declBuffTableObjIndexMapByInhDuplicateIndex">
	private Map&lt; $reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key,
		Map&lt;$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; &gt; indexBy$Suffix$;</GenRule>

	<GenRule GenDef="Table" Name="initBuffTableObjIndexMapByIndexes"
		>$switch HasSuperClassRelation yes initBuffTableObjIndexMapByInhIndexes default empty$$iterate Index( each initBuffTableObjIndexMapByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="initBuffTableObjIndexMapBySubIndexes"
		>$switch HasSuperClassRelation yes initBuffTableObjIndexMapByInhIndexes default empty$$iterate Index( each initBuffTableObjIndexMapByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default initBuffTableObjIndexMapByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default initBuffTableObjIndexMapByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="initBuffTableObjIndexMapByInhIndexes"
		>$reference SuperClassRelation reference ToTable initBuffTableObjIndexMapBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByThisIndex"
		>$switch IsUnique
			yes initBuffTableObjIndexMapByThisUniqueIndex
			default initBuffTableObjIndexMapByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByInhIndex"
		>$switch IsUnique
			yes initBuffTableObjIndexMapByInhUniqueIndex
			default initBuffTableObjIndexMapByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByIndex"
		>$switch IsUnique
			yes initBuffTableObjIndexMapByUniqueIndex
			default initBuffTableObjIndexMapByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByThisUniqueIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByInhUniqueIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByThisDuplicateIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Index" Name="initBuffTableObjIndexMapByInhDuplicateIndex">
		indexBy$Suffix$ = null;</GenRule>

	<GenRule GenDef="Table" Name="implBuffNewInstance">
	/**
	 *	If your implementation subclasses the objects,
	 *	you'll want to overload the constructByClassCode()
	 *	implementation to return your implementation's
	 *	instances instead of the base implementation.
	 *
	 *	This is the sole factory for instances derived from
	 *	$SchemaName$$TableName$Obj.
	 */
	public I$DefSchemaName$$TableName$Obj newInstance() {
		I$DefSchemaName$$TableName$Obj inst = new $SchemaName$$TableName$Obj( schema );
		return( inst );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffNewEditInstance">
	/**
	 *	If your implementation subclasses the objects,
	 *	you'll want to overload the constructByClassCode()
	 *	implementation to return your implementation's
	 *	instances instead of the base implementation.
	 *
	 *	This is the sole factory for instances derived from
	 *	$SchemaName$$TableName$Obj.
	 */
	public I$DefSchemaName$$TableName$EditObj newEditInstance( I$DefSchemaName$$TableName$Obj orig ) {
		I$DefSchemaName$$TableName$EditObj edit = new $SchemaName$$TableName$EditObj( orig );
		return( edit );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffConstructByClassCode">
	public I$DefSchemaName$$TableName$Obj constructByClassCode( String argClassCode ) {
		I$DefSchemaName$$TableName$Obj obj = null;
		if( argClassCode.equals( "$ClassCode$" ) ) {
			obj = ((I$SchemaName$SchemaObj)schema).get$TableName$TableObj().newInstance();
		}
$switch HasSubClasses yes implBuffConstructByClassCodeIterSubClasses default empty
$		return( obj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffConstructByClassCodeIterSubClasses"
		>$iterate TableSubClasses( each implBuffConstructByClassCodeConstructAndIterate empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffConstructByClassCodeConstructAndIterate"
>		else if( argClassCode.equals( "$ClassCode$" ) ) {
			obj = ((I$SchemaName$SchemaObj)schema).get$TableName$TableObj().newInstance();
		}
$switch HasSubClasses yes implBuffConstructByClassCodeIterSubClasses default empty$</GenRule>

	<GenRule GenDef="Table" Name="implBuffRealiseObjReplaceBuff">
			keepObj.setBuff( Obj.getBuff() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffRealiseObj">
	public I$DefSchemaName$$TableName$Obj realise$TableName$( I$DefSchemaName$$TableName$Obj Obj ) {
		I$DefSchemaName$$TableName$Obj obj = Obj;
		$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey pkey = obj.getPKey();
		I$DefSchemaName$$TableName$Obj keepObj = null;
		if( members.containsKey( pkey ) &amp;&amp; ( null != members.get( pkey ) ) ) {
			I$DefSchemaName$$TableName$Obj existingObj = members.get( pkey );
			keepObj = existingObj;

			/*
			 *	We always rebind the data because if we're being called, some index has
			 *	been updated and is refreshing it's data, which may or may not have changed
			 */

			// Detach object from alternate and duplicate indexes, leave PKey alone
$implBuffTableObjIndexDetachFromIndexes$$switch HasSuperClassRelation yes implBuffRealiseObjInvokeBase default implBuffRealiseObjReplaceBuff$
			// Attach new object to alternate and duplicate indexes -- PKey stay stable
$implBuffTableObjIndexAddToIndexes$
			if( all$TableName$ != null ) {
				all$TableName$.put( keepObj.getPKey(), keepObj );
			}
		}
		else {
			keepObj = obj;
$switch HasSuperClassRelation yes implBuffRealiseObjNewInvokeBase default empty$$switch HasSuperClassRelation no implBuffRealiseObjSetIsNewFalse default empty$
			// Attach new object to PKey, all, alternate, and duplicate indexes
			members.put( keepObj.getPKey(), keepObj );
			if( all$TableName$ != null ) {
				all$TableName$.put( keepObj.getPKey(), keepObj );
			}
$implBuffTableObjIndexAddToIndexes$
		}
		return( keepObj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjIndexDetachFromIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjIndexDetachFromInhIndexes default empty$$iterate Index( each implBuffTableObjIndexDetachFromThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjIndexDetachFromSubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjIndexDetachFromInhIndexes default empty$$iterate Index( each implBuffTableObjIndexDetachFromInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjIndexDetachFromThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjIndexDetachFromInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjIndexDetachFromInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableObjIndexDetachFromSubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromThisIndex"
		>$switch IsUnique
			yes implBuffTableObjIndexDetachFromThisUniqueIndex
			default implBuffTableObjIndexDetachFromThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromInhIndex"
		>$switch IsUnique
			yes implBuffTableObjIndexDetachFromInhUniqueIndex
			default implBuffTableObjIndexDetachFromInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromIndex"
		>$switch IsUnique
			yes implBuffTableObjIndexDetachFromUniqueIndex
			default implBuffTableObjIndexDetachFromDuplicateIndex$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffTableObjIndexCopyKeepObjToKey">
				key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( keepObj.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromThisUniqueIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				indexBy$Suffix$.remove( key$Suffix$ );
			}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromInhUniqueIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				indexBy$Suffix$.remove( key$Suffix$ );
			}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromThisDuplicateIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				Map&lt;$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj &gt; map$Suffix$ = indexBy$Suffix$.get( key$Suffix$ );
				if( map$Suffix$ != null ) {
					map$Suffix$.remove( keepObj.getPKey() );
					if( map$Suffix$.size() &lt;= 0 ) {
						indexBy$Suffix$.remove( key$Suffix$ );
					}
				}
			}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexDetachFromInhDuplicateIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				Map&lt;$poptop Table DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; map$Suffix$ = indexBy$Suffix$.get( key$Suffix$ );
				if( map$Suffix$ != null ) {
					indexBy$Suffix$.remove( key$Suffix$ );
				}
			}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjIndexAddToIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjIndexAddToInhIndexes default empty$$iterate Index( each implBuffTableObjIndexAddToThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjIndexAddToSubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjIndexAddToInhIndexes default empty$$iterate Index( each implBuffTableObjIndexAddToInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjIndexAddToThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjIndexAddToInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjIndexAddToInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableObjIndexAddToSubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToThisIndex"
		>$switch IsUnique
			yes implBuffTableObjIndexAddToThisUniqueIndex
			default implBuffTableObjIndexAddToThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToInhIndex"
		>$switch IsUnique
			yes implBuffTableObjIndexAddToInhUniqueIndex
			default implBuffTableObjIndexAddToInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToIndex"
		>$switch IsUnique
			yes implBuffTableObjIndexAddToUniqueIndex
			default implBuffTableObjIndexAddToDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToThisUniqueIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				indexBy$Suffix$.put( key$Suffix$, keepObj );
			}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToInhUniqueIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				indexBy$Suffix$.put( key$Suffix$, keepObj );
			}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToThisDuplicateIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				Map&lt;$poptop Table DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; map$Suffix$ = indexBy$Suffix$.get( key$Suffix$ );
				if( map$Suffix$ != null ) {
					map$Suffix$.put( keepObj.getPKey(), keepObj );
				}
			}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjIndexAddToInhDuplicateIndex">
			if( indexBy$Suffix$ != null ) {
				$reference Table DefSchemaName$$reference Table TableName$By$Suffix$Key key$Suffix$ =
					((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffTableObjIndexCopyKeepObjToKey empty empty )$
				Map&lt;$poptop Table DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$poptop Table DefSchemaName$$poptop Table TableName$Obj &gt; map$Suffix$ = indexBy$Suffix$.get( key$Suffix$ );
				if( map$Suffix$ != null ) {
					map$Suffix$.put( keepObj.getPKey(), keepObj );
				}
			}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffRealiseObjSetIsNewFalse"
>			keepObj.setIsNew( false );
</GenRule>

	<GenRule GenDef="Table" Name="implBuffRealiseObjInvokeBase"
>			// Keep passing the new object because it's the one with the buffer
			// that the base table needs to copy to the existing object from
			// the cache.
			keepObj = (I$DefSchemaName$$TableName$Obj)schema.get$reference SuperClassRelation reference ToTable TableName$TableObj().realise$reference SuperClassRelation reference ToTable TableName$( Obj );
</GenRule>

	<GenRule GenDef="Table" Name="implBuffRealiseObjNewInvokeBase"
>			keepObj = (I$DefSchemaName$$TableName$Obj)schema.get$reference SuperClassRelation reference ToTable TableName$TableObj().realise$reference SuperClassRelation reference ToTable TableName$( keepObj );
</GenRule>

	<GenRule GenDef="Table" Name="implBuffCreateObj">
	public I$DefSchemaName$$TableName$Obj create$TableName$( I$DefSchemaName$$TableName$Obj Obj ) {<!--$switch HasSuperClassRelation yes implBuffCreateObjInvokeSuper default implBuffCreateObjAssignObj$-->$implBuffCreateObjAssignObj$
		$DefSchemaName$$TableName$Buff buff = obj.get$TableName$Buff();
		((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().create$TableName$(
			schema.getAuthorization(),
			buff );$implBuffCreateObjCopyBuffToPKey$$switch HasClassCode no implBuffCreateObjRealise default implBuffCreateObjRealiseIfMatches$$switch HasChain yes implBuffCreateObjRefreshChainPrev default empty$
		obj.endEdit();
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffCreateObjRefreshChainPrev">
		I$DefSchemaName$$reference Chain reference Table TableName$Obj prev = obj.get$reference Chain reference PrevRel OptionalOrRequired$$reference Chain reference PrevRel RelationTypeTag$$reference Chain reference PrevRel Suffix$();
		if( prev != null ) {
			prev.read( true );
		}</GenRule>

	<GenRule GenDef="Table" Name="implBuffCreateObjCopyClassCodeToPKey">
		pkey.setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffCreateObjCopyPKeyAttr">
		pkey.set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffCreateObjRealiseIfMatches">
		if( obj.getPKey().getClassCode().equals( "$ClassCode$" ) ) {
			obj = (I$DefSchemaName$$TableName$Obj)(obj.realise());
		}</GenRule>

	<GenRule GenDef="Table" Name="implBuffCreateObjRealise">
		obj = obj.realise();</GenRule>

	<GenRule GenDef="Table" Name="invokeBuffSuperCreateTable">
		// The base class assigns any generated ids
		schema.get$reference SuperClassRelation reference ToTable TableName$TableObj().create$reference SuperClassRelation reference ToTable TableName$( obj );</GenRule>

	<GenRule GenDef="TableCol" Name="implBuffCopyDataColumnFromObj"
		>$switch ColumnInPrimaryIndex
			yes empty
			default implBuffCopyColumnFromObj$</GenRule>
	<GenRule GenDef="Atom" Name="implBuffCopyDataColumnFromObj"
		>$switch ColumnInPrimaryIndex
			yes empty
			default implBuffCopyColumnFromObj$</GenRule>
	<GenRule GenDef="IndexCol" Name="implBuffCopyDataColumnFromObj"
		>$reference Column implBuffCopyDataColumnFromObj$</GenRule>

	<GenRule GenDef="TableCol" Name="implBuffCopyColumnFromObj">
					data.set$implColumnAttrOptionality$$Name$( obj.get$implColumnAttrOptionality$$Name$() );</GenRule>
	<GenRule GenDef="Atom" Name="implBuffCopyColumnFromObj">
					data.set$implColumnAttrOptionality$$Name$( obj.get$implColumnAttrOptionality$$Name$() );</GenRule>
	<GenRule GenDef="IndexCol" Name="implBuffCopyColumnFromObj"
		>$reference Column implBuffCopyColumnFromObj$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffCopyPKeyColumnFromObj"
		>$reference Column implBuffCopyPKeyColumnFromObj$</GenRule>

	<GenRule GenDef="Atom" Name="implBuffCopyPKeyColumnFromObj">
					pkey.set$implColumnAttrOptionality$$Name$( obj.get$implColumnAttrOptionality$$Name$() );</GenRule>
	<GenRule GenDef="TableCol" Name="implBuffCopyPKeyColumnFromObj">
					pkey.set$implColumnAttrOptionality$$Name$( obj.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadAllObj">
	public List&lt;I$DefSchemaName$$TableName$Obj&gt; readAll$TableName$() {
		return( readAll$TableName$( false ) );
	}

	public List&lt;I$DefSchemaName$$TableName$Obj&gt; readAll$TableName$( boolean forceRead ) {
		final String S_ProcName = "readAll$TableName$";
		if( ( all$TableName$ == null ) || forceRead ) {
			Map&lt;$DefSchemaName$$poptop Table reference BaseClass TableName$PKey, I$DefSchemaName$$TableName$Obj&gt; map = new HashMap&lt;$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey,I$DefSchemaName$$TableName$Obj&gt;();
			all$TableName$ = map;
			$DefSchemaName$$TableName$Buff[] buffList = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().readAllDerived( schema.getAuthorization() );
			$DefSchemaName$$TableName$Buff buff;
			I$DefSchemaName$$TableName$Obj obj;
			for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
				buff = buffList[ idx ];$switch HasClassCode yes implBuffReadAllObjConsObjByClassCode default implBuffReadAllObjConsObj$
				obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference BaseClass TableName$().newPKey() );
				obj.setBuff( buff );
				I$DefSchemaName$$TableName$Obj realised = (I$DefSchemaName$$TableName$Obj)obj.realise();
			}
		}$implBuffReadAllReturnSortedArray$
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadAllObjComparator"
		>$poptop Table implBuffReadAllObjComparator$</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadAllObjComparator">
		Comparator&lt;I$DefSchemaName$$TableName$Obj&gt; cmp = new Comparator&lt;I$DefSchemaName$$TableName$Obj&gt;() {
			public int compare( I$DefSchemaName$$TableName$Obj lhs, I$DefSchemaName$$TableName$Obj rhs ) {
				if( lhs == null ) {
					if( rhs == null ) {
						return( 0 );
					}
					else {
						return( -1 );
					}
				}
				else if( rhs == null ) {
					return( 1 );
				}
				else {
					$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey lhsPKey = lhs.getPKey();
					$reference BaseClass DefSchemaName$$reference BaseClass TableName$PKey rhsPKey = rhs.getPKey();
					int ret = lhsPKey.compareTo( rhsPKey );
					return( ret );
				}
			}
		};</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadAllReturnSortedArray">
		int len = all$TableName$.size();
		I$DefSchemaName$$TableName$Obj arr[] = new I$DefSchemaName$$TableName$Obj[len];
		Iterator&lt;I$DefSchemaName$$TableName$Obj&gt; valIter = all$TableName$.values().iterator();
		int idx = 0;
		while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
			arr[idx++] = valIter.next();
		}
		if( idx &lt; len ) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"idx",
				idx,
				len );
		}
		else if( valIter.hasNext() ) {
			throw new CFLibArgumentOverflowException( getClass(),
					S_ProcName,
					0,
					"idx",
					idx,
					len );
		}
		ArrayList&lt;I$DefSchemaName$$TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$TableName$Obj&gt;(len);
		for( idx = 0; idx &lt; len; idx ++ ) {
			arrayList.add( arr[idx] );
		}
$implBuffReadAllObjComparator$
		Collections.sort( arrayList, cmp );
		List&lt;I$DefSchemaName$$TableName$Obj&gt; sortedList = arrayList;
		return( sortedList );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadAllObjConsObjByClassCode">
				obj = (I$DefSchemaName$$TableName$Obj)schema.get$reference BaseClass TableName$TableObj().constructByClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadAllObjConsObj">
				obj = newInstance();</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadAllObjCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadAllObjCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadObjByPKey">
	public I$DefSchemaName$$TableName$Obj read$TableName$( $DefSchemaName$$reference BaseClass TableName$PKey pkey ) {
		return( read$TableName$( pkey, false ) );
	}

	public I$DefSchemaName$$TableName$Obj read$TableName$( $DefSchemaName$$reference BaseClass TableName$PKey pkey, boolean forceRead ) {
		I$DefSchemaName$$TableName$Obj obj = null;
		if( ( ! forceRead ) &amp;&amp; members.containsKey( pkey ) ) {
			obj = members.get( pkey );
		}
		else {
			$DefSchemaName$$TableName$Buff readBuff = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().readDerivedBy$reference BaseClass reference PrimaryKeyIndex Suffix$( schema.getAuthorization()$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implBuffReadObjByPKeyCommaPassArg empty empty )$ );
			if( readBuff != null ) {$switch HasClassCode yes implBuffReadObjByPKeyConsObjByClassCode default implBuffReadObjByPKeyConsObj$
				obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference BaseClass TableName$().newPKey() );
				obj.setBuff( readBuff );
				obj = (I$DefSchemaName$$TableName$Obj)obj.realise();
			}
		}
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffLockObjByPKey">
	public I$DefSchemaName$$TableName$Obj lock$TableName$( $DefSchemaName$$reference BaseClass TableName$PKey pkey ) {
		I$DefSchemaName$$TableName$Obj locked = null;
		$DefSchemaName$$TableName$Buff lockBuff = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().lockDerived( schema.getAuthorization(), pkey );
		if( lockBuff != null ) {$switch HasClassCode yes implBuffLockObjByPKeyConsLockedByClassCode default implBuffLockObjByPKeyConsLocked$
			locked.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference BaseClass TableName$().newPKey() );
			locked.setBuff( lockBuff );
			locked = (I$DefSchemaName$$TableName$Obj)locked.realise();
		}
		else {
			throw new CFLibCollisionDetectedException( getClass(), "lock$TableName$", pkey );
		}
		return( locked );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadObjByPKeyCopyPKeyClassCode">
				obj.getPKey().setClassCode( readBuff.getClassCode() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadObjByPKeyConsObjByClassCode">
				obj = (I$DefSchemaName$$TableName$Obj)schema.get$reference BaseClass TableName$TableObj().constructByClassCode( readBuff.getClassCode() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadObjByPKeyConsObj">
				obj = schema.get$TableName$TableObj().newInstance();</GenRule>

	<GenRule GenDef="Table" Name="implBuffLockObjByPKeyConsLockedByClassCode">
				locked = (I$DefSchemaName$$TableName$Obj)schema.get$reference BaseClass TableName$TableObj().constructByClassCode( lockBuff.getClassCode() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffLockObjByPKeyConsLocked">
				locked = schema.get$TableName$TableObj().newInstance();</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByPKeyCommaPassArg">,
				pkey.get$implColumnAttrOptionality$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByPKeyCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( readBuff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByIndex"
		>$switch IsUnique
			yes implBuffReadObjByUniqueIndex
			default implBuffReadObjByDuplicateIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadByIndexes"
		>$implBuffTableObjReadByPrimaryIndex$$switch HasSuperClassRelation yes implBuffTableObjReadByInhIndexes default empty$$iterate Index( each implBuffTableObjReadByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadByPrimaryIndex"
		>$reference BaseClass reference PrimaryKeyIndex implBuffTableObjReadByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadBySubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjReadByInhIndexes default empty$$iterate Index( each implBuffTableObjReadByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjReadByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjReadByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadByInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableObjReadBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByThisIndex"
		>$switch IsUnique
			yes implBuffTableObjReadByThisUniqueIndex
			default implBuffTableObjReadByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByInhIndex"
		>$switch IsUnique
			yes implBuffTableObjReadByInhUniqueIndex
			default implBuffTableObjReadByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByIndex"
		>$switch IsUnique
			yes implBuffTableObjReadByUniqueIndex
			default implBuffTableObjReadByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByThisUniqueIndex">
	public I$DefSchemaName$$poptop Table TableName$Obj read$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		return( read$poptop Table TableName$By$Suffix$( $iterate Columns( first passAlongColumnArg each passAlongCommaColumnArg )$,
			false ) );
	}

	public I$DefSchemaName$$poptop Table TableName$Obj read$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$, boolean forceRead )
	{$switch IsPrimaryIndex yes implBuffTableObjReadByUniqueIndexPKey default implBuffTableObjReadByUniqueAltIndex$
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByUniqueIndexPKey">
		$reference Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey pkey = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$poptop Table reference BaseClass TableName$().newPKey();$iterate Columns( each implBuffReadObjByUniqueIndexCopyArgToPKey )$
		I$DefSchemaName$$poptop Table TableName$Obj obj = read$poptop Table TableName$( pkey, forceRead );</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByUniqueAltIndex">
		if( indexBy$Suffix$ == null ) {
			indexBy$Suffix$ = new HashMap&lt; $DefSchemaName$$reference Table TableName$By$Suffix$Key,
				I$DefSchemaName$$poptop Table TableName$Obj &gt;();
		}
		$DefSchemaName$$reference Table TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadObjByDuplicateIndexAssignKey )$
		I$DefSchemaName$$poptop Table TableName$Obj obj = null;
		if( ( ! forceRead ) &amp;&amp; indexBy$Suffix$.containsKey( key ) ) {
			obj = indexBy$Suffix$.get( key );
		}
		else {
			$DefSchemaName$$TableName$Buff buff = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().readDerivedBy$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
			if( buff != null ) {$switch HasClassCode yes implBuffReadObjByAltIdxConsObjByClassCode default implBuffReadObjByAltIdxConsObj$
				obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table reference BaseClass TableName$().newPKey() );
				obj.setBuff( buff );
				obj = (I$DefSchemaName$$poptop Table TableName$Obj)obj.realise();
			}
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByInhUniqueIndex"
		>$implBuffTableObjReadByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByThisDuplicateIndex">
	public List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; read$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		return( read$poptop Table TableName$By$Suffix$( $iterate Columns( first passAlongColumnArg each passAlongCommaColumnArg )$,
			false ) );
	}

	public List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; read$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$,
		boolean forceRead )
	{
		final String S_ProcName = "read$poptop Table TableName$By$Suffix$";
		$DefSchemaName$$TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadObjByDuplicateIndexAssignKey )$
		Map&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj&gt; dict;
		if( indexBy$Suffix$ == null ) {
			indexBy$Suffix$ = new HashMap&lt; $DefSchemaName$$reference Table TableName$By$Suffix$Key,
				Map&lt; $DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj &gt; &gt;();
		}$implBuffTableObjReadByInhDupIndexCalcDict$$implBuffTableObjReadByThisDuplicateIndexReturnSortedList$
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByThisDuplicateIndexComparator">
		Comparator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; cmp = new Comparator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;() {
			public int compare( I$DefSchemaName$$poptop Table TableName$Obj lhs, I$DefSchemaName$$poptop Table TableName$Obj rhs ) {
				if( lhs == null ) {
					if( rhs == null ) {
						return( 0 );
					}
					else {
						return( -1 );
					}
				}
				else if( rhs == null ) {
					return( 1 );
				}
				else {
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey lhsPKey = lhs.getPKey();
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey rhsPKey = rhs.getPKey();
					int ret = lhsPKey.compareTo( rhsPKey );
					return( ret );
				}
			}
		};</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByThisDuplicateIndexReturnSortedList">
		int len = dict.size();
		I$DefSchemaName$$poptop Table TableName$Obj arr[] = new I$DefSchemaName$$poptop Table TableName$Obj[len];
		Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = dict.values().iterator();
		int idx = 0;
		while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
			arr[idx++] = valIter.next();
		}
		if( idx &lt; len ) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"idx",
				idx,
				len );
		}
		else if( valIter.hasNext() ) {
			throw new CFLibArgumentOverflowException( getClass(),
					S_ProcName,
					0,
					"idx",
					idx,
					len );
		}
		ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;(len);
		for( idx = 0; idx &lt; len; idx ++ ) {
			arrayList.add( arr[idx] );
		}
$implBuffReadAllObjComparator$
		Collections.sort( arrayList, cmp );
		List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; sortedList = arrayList;
		return( sortedList );</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByInhDupIndexCalcDict">
		if( ( ! forceRead ) &amp;&amp; indexBy$Suffix$.containsKey( key ) ) {
			dict = indexBy$Suffix$.get( key );
		}
		else {
			dict = new HashMap&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj&gt;();
			I$DefSchemaName$$TableName$Obj obj;
			$DefSchemaName$$TableName$Buff[] buffList = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().readDerivedBy$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
			$DefSchemaName$$TableName$Buff buff;
			for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
				buff = buffList[ idx ];$switch HasClassCode yes implBuffReadObjByDupIdxConsObjByClassCode default implBuffReadObjByDupIdxConsObj$
				obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table reference BaseClass TableName$().newPKey() );
				obj.setBuff( buff );
				I$DefSchemaName$$poptop Table TableName$Obj realised = (I$DefSchemaName$$poptop Table TableName$Obj)obj.realise();
				dict.put( realised.getPKey(), realised );
			}
			indexBy$Suffix$.put( key, dict );
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjPageByIndexCalcList">
		List&lt;I$DefSchemaName$$TableName$Obj&gt; retList = new LinkedList&lt;I$DefSchemaName$$TableName$Obj&gt;();
		I$DefSchemaName$$TableName$Obj obj;
		$DefSchemaName$$TableName$Buff[] buffList = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().pageBuffBy$declReadTableSuffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$$poptop Table reference BaseClass reference PrimaryKeyIndex iterate Columns( each passCommaOptPriorArg )$ );
		$DefSchemaName$$TableName$Buff buff;
		for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
			buff = buffList[ idx ];$switch HasClassCode yes implBuffReadObjByDupIdxConsObjByClassCode default implBuffReadObjByDupIdxConsObj$
			obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table reference BaseClass TableName$().newPKey() );
			obj.setBuff( buff );
			I$DefSchemaName$$poptop Table TableName$Obj realised = (I$DefSchemaName$$poptop Table TableName$Obj)obj.realise();
			retList.add( realised );
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadByInhDuplicateIndex"
		>$implBuffTableObjReadByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByUniqueIndexPKey">
		$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey pkey = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table reference BaseClass TableName$().newPKey();$iterate Columns( each implBuffReadObjByUniqueIndexCopyArgToPKey )$
		I$DefSchemaName$$TableName$Obj obj = read$TableName$( pkey );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByUniqueIndexCopyArgToPKey">
		pkey.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByAltIdxCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByAltIdxConsObjByClassCode">
				obj = (I$DefSchemaName$$poptop Table TableName$Obj)schema.get$reference Table reference BaseClass TableName$TableObj().constructByClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByAltIdxConsObj">
				obj = schema.get$TableName$TableObj().newInstance();</GenRule>


	<GenRule GenDef="IndexCol" Name="implBuffReadObjByAltIdxCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByUniqueIndexCopyBuffToPKey">
				pkey.set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByUniqueIndexCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByIndexPassArg"
		>$Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByIndexCommaPassArg">,
				$implBuffReadObjByIndexPassArg$</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDuplicateIndex">
	public List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; read$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		return( read$poptop Table TableName$By$Suffix$( $iterate Columns( first passAlongColumnArg each passAlongCommaColumnArg )$,
			false ) );
	}

	public List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; read$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$,
		boolean forceRead )
	{
		final String S_ProcName = "read$poptop Table TableName$By$Suffix$";
		$DefSchemaName$$poptop Table TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$poptop Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadObjByDuplicateIndexAssignKey )$
		Map&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,I$DefSchemaName$$poptop Table TableName$Obj&gt; dict;
$implBuffReadObjByDuplicateIndexPart1$
$implBuffReadObjByDuplicateIndexComparator$$implBuffReadObjByDuplicateIndexReturnSortedList$
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDuplicateIndexComparator">
		Comparator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; cmp = new Comparator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;() {
			public int compare( I$DefSchemaName$$poptop Table TableName$Obj lhs, I$DefSchemaName$$poptop Table TableName$Obj rhs ) {
				if( lhs == null ) {
					if( rhs == null ) {
						return( 0 );
					}
					else {
						return( -1 );
					}
				}
				else if( rhs == null ) {
					return( 1 );
				}
				else {
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey lhsPKey = lhs.getPKey();
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey rhsPKey = rhs.getPKey();
					int ret = lhsPKey.compareTo( rhsPKey );
					return( ret );
				}
			}
		};</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDuplicateIndexReturnSortedList">
		int len = dict.size();
		I$DefSchemaName$$poptop Table TableName$Obj arr[] = new I$DefSchemaName$$poptop Table TableName$Obj[len];
		Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = dict.values().iterator();
		int idx = 0;
		while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
			arr[idx++] = valIter.next();
		}
		if( idx &lt; len ) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"idx",
				idx,
				len );
		}
		else if( valIter.hasNext() ) {
			throw new CFLibArgumentOverflowException( getClass(),
					S_ProcName,
					0,
					"idx",
					idx,
					len );
		}
		ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;(len);
		for( idx = 0; idx &lt; len; idx ++ ) {
			arrayList.add( arr[idx] );
		}
$implBuffReadAllObjComparator$
		Collections.sort( arrayList, cmp );
		List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; sortedList = arrayList;
		return( sortedList );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDuplicateIndexPart1"
>		if( indexBy$Suffix$ == null ) {
			indexBy$Suffix$ = new HashMap&lt; $DefSchemaName$$reference Table TableName$By$Suffix$Key,
				Map&lt; $DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj &gt; &gt;();
		}
		if( ( ! forceRead ) &amp;&amp; indexBy$Suffix$.containsKey( key ) ) {
			dict = indexBy$Suffix$.get( key );
		}
		else {
			dict = new HashMap&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,I$DefSchemaName$$TableName$Obj&gt;();
			// Allow other threads to dirty-read while we're loading
			indexBy$Suffix$.put( key, dict );
			I$DefSchemaName$$TableName$Obj obj;
			$DefSchemaName$$TableName$Buff[] buffList = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().readDerivedBy$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
			$DefSchemaName$$TableName$Buff buff;
			for( int idx = 0; idx &lt; buffList.length; idx ++ ) {
				buff = buffList[ idx ];$switch HasClassCode yes implBuffReadObjByDupIdxConsObjByClassCode default implBuffReadObjByDupIdxConsObj$
				obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table reference BaseClass TableName$().newPKey() );
				obj.setBuff( buff );
				I$DefSchemaName$$TableName$Obj realised = (I$DefSchemaName$$TableName$Obj)obj.realise();
			}
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByDupIdxCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadObjByDuplicateIndexAssignKey">
		key.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDupIdxCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDupIdxConsObjByClassCode">
				obj = (I$DefSchemaName$$poptop Table TableName$Obj)schema.get$reference Table reference BaseClass TableName$TableObj().constructByClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadObjByDupIdxConsObj">
				obj = schema.get$TableName$TableObj().newInstance();</GenRule>

	<GenRule GenDef="Table" Name="implBuffUpdateObjInvokeSuper">
		I$DefSchemaName$$TableName$Obj obj = (I$DefSchemaName$$TableName$Obj)schema.get$reference SuperClassRelation reference ToTable TableName$TableObj().update$reference SuperClassRelation reference ToTable TableName$( Obj );</GenRule>

	<GenRule GenDef="Table" Name="implBuffUpdateObjInitObj">
		I$DefSchemaName$$TableName$Obj obj = Obj;</GenRule>


	<GenRule GenDef="Table" Name="implBuffTableObjMoveUp">
	/**
	 *	Move the $DefSchemaName$$TableName$Obj instance up in the chain.  The instance is always refreshed.
	 *
	 *	@return	$DefSchemaName$$TableName$Obj refreshed cache instance.
	 */
	public I$DefSchemaName$$TableName$Obj moveUp$TableName$( I$DefSchemaName$$TableName$Obj Obj ) {
		I$DefSchemaName$$TableName$Obj obj = null;
		if( null != Obj.getEdit() ) {
			throw new CFLibUsageException( getClass(),
				"moveUp$TableName$",
				"You cannot move an object that is being edited" );
		}
		$DefSchemaName$$TableName$Buff buff = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().moveBuffUp( schema.getAuthorization()$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implBuffMoveBuffPassCommaPKeyArg )$,
			Obj.getBuff().getRequiredRevision() );
		if( buff != null ) {
			obj = schema.get$TableName$TableObj().newInstance();
			obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference BaseClass TableName$().newPKey() );
			obj.setBuff( buff );
			obj = (I$DefSchemaName$$TableName$Obj)obj.realise();
			I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Obj prev = obj.get$reference Chain reference PrevRel OptionalOrRequired$$reference Chain reference PrevRel RelationTypeTag$$reference Chain reference PrevRel Suffix$( true );
			I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Obj next = obj.get$reference Chain reference NextRel OptionalOrRequired$$reference Chain reference NextRel RelationTypeTag$$reference Chain reference NextRel Suffix$( true );
			if( next != null ) {
				I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Obj gnext = next.get$reference Chain reference NextRel OptionalOrRequired$$reference Chain reference NextRel RelationTypeTag$$reference Chain reference NextRel Suffix$( true );
			}
		}
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjMoveDown">
	/**
	 *	Move the $DefSchemaName$$TableName$Obj instance down in the chain.  The instance is always refreshed.
	 *
	 *	@return	$DefSchemaName$$TableName$Obj refreshed cache instance.
	 */
	public I$DefSchemaName$$TableName$Obj moveDown$TableName$( I$DefSchemaName$$TableName$Obj Obj ) {
		I$DefSchemaName$$TableName$Obj obj = null;
		if( null != Obj.getEdit() ) {
			throw new CFLibUsageException( getClass(),
				"moveDown$TableName$",
				"You cannot move an object that is being edited" );
		}
		$DefSchemaName$$TableName$Buff buff = ((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().moveBuffDown( schema.getAuthorization()$reference BaseClass reference PrimaryKeyIndex iterate Columns( each implBuffMoveBuffPassCommaPKeyArg )$,
			Obj.getBuff().getRequiredRevision() );
		if( buff != null ) {
			obj = schema.get$TableName$TableObj().newInstance();
			obj.setPKey( ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference BaseClass TableName$().newPKey() );
			obj.setBuff( buff );
			obj = (I$DefSchemaName$$TableName$Obj)obj.realise();
			I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Obj prev = obj.get$reference Chain reference PrevRel OptionalOrRequired$$reference Chain reference PrevRel RelationTypeTag$$reference Chain reference PrevRel Suffix$( true );
			if( prev != null ) {
				I$reference Chain reference Table DefSchemaName$$reference Chain reference Table TableName$Obj gprev = prev.get$reference Chain reference PrevRel OptionalOrRequired$$reference Chain reference PrevRel RelationTypeTag$$reference Chain reference PrevRel Suffix$( true );
			}
			I$DefSchemaName$$reference Chain reference Table TableName$Obj next = obj.get$reference Chain reference NextRel OptionalOrRequired$$reference Chain reference NextRel RelationTypeTag$$reference Chain reference NextRel Suffix$( true );
		}
		return( obj );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffMoveBuffPassCommaPKeyArg">,
			Obj.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="Table" Name="implBuffUpdateObj">
	public I$DefSchemaName$$TableName$Obj update$TableName$( I$DefSchemaName$$TableName$Obj Obj ) {<!--$switch HasSuperClassRelation yes implBuffUpdateObjInvokeSuper default implBuffUpdateObjInitObj$-->$implBuffUpdateObjInitObj$
		((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().update$TableName$( schema.getAuthorization(),
			Obj.get$TableName$Buff() );$switch HasClassCode no implBuffUpdateObjAlwaysRealise default implBuffUpdateObjMaybeRealise$
		obj.endEdit();
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffUpdateObjAlwaysRealise">
		obj = (I$DefSchemaName$$TableName$Obj)Obj.realise();</GenRule>

	<GenRule GenDef="Table" Name="implBuffUpdateObjMaybeRealise">
		if( Obj.getClassCode().equals( "$ClassCode$" ) ) {
			obj = (I$DefSchemaName$$TableName$Obj)Obj.realise();
		}</GenRule>

	<GenRule GenDef="Table" Name="implBuffDeleteObjInvokeSuper">
		schema.get$reference SuperClassRelation reference ToTable TableName$TableObj().delete$reference SuperClassRelation reference ToTable TableName$( Obj );</GenRule>

	<GenRule GenDef="Table" Name="implBuffDeleteObj">
	public void delete$TableName$( I$DefSchemaName$$TableName$Obj Obj ) {
		I$DefSchemaName$$TableName$Obj obj = Obj;$switch HasChain yes implBuffDeleteObjChainGetPrevNext default empty$
		((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().delete$TableName$( schema.getAuthorization(),
			obj.get$TableName$Buff() );<!--$switch HasSuperClassRelation yes implBuffDeleteObjInvokeSuper default empty$ -->
		Obj.forget();$switch HasChain yes implBuffDeleteObjChainRefreshPrevNext default empty$
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffDeleteObjChainGetPrevNext">
		I$DefSchemaName$$reference Chain reference Table TableName$Obj prev = obj.get$reference Chain reference PrevRel OptionalOrRequired$$reference Chain reference PrevRel RelationTypeTag$$reference Chain reference PrevRel Suffix$();
		I$DefSchemaName$$reference Chain reference Table TableName$Obj next = obj.get$reference Chain reference NextRel OptionalOrRequired$$reference Chain reference NextRel RelationTypeTag$$reference Chain reference NextRel Suffix$();</GenRule>

	<GenRule GenDef="Table" Name="implBuffDeleteObjChainRefreshPrevNext">
		if( prev != null ) {
			prev.read( true );
		}
		if( next != null ) {
			next.read( true );
		}</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeleteByIndexes"
		>$implBuffTableObjDeleteByPrimaryIndex$$switch HasSuperClassRelation yes implBuffTableObjDeleteByInhIndexes default empty$$iterate Index( each implBuffTableObjDeleteByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeleteByPrimaryIndex"
		>$reference BaseClass reference PrimaryKeyIndex implBuffTableObjDeleteByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeleteBySubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjDeleteByInhIndexes default empty$$iterate Index( each implBuffTableObjDeleteByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjDeleteByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjDeleteByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeleteByInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableObjDeleteBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByThisIndex"
		>$switch IsUnique
			yes implBuffTableObjDeleteByThisUniqueIndex
			default implBuffTableObjDeleteByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByInhIndex"
		>$switch IsUnique
			yes implBuffTableObjDeleteByInhUniqueIndex
			default implBuffTableObjDeleteByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByIndex"
		>$switch IsUnique
			yes implBuffTableObjDeleteByUniqueIndex
			default implBuffTableObjDeleteByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByThisUniqueIndex">
	public void delete$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{$switch IsPrimaryIndex yes implBuffTableObjDeleteByUniqueIndexPKey default implBuffTableObjDeleteByUniqueAltIndex$
		deepDispose$poptop Table TableName$By$Suffix$( $iterate Columns( first implBuffReadObjByIndexPassArg each implBuffReadObjByIndexCommaPassArg )$ );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByUniqueIndexPKey">
		$reference Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey pkey = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$poptop Table reference BaseClass TableName$().newPKey();$iterate Columns( each implBuffReadObjByUniqueIndexCopyArgToPKey )$
		I$poptop Table DefSchemaName$$poptop Table TableName$Obj obj = read$poptop Table TableName$( pkey );
		if( obj != null ) {
			I$poptop Table DefSchemaName$$poptop Table TableName$EditObj editObj = (I$poptop Table DefSchemaName$$poptop Table TableName$EditObj)obj.getEdit();
			boolean editStarted;
			if( editObj == null ) {
				editObj = (I$poptop Table DefSchemaName$$poptop Table TableName$EditObj)obj.beginEdit();
				if( editObj != null ) {
					editStarted = true;
				}
				else {
					editStarted = false;
				}
			}
			else {
				editStarted = false;
			}
			if( editObj != null ) {
				editObj.deleteInstance();
				if( editStarted ) {
					editObj.endEdit();
				}
			}
			obj.forget();
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByUniqueAltIndex">
		if( indexBy$Suffix$ == null ) {
			indexBy$Suffix$ = new HashMap&lt; $DefSchemaName$$reference Table TableName$By$Suffix$Key,
				I$DefSchemaName$$poptop Table TableName$Obj &gt;();
		}
		$DefSchemaName$$reference Table TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadObjByDuplicateIndexAssignKey )$
		I$DefSchemaName$$poptop Table TableName$Obj obj = null;
		if( indexBy$Suffix$.containsKey( key ) ) {
			obj = indexBy$Suffix$.get( key );
			((I$SchemaName$Schema)schema.getBackingStore()).getTable$poptop Table TableName$().delete$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
			obj.forget();
		}
		else {
			((I$SchemaName$Schema)schema.getBackingStore()).getTable$poptop Table TableName$().delete$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByInhUniqueIndex"
		>$implBuffTableObjDeleteByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByThisDuplicateIndex">
	public void delete$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		$DefSchemaName$$reference Table TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadObjByDuplicateIndexAssignKey )$
		if( indexBy$Suffix$ == null ) {
			indexBy$Suffix$ = new HashMap&lt; $DefSchemaName$$reference Table TableName$By$Suffix$Key,
				Map&lt; $DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj &gt; &gt;();
		}$implBuffTableObjDeleteByInhUniqueIndexCalcDict$
		deepDispose$poptop Table TableName$By$Suffix$( $iterate Columns( first implBuffReadObjByIndexPassArg each implBuffReadObjByIndexCommaPassArg )$ );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByInhUniqueIndexCalcDict">
		if( indexBy$Suffix$.containsKey( key ) ) {
			Map&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj&gt; dict = indexBy$Suffix$.get( key );
			((I$SchemaName$Schema)schema.getBackingStore()).getTable$poptop Table TableName$().delete$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; iter = dict.values().iterator();
			I$DefSchemaName$$poptop Table TableName$Obj obj;
			List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; toForget = new LinkedList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;();
			while( iter.hasNext() ) {
				obj = iter.next();
				toForget.add( obj );
			}
			iter = toForget.iterator();
			while( iter.hasNext() ) {
				obj = iter.next();
				obj.forget();
			}
			indexBy$Suffix$.remove( key );
		}
		else {
			((I$SchemaName$Schema)schema.getBackingStore()).getTable$poptop Table TableName$().delete$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeleteByInhDuplicateIndex"
		>$implBuffTableObjDeleteByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffDeleteObjByUniqueIndexPKey">
		$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey pkey = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table reference BaseClass TableName$().newPKey();$iterate Columns( each implBuffDeleteObjByUniqueIndexCopyArgToPKey )$
		I$DefSchemaName$$poptop Table TableName$Obj obj = read$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffReadObjByIndexCommaPassArg empty empty )$ );
		if( obj != null ) {
			I$poptop Table DefSchemaName$$poptop Table TableName$EditObj editObj = (I$poptop Table DefSchemaName$$poptop Table TableName$EditObj)obj.getEdit();
			boolean editStarted;
			if( editObj == null ) {
				editObj = (I$poptop Table DefSchemaName$$poptop Table TableName$EditObj)obj.beginEdit();
				if( editObj != null ) {
					editStarted = true;
				}
				else {
					editStarted = false;
				}
			}
			else {
				editStarted = false;
			}
			if( editObj != null ) {
				editObj.deleteInstance();
				if( editStarted ) {
					editObj.endEdit();
				}
			}
			obj.forget();
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeleteObjByIndexPassArg"
		>$Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeleteObjByIndexCommaPassArg">,
				$implBuffDeleteObjByIndexPassArg$</GenRule>

	<GenRule GenDef="Index" Name="implBuffDeleteObjByDuplicateIndex">
	public void delete$TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		$DefSchemaName$$TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$TableName$().new$Suffix$Key();$iterate Columns( each implBuffDeleteObjByDuplicateIndexAssignKey )$
$implBuffDeleteObjByDuplicateIndexPart1$
		deepDispose$poptop Table TableName$By$Suffix$( $iterate Columns( first implBuffReadObjByIndexPassArg each implBuffReadObjByIndexCommaPassArg )$ );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffDeleteObjByDuplicateIndexPart1"
>		if( indexBy$Suffix$ == null ) {
			indexBy$Suffix$ = new HashMap&lt; $DefSchemaName$$reference Table TableName$By$Suffix$Key,
				Map&lt; $DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj &gt; &gt;();
		}
		if( indexBy$Suffix$.containsKey( key ) ) {
			Map&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,I$DefSchemaName$$TableName$Obj&gt; dict = indexBy$Suffix$.get( key );
			((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().delete$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffDeleteObjByIndexCommaPassArg empty empty )$ );
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; iter = dict.values().iterator();
			while( iter.hasNext() ) {
				I$DefSchemaName$$poptop Table TableName$Obj obj = iter.next();
				obj.forget();
			}
			indexBy$Suffix$.remove( key );
		}
		else {
			((I$SchemaName$Schema)schema.getBackingStore()).getTable$TableName$().delete$poptop Table TableName$By$Suffix$( schema.getAuthorization()$iterate Columns( each implBuffDeleteObjByIndexCommaPassArg empty empty )$ );
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeleteObjByDupIdxCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeleteObjByDuplicateIndexAssignKey">
		key.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadCachedAllObj">
	public List&lt;I$DefSchemaName$$TableName$Obj&gt; readCachedAll$TableName$() {
		final String S_ProcName = "readCachedAll$TableName$";
		ArrayList&lt;I$DefSchemaName$$TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$TableName$Obj&gt;();
		if( all$TableName$ != null ) {
			int len = all$TableName$.size();
			I$DefSchemaName$$TableName$Obj arr[] = new I$DefSchemaName$$TableName$Obj[len];
			Iterator&lt;I$DefSchemaName$$TableName$Obj&gt; valIter = all$TableName$.values().iterator();
			int idx = 0;
			while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
				arr[idx++] = valIter.next();
			}
			if( idx &lt; len ) {
				throw new CFLibArgumentUnderflowException( getClass(),
					S_ProcName,
					0,
					"idx",
					idx,
					len );
			}
			else if( valIter.hasNext() ) {
				throw new CFLibArgumentOverflowException( getClass(),
						S_ProcName,
						0,
						"idx",
						idx,
						len );
			}
			for( idx = 0; idx &lt; len; idx ++ ) {
				arrayList.add( arr[idx] );
			}
		}
		Comparator&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt; cmp = new Comparator&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt;() {
			public int compare( I$poptop Table DefSchemaName$$poptop Table TableName$Obj lhs, I$poptop Table DefSchemaName$$poptop Table TableName$Obj rhs ) {
				if( lhs == null ) {
					if( rhs == null ) {
						return( 0 );
					}
					else {
						return( -1 );
					}
				}
				else if( rhs == null ) {
					return( 1 );
				}
				else {
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey lhsPKey = lhs.getPKey();
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey rhsPKey = rhs.getPKey();
					int ret = lhsPKey.compareTo( rhsPKey );
					return( ret );
				}
			}
		};
		Collections.sort( arrayList, cmp );
		return( arrayList );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadCachedAllObjCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedAllObjCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadCachedObjByPKey">
	public I$DefSchemaName$$TableName$Obj readCached$TableName$( $DefSchemaName$$reference BaseClass TableName$PKey pkey ) {
		I$DefSchemaName$$TableName$Obj obj = null;
		if( members.containsKey( pkey ) ) {
			obj = members.get( pkey );
		}
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffReadCachedObjByPKeyCopyPKeyClassCode">
				obj.getPKey().setClassCode( readCachedBuff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByPKeyCommaPassArg">,
				pkey.get$implColumnAttrOptionality$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByPKeyCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( readCachedBuff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadCachedObjByIndex"
		>$switch IsUnique
			yes implBuffReadCachedObjByUniqueIndex
			default implBuffReadCachedObjByDuplicateIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadCachedByIndexes"
		>$implBuffTableObjReadCachedByPrimaryIndex$$switch HasSuperClassRelation yes implBuffTableObjReadCachedByInhIndexes default empty$$iterate Index( each implBuffTableObjReadCachedByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadCachedByPrimaryIndex"
		>$reference BaseClass reference PrimaryKeyIndex implBuffTableObjReadCachedByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadCachedBySubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjReadCachedByInhIndexes default empty$$iterate Index( each implBuffTableObjReadCachedByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjReadCachedByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjReadCachedByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjReadCachedByInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableObjReadCachedBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByThisIndex"
		>$switch IsUnique
			yes implBuffTableObjReadCachedByThisUniqueIndex
			default implBuffTableObjReadCachedByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByInhIndex"
		>$switch IsUnique
			yes implBuffTableObjReadCachedByInhUniqueIndex
			default implBuffTableObjReadCachedByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByIndex"
		>$switch IsUnique
			yes implBuffTableObjReadCachedByUniqueIndex
			default implBuffTableObjReadCachedByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByThisUniqueIndex">
	public I$DefSchemaName$$poptop Table TableName$Obj readCached$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		I$DefSchemaName$$poptop Table TableName$Obj obj = null;$switch IsPrimaryIndex yes implBuffTableObjReadCachedByUniqueIndexPKey default implBuffTableObjReadCachedByUniqueAltIndex$
		return( obj );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByUniqueIndexPKey">
		$reference Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey pkey = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$poptop Table reference BaseClass TableName$().newPKey();$iterate Columns( each implBuffReadCachedObjByUniqueIndexCopyArgToPKey )$
		obj = readCached$poptop Table TableName$( pkey );</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByUniqueAltIndex">
		$DefSchemaName$$reference Table TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$reference Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadCachedObjByDuplicateIndexAssignKey )$
		if( indexBy$Suffix$ != null ) {
			if( indexBy$Suffix$.containsKey( key ) ) {
				obj = indexBy$Suffix$.get( key );
			}
			else {
				Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = members.values().iterator();
				while( ( obj == null ) &amp;&amp; valIter.hasNext() ) {
					obj = valIter.next();
					if( obj != null ) {
						if( obj.getBuff().compareTo( key ) != 0 ) {
							obj = null;
						}
					}
				}
			}
		}
		else {
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = members.values().iterator();
			while( valIter.hasNext() ) {
				obj = valIter.next();
				if( obj != null ) {
					if( obj.getBuff().compareTo( key ) != 0 ) {
						obj = null;
					}
				}
			}
		}</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByInhUniqueIndex"
		>$implBuffTableObjReadCachedByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByThisDuplicateIndex">
	public List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; readCached$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		final String S_ProcName = "readCached$poptop Table TableName$By$Suffix$";
		$DefSchemaName$$TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadCachedObjByDuplicateIndexAssignKey )$
		ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;();
		if( indexBy$Suffix$ != null ) {
			Map&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey, I$DefSchemaName$$poptop Table TableName$Obj&gt; dict;
			if( indexBy$Suffix$.containsKey( key ) ) {
				dict = indexBy$Suffix$.get( key );
				int len = dict.size();
				I$DefSchemaName$$poptop Table TableName$Obj arr[] = new I$DefSchemaName$$poptop Table TableName$Obj[len];
				Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = dict.values().iterator();
				int idx = 0;
				while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
					arr[idx++] = valIter.next();
				}
				if( idx &lt; len ) {
					throw new CFLibArgumentUnderflowException( getClass(),
						S_ProcName,
						0,
						"idx",
						idx,
						len );
				}
				else if( valIter.hasNext() ) {
					throw new CFLibArgumentOverflowException( getClass(),
							S_ProcName,
							0,
							"idx",
							idx,
							len );
				}
				for( idx = 0; idx &lt; len; idx ++ ) {
					arrayList.add( arr[idx] );
				}
			}
		}
		else {
			I$DefSchemaName$$poptop Table TableName$Obj obj;
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = members.values().iterator();
			while( valIter.hasNext() ) {
				obj = valIter.next();
				if( obj != null ) {
					if( obj.getBuff().compareTo( key ) == 0 ) {
						arrayList.add( obj );
					}
				}
			}
		}
		Comparator&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt; cmp = new Comparator&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt;() {
			public int compare( I$poptop Table DefSchemaName$$poptop Table TableName$Obj lhs, I$poptop Table DefSchemaName$$poptop Table TableName$Obj rhs ) {
				if( lhs == null ) {
					if( rhs == null ) {
						return( 0 );
					}
					else {
						return( -1 );
					}
				}
				else if( rhs == null ) {
					return( 1 );
				}
				else {
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey lhsPKey = lhs.getPKey();
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey rhsPKey = rhs.getPKey();
					int ret = lhsPKey.compareTo( rhsPKey );
					return( ret );
				}
			}
		};
		Collections.sort( arrayList, cmp );
		return( arrayList );
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjReadCachedByInhDuplicateIndex"
		>$implBuffTableObjReadCachedByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByUniqueIndexCopyArgToPKey">
		pkey.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadCachedObjByAltIdxCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByAltIdxCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByUniqueIndexCopyBuffToPKey">
				pkey.set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByUniqueIndexCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByIndexPassArg"
		>$Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByIndexCommaPassArg">,
				$implBuffReadCachedObjByIndexPassArg$</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadCachedObjByDuplicateIndex">
	public List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; readCached$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
		final String S_ProcName = "readCached$poptop Table TableName$By$Suffix$";
		$DefSchemaName$$poptop Table TableName$By$Suffix$Key key = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$poptop Table TableName$().new$Suffix$Key();$iterate Columns( each implBuffReadCachedObjByDuplicateIndexAssignKey )$
		ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = new ArrayList&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt;();
		if( indexBy$Suffix$ != null ) {
			if( indexBy$Suffix$.containsKey( key ) ) {
				Map&lt;$reference Table reference BaseClass DefSchemaName$$reference Table reference BaseClass TableName$PKey,I$DefSchemaName$$poptop Table TableName$Obj&gt; dict = indexBy$Suffix$.get( key );
				int len = dict.size();
				I$DefSchemaName$$poptop Table TableName$Obj arr[] = new I$DefSchemaName$$poptop Table TableName$Obj[len];
				Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = dict.values().iterator();
				int idx = 0;
				while( ( idx &lt; len ) &amp;&amp; valIter.hasNext() ) {
					arr[idx++] = valIter.next();
				}
				if( idx &lt; len ) {
					throw new CFLibArgumentUnderflowException( getClass(),
						S_ProcName,
						0,
						"idx",
						idx,
						len );
				}
				else if( valIter.hasNext() ) {
					throw new CFLibArgumentOverflowException( getClass(),
							S_ProcName,
							0,
							"idx",
							idx,
							len );
				}
				for( idx = 0; idx &lt; len; idx ++ ) {
					arrayList.add( arr[idx] );
				}
			}
		}
		else {
			I$DefSchemaName$$poptop Table TableName$Obj obj;
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; valIter = members.values().iterator();
			while( valIter.hasNext() ) {
				obj = valIter.next();
				if( obj != null ) {
					if( obj.getBuff().compareTo( key ) == 0 ) {
						arrayList.add( obj );
					}
				}
			}
		}
		Comparator&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt; cmp = new Comparator&lt;I$poptop Table DefSchemaName$$poptop Table TableName$Obj&gt;() {
			public int compare( I$poptop Table DefSchemaName$$poptop Table TableName$Obj lhs, I$poptop Table DefSchemaName$$poptop Table TableName$Obj rhs ) {
				if( lhs == null ) {
					if( rhs == null ) {
						return( 0 );
					}
					else {
						return( -1 );
					}
				}
				else if( rhs == null ) {
					return( 1 );
				}
				else {
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey lhsPKey = lhs.getPKey();
					$poptop Table reference BaseClass DefSchemaName$$poptop Table reference BaseClass TableName$PKey rhsPKey = rhs.getPKey();
					int ret = lhsPKey.compareTo( rhsPKey );
					return( ret );
				}
			}
		};
		Collections.sort( arrayList, cmp );
		return( arrayList );
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByDupIdxCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReadCachedObjByDuplicateIndexAssignKey">
		key.set$implColumnAttrOptionality$$Name$( $Name$ );</GenRule>

	<GenRule GenDef="Index" Name="implBuffReadCachedObjByDupIdxCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffDeepDisposeAllObjCopyPKeyClassCode">
				obj.getPKey().setClassCode( buff.getClassCode() );</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeepDisposeAllObjCopyPKeyAttribute">
				obj.getPKey().set$implColumnAttrOptionality$$Name$( buff.get$implColumnAttrOptionality$$Name$() );</GenRule>

	<GenRule GenDef="Table" Name="implBuffDeepDisposeObjByPKey">
	public void deepDispose$TableName$( $DefSchemaName$$reference BaseClass TableName$PKey pkey ) {
		I$DefSchemaName$$TableName$Obj obj = readCached$TableName$( pkey );
		if( obj != null ) {
			obj.forget();
		}
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffDeepDisposeObjByIndex"
		>$switch IsUnique
			yes implBuffDeepDisposeObjByUniqueIndex
			default implBuffDeepDisposeObjByDuplicateIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeepDisposeByIndexes"
		>$implBuffTableObjDeepDisposeByPrimaryIndex$$switch HasSuperClassRelation yes implBuffTableObjDeepDisposeByInhIndexes default empty$$iterate Index( each implBuffTableObjDeepDisposeByThisNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeepDisposeByPrimaryIndex"
		>$reference BaseClass reference PrimaryKeyIndex implBuffTableObjDeepDisposeByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeepDisposeBySubIndexes"
		>$switch HasSuperClassRelation yes implBuffTableObjDeepDisposeByInhIndexes default empty$$iterate Index( each implBuffTableObjDeepDisposeByInhNonPrimaryIndex )$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByThisNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjDeepDisposeByThisIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByInhNonPrimaryIndex"
		>$switch IsPrimaryIndex yes empty default implBuffTableObjDeepDisposeByInhIndex$</GenRule>

	<GenRule GenDef="Table" Name="implBuffTableObjDeepDisposeByInhIndexes"
		>$reference SuperClassRelation reference ToTable implBuffTableObjDeepDisposeBySubIndexes$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByThisIndex"
		>$switch IsUnique
			yes implBuffTableObjDeepDisposeByThisUniqueIndex
			default implBuffTableObjDeepDisposeByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByInhIndex"
		>$switch IsUnique
			yes implBuffTableObjDeepDisposeByInhUniqueIndex
			default implBuffTableObjDeepDisposeByInhDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByIndex"
		>$switch IsUnique
			yes implBuffTableObjDeepDisposeByUniqueIndex
			default implBuffTableObjDeepDisposeByDuplicateIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByThisUniqueIndex">
	public void deepDispose$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		I$DefSchemaName$$poptop Table TableName$Obj obj = readCached$poptop Table TableName$By$Suffix$( $iterate Columns( first implBuffDeepDisposeObjByIndexPassArg each implBuffDeepDisposeObjByIndexCommaPassArg )$ );
		if( obj != null ) {
			obj.forget();
		}
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByInhUniqueIndex"
		>$implBuffTableObjDeepDisposeByThisUniqueIndex$</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByThisDuplicateIndex">
	public void deepDispose$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
	{
		final String S_ProcName = "deepDispose$poptop Table TableName$By$Suffix$";
		I$DefSchemaName$$poptop Table TableName$Obj obj;
		List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = readCached$poptop Table TableName$By$Suffix$( $iterate Columns( first implBuffDeepDisposeObjByIndexPassArg each implBuffDeepDisposeObjByIndexCommaPassArg )$ );
		if( arrayList != null )  {
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayIter = arrayList.iterator();
			while( arrayIter.hasNext() ) {
				obj = arrayIter.next();
				if( obj != null ) {
					obj.forget();
				}
			}
		}
	}
</GenRule>

	<GenRule GenDef="Index" Name="implBuffTableObjDeepDisposeByInhDuplicateIndex"
		>$implBuffTableObjDeepDisposeByThisDuplicateIndex$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeepDisposeObjByIndexPassArg"
		>$Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffDeepDisposeObjByIndexCommaPassArg">,
				$implBuffDeepDisposeObjByIndexPassArg$</GenRule>

	<GenRule GenDef="Index" Name="implBuffDeepDisposeObjByDuplicateIndex">
	public void deepDispose$poptop Table TableName$By$Suffix$( $iterate Columns( first declColumnArg each declCommaColumnArg )$ )
		final String S_ProcName = "deepDispose$poptop Table TableName$By$Suffix$";
		I$DefSchemaName$$poptop Table TableName$Obj obj;
		List&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayList = readCached$poptop Table TableName$By$Suffix$( $iterate Columns( first implBuffDeepDisposeObjByIndexPassArg each implBuffDeepDisposeObjByIndexCommaPassArg )$ );
		if( arrayList != null )  {
			Iterator&lt;I$DefSchemaName$$poptop Table TableName$Obj&gt; arrayIter = arrayList.iterator();
			while( arrayIter.hasNext() ) {
				obj = arrayIter.next();
				if( obj != null ) {
					obj.forget();
				}
			}
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeTable">
	public void reallyDeepDispose$TableName$( I$DefSchemaName$$TableName$Obj obj )
	{
		final String S_ProcName = "$SchemaName$$TableName$TableObj.reallyDeepDispose$TableName$() ";
		String classCode;
		if( obj == null ) {
			return;
		}
		$DefSchemaName$$reference BaseClass TableName$PKey pkey = obj.getPKey();
		I$DefSchemaName$$TableName$Obj existing = readCached$TableName$( pkey );
		if( existing == null ) {
			return;
		}
		members.remove( pkey );$iterate Index( each maybeBuffImplReallyDeepDisposeTableInitIndexKey )$
$switch HasDelDeps no implBuffReallyDeepDisposeCascades default implBuffReallyDeepDisposeTableDelDeps$
$iterate Index( each maybeBuffImplReallyDeepDisposeTableRemoveIndexEntry )$
$switch HasSuperClassRelation yes implBuffReallyDeepDisposeTableInvokeSuper default empty$
	}</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeCascades"
		>$implBuffReallyDeleteCascades$</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeleteCascades"
		>$iterate Relation( each implBuffReallyDeepDisposeCascadeRelation empty empty )$$switch HasSuperClassRelation yes implBuffReallyDeepDisposeSuperCascades default empty$</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeSuperCascades"
		>$reference SuperClassRelation reference ToTable implBuffReallyDeleteCascades$</GenRule>

	<GenRule GenDef="Relation" Name="implBuffReallyDeepDisposeCascadeRelation"
		>$switch RelationTypeTag
			Components implBuffReallyDeepDisposeCascade
			Children implBuffReallyDeepDisposeCascade
			Details implBuffReallyDeepDisposeCascade
			default empty$</GenRule>

	<GenRule GenDef="Relation" Name="implBuffReallyDeepDisposeCascade"
		>$switch ToIndexIsUnique yes implBuffReallyDeepDisposeCascadeSingleton default implBuffReallyDeepDisposeCascadeMany$</GenRule>

	<GenRule GenDef="Relation" Name="implBuffReallyDeepDisposeCascadeSingleton">
		schema.get$reference ToTable TableName$TableObj().deepDispose$reference ToTable TableName$By$reference ToIndex Suffix$( $reference FromIndex iterate Columns( first implBuffReallyDeepDisposeTableDelExistingPassArg each implBuffReallyDeepDisposeTableDelExistingCommaPassArg )$ );</GenRule>

	<GenRule GenDef="Relation" Name="implBuffReallyDeepDisposeCascadeMany">
		schema.get$reference ToTable TableName$TableObj().deepDispose$reference ToTable TableName$By$reference ToIndex Suffix$( $reference FromIndex iterate Columns( first implBuffReallyDeepDisposeTableDelExistingPassArg each implBuffReallyDeepDisposeTableDelExistingCommaPassArg )$ );</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeTableDelDeps"
		>$implBuffReallyDeleteTableDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeleteTableDelDeps"
		>$switch HasSuperClassRelation yes implBuffReallyDeepDisposeTableInhDelDeps default implBuffReallyDeepDisposeTableBaseDelDeps$</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeTableInhDelDeps"
		>$reference SuperClassRelation reference ToTable implBuffReallyDeleteTableDelDeps$$iterate ReverseDelDeps( each implBuffReallyDeepDisposeTableDelDep empty empty )$</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeTableBaseDelDeps"
		>$iterate ReverseDelDeps( each implBuffReallyDeepDisposeTableDelDep empty empty )$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implBuffReallyDeepDisposeTableDelDep"
		>$switch RelationIsUnique yes implBuffReallyDeepDisposeTableDelUniqueDep default implBuffReallyDeepDisposeTableDelDupDep$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implBuffReallyDeepDisposeTableDelUniqueDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelUniqueDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implBuffReallyDeepDisposeTableDelDupDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelDupDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implBuffReallyDeepDisposeTableDelThisOne">
					schema.get$reference Relation reference ToTable TableName$TableObj().deepDispose$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelExistingPassArg each implBuffReallyDeepDisposeTableDelExistingCommaPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelExistingPassArg"
		>existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelExistingCommaPassArg">,
						$implBuffReallyDeepDisposeTableDelExistingPassArg$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReallyDeepDisposeTableDelExistingPassArg"
		>existing.get$OptionalOrRequired$$Name$()</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReallyDeepDisposeTableDelExistingCommaPassArg">,
						$implBuffReallyDeepDisposeTableDelExistingPassArg$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implBuffReallyDeepDisposeTableDelUniqueDepChaseDown">
		I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTablePassExistingArg each implBuffReallyDeepDisposeTableCommaPassExistingArg )$ );
		if( obj$Name$ != null ) {$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
		}</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTablePassExistingArg"
		>existing.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableCommaPassExistingArg">,
			$implBuffReallyDeepDisposeTablePassExistingArg$</GenRule>

	<GenRule GenDef="DelTopDep" Name="implBuffReallyDeepDisposeTableDelDupDepChaseDown">
		I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$;
		List&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; arr$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTablePassExistingArg each implBuffReallyDeepDisposeTableCommaPassExistingArg )$ );
		Iterator&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; iter$Name$ = arr$Name$.iterator();
		while( iter$Name$.hasNext() ) {
			obj$Name$ = iter$Name$.next();
			if( obj$Name$ != null ) {$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}
		}</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implBuffReallyDeepDisposeTableDelDep"
		>$switch RelationIsUnique yes implBuffReallyDeepDisposeTableDelUniqueDep default implBuffReallyDeepDisposeTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implBuffReallyDeepDisposeTableDelUniqueDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelUniqueDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implBuffReallyDeepDisposeTableDelDupDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelDupDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implBuffReallyDeepDisposeTableDelThisOne">
						schema.get$reference Relation reference ToTable TableName$TableObj().deepDispose$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelTopDepPassArg each implBuffReallyDeepDisposeTableDelTopDepCommaPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelTopDepPassArg"
		>obj$popto DelTopDep Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelTopDepCommaPassArg">,
							$implBuffReallyDeepDisposeTableDelTopDepPassArg$</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implBuffReallyDeepDisposeTableDelUniqueDepChaseDown">
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference FromIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelTopDepPassArg each implBuffReallyDeepDisposeTableDelTopDepCommaPassArg )$ );
			if( obj$Name$ != null ) {$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep1" Name="implBuffReallyDeepDisposeTableDelDupDepChaseDown">
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$;
			List&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; arr$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelTopDepPassArg each implBuffReallyDeepDisposeTableDelTopDepCommaPassArg )$ );
			Iterator&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; iter$Name$ = arr$Name$.iterator();
			while( iter$Name$.hasNext() ) {
				obj$Name$ = iter$Name$.next();$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implBuffReallyDeepDisposeTableDelDep"
		>$switch RelationIsUnique yes implBuffReallyDeepDisposeTableDelUniqueDep default implBuffReallyDeepDisposeTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implBuffReallyDeepDisposeTableDelUniqueDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelUniqueDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implBuffReallyDeepDisposeTableDelDupDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelDupDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implBuffReallyDeepDisposeTableDelThisOne">
					schema.get$reference Relation reference ToTable TableName$TableObj().deepDispose$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelSubDep1PassArg each implBuffReallyDeepDisposeTableDelSubDep1CommaPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelSubDep1PassArg"
		>obj$popto DelSubDep1 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelSubDep1CommaPassArg">,
							$implBuffReallyDeepDisposeTableDelSubDep1PassArg$</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implBuffReallyDeepDisposeTableDelUniqueDepChaseDown">
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference FromIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelSubDep1PassArg each implBuffReallyDeepDisposeTableDelSubDep1CommaPassArg )$ );
			if( buff$Name$ != null ) {$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep2" Name="implBuffReallyDeepDisposeTableDelDupDepChaseDown">
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$;
			List&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; arr$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelSubDep1PassArg each implBuffReallyDeepDisposeTableDelSubDep1CommaPassArg )$ );
			Iterator&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; iter$Name$ = arr$Name$.iterator();
			while( iter$Name$.hasNext() ) {
				obj$Name$ = iter$Name$.next();$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implBuffReallyDeepDisposeTableDelDep"
		>$switch RelationIsUnique yes implBuffReallyDeepDisposeTableDelUniqueDep default implBuffReallyDeepDisposeTableDelDupDep$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implBuffReallyDeepDisposeTableDelUniqueDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelUniqueDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implBuffReallyDeepDisposeTableDelDupDep"
		>$switch HasDelSubDep yes implBuffReallyDeepDisposeTableDelDupDepChaseDown default implBuffReallyDeepDisposeTableDelThisOne$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implBuffReallyDeepDisposeTableDelThisOne">
					schema.get$reference Relation reference ToTable TableName$TableObj().deepDispose$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelSubDep2PassArg each implBuffReallyDeepDisposeTableDelSubDep2CommaPassArg )$ );</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelSubDep2PassArg"
		>obj$popto DelSubDep2 Name$.get$reference FromCol OptionalOrRequired$$reference FromCol Name$()</GenRule>

	<GenRule GenDef="RelationCol" Name="implBuffReallyDeepDisposeTableDelSubDep2CommaPassArg">,
							$implBuffReallyDeepDisposeTableDelSubDep2PassArg$</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implBuffReallyDeepDisposeTableDelUniqueDepChaseDown">
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference FromIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelSubDep2PassArg each implBuffReallyDeepDisposeTableDelSubDep2CommaPassArg )$ );
			if( buff$Name$ != null ) {$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}</GenRule>

	<GenRule GenDef="DelSubDep3" Name="implBuffReallyDeepDisposeTableDelDupDepChaseDown">
			I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj obj$Name$;
			List&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; arr$Name$ = schema.get$reference Relation reference ToTable TableName$TableObj().readCached$reference Relation reference ToTable TableName$By$reference Relation reference ToIndex Suffix$( $reference Relation iterate Columns( first implBuffReallyDeepDisposeTableDelSubDep2PassArg each implBuffReallyDeepDisposeTableDelSubDep2CommaPassArg )$ );
			Iterator&lt;I$reference Relation reference ToTable EffSchemaName$$reference Relation reference ToTable TableName$Obj&gt; iter$Name$ = arr$Name$.iterator();
			while( iter$Name$.hasNext() ) {
				obj$Name$ = iter$Name$.next();$reference DelSubDep implBuffReallyDeepDisposeTableDelDep$
			}</GenRule>

	<GenRule GenDef="Index" Name="maybeBuffImplReallyDeepDisposeTableInitIndexKey"
		>$switch IsPrimaryIndex yes empty default implBuffReallyDeepDisposeTableInitIndexKey$</GenRule>

	<GenRule GenDef="Index" Name="implBuffReallyDeepDisposeTableInitIndexKey">
		$DefSchemaName$$TableName$By$Suffix$Key key$Suffix$ = ((I$SchemaName$Schema)schema.getBackingStore()).getFactory$TableName$().new$Suffix$Key();
$iterate Columns( each implBuffReallyDeepDisposeTableInitExistingKeyAttr )$</GenRule>

	<GenRule GenDef="IndexCol" Name="implBuffReallyDeepDisposeTableInitExistingKeyAttr"
>		key$popto Index Suffix$.set$implColumnAttrOptionality$$Name$( existing.get$implColumnAttrOptionality$$Name$() );
</GenRule>

	<GenRule GenDef="Index" Name="maybeBuffImplReallyDeepDisposeTableRemoveIndexEntry"
		>$switch IsPrimaryIndex yes empty default implBuffReallyDeepDisposeTableRemoveIndexEntry$</GenRule>
	<GenRule GenDef="Index" Name="implBuffReallyDeepDisposeTableRemoveIndexEntry"
		>$switch IsUnique yes implBuffReallyDeepDisposeTableRemoveUniqueEntry default implBuffReallyDeepDisposeTableRemoveDupEntry$</GenRule>
	<GenRule GenDef="Index" Name="implBuffReallyDeepDisposeTableRemoveUniqueEntry">
		if( indexBy$Suffix$ != null ) {
			indexBy$Suffix$.remove( key$Suffix$ );
		}
</GenRule>
	<GenRule GenDef="Index" Name="implBuffReallyDeepDisposeTableRemoveDupEntry">
		if( indexBy$Suffix$ != null ) {
			if( indexBy$Suffix$.containsKey( key$Suffix$ ) ) {
				indexBy$Suffix$.get( key$Suffix$ ).remove( pkey );
				if( indexBy$Suffix$.get( key$Suffix$ ).size() &lt;= 0 ) {
					indexBy$Suffix$.remove( key$Suffix$ );
				}
			}
		}
</GenRule>

	<GenRule GenDef="Table" Name="implBuffReallyDeepDisposeTableInvokeSuper">
		schema.get$reference SuperClassRelation reference ToTable TableName$TableObj().reallyDeepDispose$reference SuperClassRelation reference ToTable TableName$( obj );</GenRule>

</RuleSet>
