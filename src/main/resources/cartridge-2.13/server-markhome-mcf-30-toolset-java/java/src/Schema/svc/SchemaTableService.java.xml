<?xml version="1.0" encoding="UTF-8"?>
<!--
 *	Mark's Code Fractal 2.13 CFKBase - Code Fractal Knowledge Base
 * 
 *	Copyright (C) 2016-2025 Mark Stephen Sobkow
 *
 *	This file is part of Mark's Code Fractal 2.13, providing the extensible
 *	knowledge base for starting to customize Mark's Code Fractal with your own
 *	rules and custom verbs.
 *
 *	This program is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 *
 *	If you wish to modify and use this code without publishing your changes,
 *	or integrate it with proprietary code, please contact Mark Stephen Sobkow
 *	for a commercial license at mark.sobkow@gmail.com
 * -->
<RuleSet
	xmlns="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd http://msscf.org:8088/msscf/2.0.13/xsd/cfgenkb-2.13-ruleset.xsd"
	ToolSet="java"
	Name="src/Schema/svc/SchemaTableService.java"
	Revision="3.0"
	Descr="Java Spring JPA Service for $TableName$.">

	<GenFile GenDef="Table" Name="fileSchemaTableServiceJava"
			GenerateOnce="false"
		ModuleName="$reference ManufacturingSchema lower JavaPackage$.svc"
		SourceBundle="java"
		BasePackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$/src/main/java"
		SubPackageName="$reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.svc"
		ExpansionClassName="$SchemaName$$TableName$ServiceJava"
		ExpansionKeyName="$SchemaName$$TableName$ServiceJava"
		ExpansionFileName="$SchemaName$$TableName$Service.java"
>// Description: Java Spring JPA Service for $TableName$.

$MssSourceLicense$

package $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.svc;

import java.io.Serializable;
import java.math.*;
import java.time.*;
import java.util.*;
import jakarta.persistence.*;
import server.markhome.msscf.v3_1.cflib.*;
import server.markhome.msscf.v3_1.cflib.dbutil.*;
import server.markhome.msscf.v3_1.cflib.xml.CFLibXmlUtil;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.text.StringEscapeUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;$poptop SchemaDef iterate SchemaRefs( each importJavaPackageSchemaName empty empty )$
import $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.*;
import $lower DefTopProjectName$.$DefVUnderVersion$.$lower DefSubProjectName$.$lower DefSchemaName$.jpa.*;

/**
 *	Service for the $SchemaName$$TableName$ entities defined in $reference ManufacturingSchema lower JavaPackage$.$reference ManufacturingSchema lower SchemaName$.jpa
 *	using the $SchemaName$$TableName$Repository to access them.
 */
@Service("$SchemaName$$TableName$Service")
public class $SchemaName$$TableName$Service {

	@Autowired
	@Qualifier("$lower SchemaName$EntityManagerFactory")
	private LocalContainerEntityManagerFactoryBean $lower SchemaName$EntityManagerFactory;

	@Autowired
	private $SchemaName$$TableName$Repository $lower SchemaName$$TableName$Repository;
$declServiceCreate$$declServiceUpdate$$declServiceTableFinders$$declServiceTableLockers$$declServiceTableDeleters$
}
</GenFile>

	<GenRule GenDef="Table" Name="declJpaServiceFind">
	/**
	 *	Argument-based find database instance for compatibility with the current MSS code factory code base.
	 *$reference BaseClass reference PrimaryKeyIndex iterate Columns( each emitJpaColumnArgumentComment )$
	 *
	 *		@return The retrieved entity, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ find($reference BaseClass reference PrimaryKeyIndex iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.get($reference BaseClass reference PrimaryKeyIndex iterate Columns(first passArgDirect each commaPassArgDirect)$));
	}
$switch IsPrimaryIndexKeyAtomic yes empty default declJpaServiceFindByPKey$</GenRule>

	<GenRule GenDef="Table" Name="declJpaServiceFindByPKey">
	/**
	 *	$SchemaName$$TableName$PKey based find method for object-based access.
	 *
	 *		@param key The key of the entity to be find.
	 *
	 *		@return The entity find, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ find($SchemaName$$TableName$PKey key) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.get($reference BaseClass reference PrimaryKeyIndex iterate Columns(first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="declJpaServicePassDirectAttr">$leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>
	<GenRule GenDef="IndexCol" Name="commaDeclJpaServicePassDirectAttr">,
			$declJpaServicePassDirectAttr$</GenRule>

	<GenRule GenDef="Table" Name="declServiceTableLockers">$switch HasSuperClassRelation yes declInheritedServiceTableLockers default empty$
	// $SchemaName$$TableName$ specified lock-by-index methods
$iterate Index(each maybeDeclJpaServiceLocker empty empty)$</GenRule>

	<GenRule GenDef="Table" Name="declInheritedServiceTableLockers">$reference SuperClassRelation reference ToTable declServiceTableLockers$</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclJpaServiceLocker">$switch IsPrimaryIndex yes maybeDeclJpaServiceLockerIfBaseTable default declJpaServiceLock$</GenRule>
	<GenRule GenDef="Index" Name="maybeDeclJpaServiceLockerIfBaseTable">$switch TableHasSuperClassRelation yes empty default declJpaServiceLockPKey$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceLockPKey">
	/**
	 *	Argument-based lock database entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity locks, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ lockBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.lockBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$));
	}
$switch IsPrimaryIndexKeyAtomic yes empty default declJpaServiceLockPKeyByObj$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceLockPKeyByObj">
	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The key of the entity to be locked.
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ lockBy$IndexName$($SchemaName$$TableName$PKey key) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.lockBy$IndexName$($iterate Columns(first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceLock">$switch IsPrimaryIndex yes empty default reallyDeclJpaServiceLock$</GenRule>
	<GenRule GenDef="Index" Name="reallyDeclJpaServiceLock">$switch IsUnique yes declJpaServiceLockSingle default declJpaServiceLockMultiple$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceLockSingle">
	/**
	 *	Argument-based lock database entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity locks, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ lockBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.lockBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$));
	}

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The key of the entity to be locked.
	 *
	 *		@return The locked entity, refreshed from the data store, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ lockBy$IndexName$($SchemaName$$TableName$By$Suffix$Key key) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.lockBy$IndexName$($iterate Columns(first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceLockMultiple">
	/**
	 *	Argument-based lock database instance for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity locks, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return A list of locked entities, refreshed from the data store, or an empty list if no such entities exist.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public List&lt;$poptop Table SchemaName$$poptop Table TableName$&gt; lockBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.lockBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$));
	}

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The key of the entity to be locked.
	 *
	 *		@return A list of locked entities, refreshed from the data store, or an empty list if no such entities exist.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public List&lt;$poptop Table SchemaName$$poptop Table TableName$&gt; lockBy$IndexName$($SchemaName$$TableName$By$Suffix$Key key) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.lockBy$IndexName$($iterate Columns(first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="Table" Name="declServiceTableDeleters">$switch HasSuperClassRelation yes declInheritedServiceTableDeleters default empty$
	// $SchemaName$$TableName$ specified delete-by-index methods
$iterate Index(each maybeDeclJpaServiceDeleter empty empty)$</GenRule>

	<GenRule GenDef="Table" Name="declInheritedServiceTableDeleters">$reference SuperClassRelation reference ToTable declServiceTableDeleters$</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclJpaServiceDeleter">$switch IsPrimaryIndex yes maybeDeclJpaServiceDeleterIfBaseTable default declJpaServiceDelete$</GenRule>
	<GenRule GenDef="Index" Name="maybeDeclJpaServiceDeleterIfBaseTable">$switch TableHasSuperClassRelation yes empty default declJpaServiceDeleteByPKey$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceDeleteByPKey">
	/**
	 *	Argument-based delete entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity lock, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public void deleteBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		$lower poptop Table SchemaName$$poptop Table TableName$Repository.deleteBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$);
	}
$switch IsPrimaryIndexKeyAtomic yes empty default declJpaServiceDeleteByPKeyObj$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceDeleteByPKeyObj">
	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key of the entity to be locked.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public void deleteBy$IndexName$($SchemaName$$TableName$PKey key) {
		$lower poptop Table SchemaName$$poptop Table TableName$Repository.deleteBy$IndexName$($iterate Columns(first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$);
	}
</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceDelete">
	/**
	 *	Argument-based delete entity for compatibility with the current MSS code factory code base, uses @Transactional to acquire a JPA entity lock, which may or may not imply an actual database lock during the transaction.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public void deleteBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		$lower poptop Table SchemaName$$poptop Table TableName$Repository.deleteBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$);
	}

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key based lock method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key of the entity to be locked.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public void deleteBy$IndexName$($SchemaName$$TableName$By$Suffix$Key key) {
		$lower poptop Table SchemaName$$poptop Table TableName$Repository.deleteBy$IndexName$($iterate Columns(first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$);
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="commaDeclJpaServicePassKeyAttr">, $declJpaServicePassKeyAttr$</GenRule>
	<GenRule GenDef="IndexCol" Name="declJpaServicePassKeyAttr">key.get$reference Column implColumnAttrOptionality$$reference Column Name$()</GenRule>

	<GenRule GenDef="Table" Name="declServiceTableFinders">$switch HasSuperClassRelation yes declInheritedServiceTableFinders default declJpaServiceFind$
	// $SchemaName$$TableName$ specified index finders
$iterate Index(each maybeDeclJpaServiceFinder empty empty)$</GenRule>
	<GenRule GenDef="Table" Name="declInheritedServiceTableFinders">$reference SuperClassRelation reference ToTable declServiceTableFinders$</GenRule>

	<GenRule GenDef="IndexCol" Name="declJpaServiceGetArgument">$reference Column implJavaAtomType$ $leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>
	<GenRule GenDef="IndexCol" Name="commaDeclJpaServiceGetArgument">,
		$declJpaServiceGetArgument$</GenRule>

	<GenRule GenDef="IndexCol" Name="setJpaServiceKeyAttr">
		key.set$reference Column implColumnAttrOptionality$$reference Column Name$( $leadlower reference Column implColumnAttrOptionality$$reference Column Name$ );</GenRule>

	<GenRule GenDef="Index" Name="maybeDeclJpaServiceFinder">$switch IsPrimaryIndex yes empty default declJpaServiceFinder$</GenRule>
	<GenRule GenDef="Index" Name="declJpaServiceFinder">$switch IsUnique yes declJpaServiceFindSingle default declJpaServiceFindList$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceFindSingle">
	/**
	 *	Find an entity using the columns of the $SchemaName$$TableName$By$Suffix$Key as arguments.
	 *$iterate Columns( each emitJpaColumnArgumentComment)$
	 *
	 *		@return The found entity, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ findBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.findBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$));
	}

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key entity finder convenience method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key instance to use for the query arguments.
	 *
	 *		@return The found entity, or null if no such entity exists.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ findBy$IndexName$($SchemaName$$TableName$By$Suffix$Key key) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.findBy$IndexName$($iterate Columns( first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="commaDeclJpaServiceQueryColumnArg"> and $declJpaServiceQueryColumnArg$</GenRule>
	<GenRule GenDef="IndexCol" Name="declJpaServiceQueryColumnArg">r.$effDbColName$ = :$leadlower reference Column Name$</GenRule>

	<GenRule GenDef="Index" Name="declJpaServiceFindList">
	/**
	 *	Find zero or more entities into a List using the columns of the $SchemaName$$TableName$By$Suffix$Key as arguments.
	 *$iterate Columns( each emitJpaColumnArgumentComment )$
	 *
	 *		@return List&amp;lt;$poptop Table SchemaName$$poptop Table TableName$&amp;gt; of the found entities, or an empty list if no such entities exist.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public List&lt;$poptop Table SchemaName$$poptop Table TableName$&gt; findBy$IndexName$($iterate Columns(first declJpaServiceArgument each commaDeclJpaServiceArgument)$) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.findBy$IndexName$($iterate Columns(first passArgDirect each commaPassArgDirect)$));
	}

	/**
	 *	$SchemaName$$TableName$By$Suffix$Key entity list finder convenience method for object-based access.
	 *
	 *		@param key The $SchemaName$$TableName$By$Suffix$Key instance to use for the query arguments.
	 *
	 *		@return The found entity list, which may be empty.
	 */
	@Transactional(propagation = Propagation.REQUIRED, noRollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public List&lt;$poptop Table SchemaName$$poptop Table TableName$&gt; findBy$IndexName$($SchemaName$$TableName$By$Suffix$Key key) {
		return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.findBy$IndexName$($iterate Columns( first declJpaServicePassKeyAttr each commaDeclJpaServicePassKeyAttr)$));
	}
</GenRule>

	<GenRule GenDef="IndexCol" Name="commaDeclJpaServiceArgument">,
		$declJpaServiceArgument$</GenRule>
	<GenRule GenDef="IndexCol" Name="declJpaServiceArgument">@Param("$reference Column leadlower Name$") $reference Column implJavaAtomType$ $leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>

	<GenRule GenDef="IndexCol" Name="commaPassArgDirect">,
			$passArgDirect$</GenRule>
	<GenRule GenDef="IndexCol" Name="passArgDirect">$leadlower reference Column implColumnAttrOptionality$$reference Column Name$</GenRule>

	<GenRule GenDef="Table" Name="declServiceCreate">
	/**
	 *	Create an entity, generating any database keys required along the way.
	 *
	 *		@param	data	The entity to be instantiated; must be a specific instance of $poptop Table SchemaName$$poptop Table TableName$, not a subclass.
	 *
	 *		@return The updated/created entity.
	 */
	@Transactional(propagation = Propagation.REQUIRED,rollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ create($poptop Table SchemaName$$poptop Table TableName$ data) {
		final String S_ProcName = "create";
		if (data == null) {
			return( null );
		}$switch IsPrimaryIndexKeyAtomic yes empty default declServiceCreateEnsurePKeyObjNotNull$$reference BaseClass reference PrimaryKeyIndex iterate Columns(each maybeServiceCreateStashGenerated)$$serviceCheckDataValid$
		try {$reference BaseClass reference PrimaryKeyIndex iterate Columns(each maybeServiceCreateGenerateId)$$switch IsBaseTableAudited yes serviceCreateInitAuditColumns default empty$
			if(data.getPKey() != null &amp;&amp; $lower poptop Table SchemaName$$poptop Table TableName$Repository.existsById(data.getPKey())) {
				return( $lower poptop Table SchemaName$$poptop Table TableName$Repository.findById(data.getPKey()).get());
			}
			return $lower poptop Table SchemaName$$poptop Table TableName$Repository.save(data);
		}
		catch(Exception ex) {$reference BaseClass reference PrimaryKeyIndex iterate Columns(each maybeServiceCreateRestoreGenerated)$
			throw new CFLibDbException(getClass(),
				S_ProcName,
				ex);
		}
	}
</GenRule>

	<GenRule GenDef="Table" Name="declServiceCreateEnsurePKeyObjNotNull">
		if (data.getPKey() == null) {
			throw new CFLibNullArgumentException(getClass(),
				S_ProcName,
				0,
				"data.getPKey()");
		}</GenRule>
	<GenRule GenDef="Table" Name="IsBaseTableAudited">$reference BaseClass HasAuditColumns$</GenRule>
	
	<GenRule GenDef="Table" Name="declServiceUpdate">
	/**
	 *	Update an existing entity.
	 *
	 *		@param	data	The entity to be updated.
	 *
	 *		@return The updated entity.
	 */
	@Transactional(propagation = Propagation.REQUIRED,rollbackFor = NoResultException.class, transactionManager = "$lower SchemaName$TransactionManager")
	public $poptop Table SchemaName$$poptop Table TableName$ update($poptop Table SchemaName$$poptop Table TableName$ data) {
		final String S_ProcName = "update";
		if (data == null) {
			return( null );
		}$declServiceCreateEnsurePKeyObjNotNull$$serviceCheckDataValid$
		// Ensure the entity exists and that the revision matches
		$poptop Table SchemaName$$poptop Table TableName$ existing = $lower poptop Table SchemaName$$poptop Table TableName$Repository.findById(data.getPKey())
			.orElseThrow(() -> new CFLibCollisionDetectedException(getClass(), S_ProcName, data.getPKey()));
		if (existing.getRequiredRevision() != data.getRequiredRevision()) {
			throw new CFLibCollisionDetectedException(getClass(), S_ProcName, data.getPKey());
		}$serviceUpdateApplyDataToExisting$$switch IsBaseTableAudited yes serviceUpdateInitAuditColumns default empty$
		// Save the changes we've made
		return $lower poptop Table SchemaName$$poptop Table TableName$Repository.save(existing);
	}
</GenRule>

	<GenRule GenDef="Table" Name="serviceUpdateApplyDataToExisting">$switch HasSuperClassRelation yes superServiceUpdateApplyDataToExisting default empty$
		// Apply data columns of $SchemaName$$TableName$ to existing object$iterate DataColumns( each serviceUpdateApplyDataColToExistingCol empty empty )$</GenRule>
	<GenRule GenDef="Table" Name="superServiceUpdateApplyDataToExisting">$reference SuperClassRelation reference ToTable serviceUpdateApplyDataToExisting$</GenRule>
	<GenRule GenDef="Value" Name="serviceUpdateApplyDataColToExistingCol">
		existing.set$implColumnAttrOptionality$$Name$(data.get$implColumnAttrOptionality$$Name$());</GenRule>

	<GenRule GenDef="Table" Name="serviceUpdateInitAuditColumns">
		// Update the audit columns
		data.setUpdatedAt(LocalDateTime.now());</GenRule>

	<GenRule GenDef="Table" Name="serviceCreateInitAuditColumns">
			LocalDateTime now = LocalDateTime.now();
			data.setCreatedAt(now);
			data.setUpdatedAt(now);</GenRule>

	<GenRule GenDef="Table" Name="serviceCheckDataValid">$switch HasSuperClassRelation yes serviceCheckInheritedDataValid default empty$$iterate DataColumns( each serviceCheckDataColValid empty empty )$</GenRule>
	<GenRule GenDef="Table" Name="serviceCheckInheritedDataValid">$reference SuperClassRelation reference ToTable serviceCheckDataValid$</GenRule>
	<GenRule GenDef="Atom" Name="serviceCheckDataColValid">$switch IsNullable yes empty default serviceEnsureDataColNotNull$$switch HasMinValue yes serviceCheckMinValue default empty$$switch HasMaxValue yes serviceCheckMaxValue default empty$</GenRule>
	<GenRule GenDef="TableCol" Name="serviceCheckDataColValid">$switch IsNullable yes empty default serviceEnsureDataColNotNull$$switch HasMinValue yes serviceCheckMinValue default empty$$switch HasMaxValue yes serviceCheckMaxValue default empty$</GenRule>

	<GenRule GenDef="Value" Name="serviceEnsureDataColNotNull"
		>$switch BaseModelAtomClass
			BlobDef serviceEnsureColObjNotNull
			BoolDef empty
			EnumDef serviceEnsureColObjNotNull
			Int16Def empty
			Int32Def empty
			Int64Def empty
			UInt16Def empty
			UInt32Def empty
			UInt64Def serviceEnsureColObjNotNull
			Id16Gen empty
			Id32Gen empty
			Id64Gen empty
			FloatDef empty
			DoubleDef empty
			NumberDef serviceEnsureColObjNotNull
			StringDef serviceEnsureColObjNotNull
			TokenDef serviceEnsureColObjNotNull
			NmTokenDef serviceEnsureColObjNotNull
			NmTokensDef serviceEnsureColObjNotNull
			TextDef serviceEnsureColObjNotNull
			DateDef serviceEnsureColObjNotNull
			TimeDef serviceEnsureColObjNotNull
			TimestampDef serviceEnsureColObjNotNull
			TZDateDef serviceEnsureColObjNotNull
			TZTimeDef serviceEnsureColObjNotNull
			TZTimestampDef serviceEnsureColObjNotNull
			DbKeyHash128Gen serviceEnsureColDbHashNotNull
			DbKeyHash160Gen serviceEnsureColDbHashNotNull
			DbKeyHash224Gen serviceEnsureColDbHashNotNull
			DbKeyHash256Gen serviceEnsureColDbHashNotNull
			DbKeyHash384Gen serviceEnsureColDbHashNotNull
			DbKeyHash512Gen serviceEnsureColDbHashNotNull
			DbKeyHash128Def serviceEnsureColDbHashNotNull
			DbKeyHash160Def serviceEnsureColDbHashNotNull
			DbKeyHash224Def serviceEnsureColDbHashNotNull
			DbKeyHash256Def serviceEnsureColDbHashNotNull
			DbKeyHash384Def serviceEnsureColDbHashNotNull
			DbKeyHash512Def serviceEnsureColDbHashNotNull
			Uuid6Gen serviceEnsureColObjNotNull
			Uuid6Def serviceEnsureColObjNotNull
			UuidGen serviceEnsureColObjNotNull
			UuidDef serviceEnsureColObjNotNull
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="serviceEnsureColObjNotNull">
		if(data.get$implColumnAttrOptionality$$Name$() == null) {
			throw new CFLibNullArgumentException(getClass(),
				S_ProcName,
				0,
				"data.$leadlower implColumnAttrOptionality$$Name$");
		}</GenRule>

	<GenRule GenDef="Value" Name="serviceEnsureColDbHashNotNull">
		if(data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
			throw new CFLibNullArgumentException(getClass(),
				S_ProcName,
				0,
				"data.$leadlower implColumnAttrOptionality$$Name$");
		}</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeServiceCreateStashGenerated">$switch GenerateId yes serviceCreateStashGenerated default empty$</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeServiceCreateGenerateId">$switch GenerateId yes serviceCreateGenerateId default empty$</GenRule>

	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateId">$switch BaseModelAtomClass
			Id16Gen empty
			Id32Gen empty
			Id64Gen empty
			DbKeyHash128Gen serviceCreateGenerateDbKeyHash128
			DbKeyHash160Gen serviceCreateGenerateDbKeyHash160
			DbKeyHash224Gen serviceCreateGenerateDbKeyHash224
			DbKeyHash256Gen serviceCreateGenerateDbKeyHash256
			DbKeyHash384Gen serviceCreateGenerateDbKeyHash384
			DbKeyHash512Gen serviceCreateGenerateDbKeyHash512
			UuidGen serviceCreateGenerateUuid
			Uuid6Gen serviceCreateGenerateUuid6
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateDbKeyHash128">
			if (data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
				data.set$implColumnAttrOptionality$$Name$(new CFLibDbKeyHash128(0));
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateDbKeyHash160">
			if (data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
				data.set$implColumnAttrOptionality$$Name$(new CFLibDbKeyHash160(0));
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateDbKeyHash224">
			if (data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
				data.set$implColumnAttrOptionality$$Name$(new CFLibDbKeyHash224(0));
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateDbKeyHash256">
			if (data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
				data.set$implColumnAttrOptionality$$Name$(new CFLibDbKeyHash256(0));
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateDbKeyHash384">
			if (data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
				data.set$implColumnAttrOptionality$$Name$(new CFLibDbKeyHash384(0));
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateDbKeyHash512">
			if (data.get$implColumnAttrOptionality$$Name$() == null || data.get$implColumnAttrOptionality$$Name$().isNull()) {
				data.set$implColumnAttrOptionality$$Name$(new CFLibDbKeyHash512(0));
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateUuid">
			if (data.get$implColumnAttrOptionality$$Name$() == null) {
				data.set$implColumnAttrOptionality$$Name$(UUID.randomUUID());
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateGenerateUuid6">
			if (data.get$implColumnAttrOptionality$$Name$() == null) {
				data.set$implColumnAttrOptionality$$Name$(CFLibUuid6.generateUuid6());
				generated$implColumnAttrOptionality$$Name$ = true;
			}</GenRule>

	<GenRule GenDef="IndexCol" Name="serviceCreateStashGenerated">
		$implJavaAtomType$ original$reference Column implColumnAttrOptionality$$reference Column Name$ = data$serviceDerefPKeyMember$.get$reference Column implColumnAttrOptionality$$reference Column Name$();
		boolean generated$reference Column implColumnAttrOptionality$$reference Column Name$ = false;</GenRule>

	<GenRule GenDef="IndexCol" Name="serviceDerefPKeyMember">$switch IsPrimaryIndexKeyAtomic yes empty default derefPKeyMember$</GenRule>
	<GenRule GenDef="Object" Name="derefPKeyMember">.getPKey()</GenRule>

	<GenRule GenDef="IndexCol" Name="maybeServiceCreateRestoreGenerated">$switch GenerateId yes serviceCreateRestoreGenerated default empty$</GenRule>
	<GenRule GenDef="IndexCol" Name="serviceCreateRestoreGenerated">
				if(generated$reference Column implColumnAttrOptionality$$reference Column Name$) {
					data.set$reference Column implColumnAttrOptionality$$reference Column Name$(original$reference Column implColumnAttrOptionality$$reference Column Name$);
				}</GenRule>

	<GenRule GenDef="Value" Name="serviceCheckMinValue">$switch IsNullable yes serviceOptCheckMinValue default serviceReqCheckMinValue$</GenRule>
	<GenRule GenDef="Value" Name="serviceCheckMaxValue">$switch IsNullable yes serviceOptCheckMaxValue default serviceReqCheckMaxValue$</GenRule>

	<GenRule GenDef="Value" Name="serviceReqCheckMinValue"
		>$switch BaseModelAtomClass
			BlobDef empty
			BoolDef empty
			EnumDef empty
			Id16Gen serviceReqCheckGenericMinValue
			Id32Gen serviceReqCheckGenericMinValue
			Id64Gen serviceReqCheckGenericMinValue
			Int16Def serviceReqCheckGenericMinValue
			Int32Def serviceReqCheckGenericMinValue
			Int64Def serviceReqCheckGenericMinValue
			UInt16Def serviceReqCheckGenericMinValue
			UInt32Def serviceReqCheckGenericMinValue
			UInt64Def serviceReqCheckObjectMinValue
			FloatDef serviceReqCheckGenericMinValue
			DoubleDef serviceReqCheckGenericMinValue
			NumberDef serviceReqCheckObjectMinValue
			DateDef serviceReqCheckObjectMinValue
			TimeDef empty
			TimestampDef serviceReqCheckObjectMinValue
			TZDateDef serviceReqCheckObjectMinValue
			TZTimeDef empty
			TZTimestampDef serviceReqCheckObjectMinValue
			DbKeyHash128Gen empty
			DbKeyHash160Gen empty
			DbKeyHash224Gen empty
			DbKeyHash256Gen empty
			DbKeyHash384Gen empty
			DbKeyHash512Gen empty
			DbKeyHash128Def empty
			DbKeyHash160Def empty
			DbKeyHash224Def empty
			DbKeyHash256Def empty
			DbKeyHash384Def empty
			DbKeyHash512Def empty
			Uuid6Gen empty
			Uuid6Def empty
			UuidGen empty
			UuidDef empty
			StringDef empty
			TokenDef empty
			NmTokenDef empty
			NmTokensDef empty
			TextDef empty
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="serviceReqCheckGenericMinValue">
		if( data.get$implColumnAttrOptionality$$Name$() &lt; $DefSchemaName$$TableName$.$upper Name$_MIN_VALUE ) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$(),
				$DefSchemaName$$TableName$.$upper Name$_MIN_VALUE );
		}</GenRule>

	<GenRule GenDef="Value" Name="serviceReqCheckObjectMinValue">
		if( data.get$implColumnAttrOptionality$$Name$() != null &amp;&amp; get$implColumnAttrOptionality$$Name$().compareTo($DefSchemaName$$TableName$.$upper Name$_MIN_VALUE) &lt; 0) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$().toString(),
				$DefSchemaName$$TableName$.$upper Name$_MIN_VALUE.toString() );
		}</GenRule>

	<GenRule GenDef="Value" Name="serviceReqCheckMaxValue"
		>$switch BaseModelAtomClass
			BoolDef empty
			Id16Gen serviceReqCheckGenericMaxValue
			Id32Gen serviceReqCheckGenericMaxValue
			Id64Gen serviceReqCheckGenericMaxValue
			Int16Def serviceReqCheckGenericMaxValue
			Int32Def serviceReqCheckGenericMaxValue
			Int64Def serviceReqCheckGenericMaxValue
			UInt16Def serviceReqCheckGenericMaxValue
			UInt32Def serviceReqCheckGenericMaxValue
			UInt64Def serviceReqCheckObjectMaxValue
			FloatDef serviceReqCheckGenericMaxValue
			DoubleDef serviceReqCheckGenericMaxValue
			NumberDef serviceReqCheckObjectMaxValue
			DateDef serviceReqCheckObjectMaxValue
			TimeDef empty
			TimestampDef serviceReqCheckObjectMaxValue
			TZDateDef serviceReqCheckObjectMaxValue
			TZTimeDef empty
			TZTimestampDef serviceReqCheckObjectMaxValue
			StringDef empty
			TokenDef empty
			NmTokenDef empty
			NmTokensDef empty
			TextDef empty
			DbKeyHash128Gen empty
			DbKeyHash160Gen empty
			DbKeyHash224Gen empty
			DbKeyHash256Gen empty
			DbKeyHash384Gen empty
			DbKeyHash512Gen empty
			DbKeyHash128Def empty
			DbKeyHash160Def empty
			DbKeyHash224Def empty
			DbKeyHash256Def empty
			DbKeyHash384Def empty
			DbKeyHash512Def empty
			Uuid6Gen empty
			Uuid6Def empty
			UuidGen empty
			UuidDef empty
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="serviceReqCheckGenericMaxValue">
		if( data.get$implColumnAttrOptionality$$Name$() &gt; $DefSchemaName$$TableName$.$upper Name$_MAX_VALUE ) {
			throw new CFLibArgumentOverflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$(),
				$DefSchemaName$$TableName$.$upper Name$_MAX_VALUE );
		}</GenRule>

	<GenRule GenDef="Value" Name="serviceReqCheckObjectMaxValue">
		if( data.get$implColumnAttrOptionality$$Name$() != null &amp;&amp; get$implColumnAttrOptionality$$Name$().compareTo($DefSchemaName$$TableName$.$upper Name$_MIN_VALUE) &gt; 0) {
			throw new CFLibArgumentOverflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$().toString(),
				$DefSchemaName$$TableName$.$upper Name$_MAX_VALUE.toString() );
		}</GenRule>

	<GenRule GenDef="Value" Name="serviceOptCheckMinValue"
		>$switch BaseModelAtomClass
			BlobDef empty
			BoolDef empty
			EnumDef empty
			Id16Gen serviceOptCheckGenericMinValue
			Id32Gen serviceOptCheckGenericMinValue
			Id64Gen serviceOptCheckGenericMinValue
			Int16Def serviceOptCheckGenericMinValue
			Int32Def serviceOptCheckGenericMinValue
			Int64Def serviceOptCheckGenericMinValue
			UInt16Def serviceOptCheckGenericMinValue
			UInt32Def serviceOptCheckGenericMinValue
			UInt64Def serviceOptCheckObjectMinValue
			FloatDef serviceOptCheckGenericMinValue
			DoubleDef serviceOptCheckGenericMinValue
			NumberDef serviceOptCheckObjectMinValue
			DateDef serviceOptCheckObjectMinValue
			TimeDef empty
			TimestampDef serviceOptCheckObjectMinValue
			TZDateDef serviceOptCheckObjectMinValue
			TZTimeDef empty
			TZTimestampDef serviceOptCheckObjectMinValue
			DbKeyHash128Gen empty
			DbKeyHash160Gen empty
			DbKeyHash224Gen empty
			DbKeyHash256Gen empty
			DbKeyHash384Gen empty
			DbKeyHash512Gen empty
			DbKeyHash128Def empty
			DbKeyHash160Def empty
			DbKeyHash224Def empty
			DbKeyHash256Def empty
			DbKeyHash384Def empty
			DbKeyHash512Def empty
			Uuid6Gen empty
			Uuid6Def empty
			UuidGen empty
			UuidDef empty
			StringDef serviceOptCheckObjectMinValue
			TokenDef serviceOptCheckObjectMinValue
			NmTokenDef serviceOptCheckObjectMinValue
			NmTokensDef serviceOptCheckObjectMinValue
			TextDef serviceOptCheckObjectMinValue
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="serviceOptCheckGenericMinValue">
		if( data.get$implColumnAttrOptionality$$Name$() != null &amp;&amp; data.get$implColumnAttrOptionality$$Name$().compareTo($DefSchemaName$$TableName$.$upper Name$_MIN_VALUE) &lt; 0) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$(),
				$DefSchemaName$$TableName$.$upper Name$_MIN_VALUE );
		}</GenRule>
	<GenRule GenDef="Value" Name="serviceOptCheckObjectMinValue">
		if( data.get$implColumnAttrOptionality$$Name$() != null &amp;&amp; data.get$implColumnAttrOptionality$$Name$().compareTo($DefSchemaName$$TableName$.$upper Name$_MIN_VALUE) &lt; 0) {
			throw new CFLibArgumentUnderflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$().toString(),
				$DefSchemaName$$TableName$.$upper Name$_MIN_VALUE.toString() );
		}</GenRule>

	<GenRule GenDef="Value" Name="serviceOptCheckMaxValue"
		>$switch BaseModelAtomClass
			BlobDef empty
			BoolDef empty
			EnumDef empty
			Id16Gen serviceOptCheckGenericMaxValue
			Id32Gen serviceOptCheckGenericMaxValue
			Id64Gen serviceOptCheckGenericMaxValue
			Int16Def serviceOptCheckGenericMaxValue
			Int32Def serviceOptCheckGenericMaxValue
			Int64Def serviceOptCheckGenericMaxValue
			UInt16Def serviceOptCheckGenericMaxValue
			UInt32Def serviceOptCheckGenericMaxValue
			UInt64Def serviceOptCheckObjectMaxValue
			FloatDef serviceOptCheckGenericMaxValue
			DoubleDef serviceOptCheckGenericMaxValue
			NumberDef serviceOptCheckObjectMaxValue
			DateDef serviceOptCheckObjectMaxValue
			TimeDef empty
			TimestampDef serviceOptCheckObjectMaxValue
			TZDateDef serviceOptCheckObjectMaxValue
			TZTimeDef empty
			TZTimestampDef serviceOptCheckObjectMaxValue
			DbKeyHash128Gen empty
			DbKeyHash160Gen empty
			DbKeyHash224Gen empty
			DbKeyHash256Gen empty
			DbKeyHash384Gen empty
			DbKeyHash512Gen empty
			DbKeyHash128Def empty
			DbKeyHash160Def empty
			DbKeyHash224Def empty
			DbKeyHash256Def empty
			DbKeyHash384Def empty
			DbKeyHash512Def empty
			Uuid6Gen empty
			Uuid6Def empty
			UuidGen empty
			UuidDef empty
			StringDef serviceOptCheckObjectMaxValue
			TokenDef serviceOptCheckObjectMaxValue
			NmTokenDef serviceOptCheckObjectMaxValue
			NmTokensDef serviceOptCheckObjectMaxValue
			TextDef serviceOptCheckObjectMaxValue
			default ErrorUnrecognizedBaseModelAtomClass$</GenRule>

	<GenRule GenDef="Value" Name="serviceOptCheckGenericMaxValue">
		if( data.get$implColumnAttrOptionality$$Name$() != null &amp;&amp; data.get$implColumnAttrOptionality$$Name$().compareTo($DefSchemaName$$TableName$.$upper Name$_MAX_VALUE) &gt; 0) {
			throw new CFLibArgumentOverflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$(),
				$DefSchemaName$$TableName$.$upper Name$_MAX_VALUE );
		}</GenRule>
	<GenRule GenDef="Value" Name="serviceOptCheckObjectMaxValue">
		if( data.get$implColumnAttrOptionality$$Name$() != null &amp;&amp; data.get$implColumnAttrOptionality$$Name$().compareTo($DefSchemaName$$TableName$.$upper Name$_MAX_VALUE) &gt; 0) {
			throw new CFLibArgumentOverflowException( getClass(),
				S_ProcName,
				0,
				"get$implColumnAttrOptionality$$Name$()",
				data.get$implColumnAttrOptionality$$Name$().toString(),
				$DefSchemaName$$TableName$.$upper Name$_MAX_VALUE.toString() );
		}</GenRule>

</RuleSet>
